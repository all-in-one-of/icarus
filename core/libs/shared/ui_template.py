#!/usr/bin/python

# [Icarus] ui_template.py
#
# Mike Bonnington <mike.bonnington@gps-ldn.com>
# (c) 2018 Gramercy Park Studios
#
# UI Template.
# A class derived from QMainWindow to act as a template for all windows and
# dialogs.


import os

from Qt import QtCompat, QtCore, QtGui, QtWidgets
import rsc_rc  # Import resource file as generated by pyside-rcc

# Import custom modules
import osOps
import settingsData
#import userPrefs
import verbose


# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------

# Set window title and object names
WINDOW_TITLE = "Custom Window"
WINDOW_OBJECT = "customUI"

# Set the UI and the stylesheet
UI_FILE = "settings_test_ui.ui"
STYLESHEET = "style.qss"  # Set to None to use the parent app's stylesheet

# Prevent spawned processes from opening a shell window
CREATE_NO_WINDOW = 0x08000000


# ----------------------------------------------------------------------------
# Main window class
# ----------------------------------------------------------------------------

class TemplateUI(QtWidgets.QMainWindow):
	""" Main window class.
	"""
	def __init__(self, parent=None):
		super(TemplateUI, self).__init__(parent)
		self.parent = parent

		# # Set object name and window title
		# self.setObjectName(WINDOW_OBJECT)
		# self.setWindowTitle(WINDOW_TITLE)

		# # Load UI & stylesheet
		# self.ui = QtCompat.load_ui(fname=os.path.join(os.environ['IC_FORMSDIR'], UI_FILE))
		# self.reloadStyleSheet()

		# # Set the main widget
		# self.setCentralWidget(self.ui)

		# # Set window flags
		# self.setWindowFlags(QtCore.Qt.Tool)

		# # Set up keyboard shortcuts
		# self.shortcutReloadStyleSheet = QtWidgets.QShortcut(self)
		# self.shortcutReloadStyleSheet.setKey('Ctrl+R')
		# self.shortcutReloadStyleSheet.activated.connect(self.reloadStyleSheet)

		# Connect signals & slots
		# pass


	def display(self):
		""" Display the window.
		"""
		self.returnValue = False

		# Read user prefs config file - if it doesn't exist it will be created
		#userPrefs.read()

		# Instantiate XML data classes
		self.xd = settingsData.settingsData()
		#xd_load = self.xd.loadXML(self.xmlData)

		self.xmlData = settingsFile
		self.xd.loadXML(self.xmlData)
		self.setupWidgets(self.ui)

		self.show()
		self.raise_()

		return self.returnValue


	# def sceneBrowse(self):
	# 	""" Browse for a scene/script file.
	# 	"""
	# 	if self.jobType == 'Maya':
	# 		fileDir = os.environ.get('MAYASCENESDIR', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'Maya files (*.ma *.mb)'
	# 		fileTerminology = 'scenes'
	# 	elif self.jobType == 'Nuke':
	# 		fileDir = os.environ.get('NUKESCRIPTSDIR', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'Nuke files (*.nk)'
	# 		fileTerminology = 'scripts'
	# 	else:
	# 		fileDir = os.environ.get('JOBPATH', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'All files (*.*)'
	# 		fileTerminology = 'commands'

	# 	currentDir = os.path.dirname(self.makePathAbsolute(self.ui.scene_comboBox.currentText()))
	# 	if os.path.exists(currentDir):
	# 		startingDir = currentDir
	# 	else:
	# 		startingDir = fileDir

	# 	filePath = QtWidgets.QFileDialog.getOpenFileName(self, self.tr('Files'), startingDir, fileFilter)
	# 	if filePath[0]:
	# 		newEntry = self.makePathRelative(osOps.absolutePath(filePath[0]))
	# 		#newEntry = osOps.absolutePath(filePath[0])
	# 		if newEntry:
	# 			self.ui.scene_comboBox.removeItem(self.ui.scene_comboBox.findText(newEntry))  # If the entry already exists in the list, delete it
	# 			self.ui.scene_comboBox.insertItem(0, newEntry)
	# 			self.ui.scene_comboBox.setCurrentIndex(0)  # Always insert the new entry at the top of the list and select it
	# 		else:
	# 			verbose.warning("Only %s belonging to the current shot can be submitted." %fileTerminology)


	def setupWidgets(self, category, storeProperties=True):
		""" Set up all the child widgets of the specified parent object.
		"""


	def setupExpandableGroupBoxes(self, parentObject):
		""" Enable expansion of custom rollout group box controls.
		"""
		for groupBox in parentObject.findChildren(QtWidgets.QGroupBox):
			if groupBox.property('expandable'):
				groupBox.setCheckable(True)
				#groupBox.setChecked(expand)
				groupBox.setFixedHeight(groupBox.sizeHint().height())
				groupBox.toggled.connect(self.toggleExpandGroup)


	# @QtCore.Slot()
	def toggleExpandGroup(self):
		""" Toggle expansion of custom rollout group box control.
		"""
		groupBox = self.sender()
		state = groupBox.isChecked()
		if state:
			groupBox.setFixedHeight(groupBox.sizeHint().height())
		else:
			groupBox.setFixedHeight(20)  # Slightly hacky - needs to match value defined in QSS


	# ------------------------------------------------------------------------
	# Widget handlers

	def setupWidgets(self, parentObject, category, storeProperties=True):
		""" Set up all the child widgets of the specified parent object.
		"""
		for widget in parentObject.findChildren(QtWidgets.QWidget):

			# Set up handler for push buttons...
			if widget.property('exec'):
				if isinstance(widget, QtWidgets.QPushButton):
					widget.clicked.connect(self.execPushButton)

			# Set up handlers for different widget types & apply values
			attr = widget.property('xmlTag')
			if attr:
				value = self.xd.getValue(category, attr)

				# Spin boxes...
				if isinstance(widget, QtWidgets.QSpinBox):
					if value is not "":
						widget.setValue(int(value))
					if storeProperties:
						self.storeValue(attr, widget.value())
					widget.valueChanged.connect(self.storeSpinBoxValue)

				# Double spin boxes...
				elif isinstance(widget, QtWidgets.QDoubleSpinBox):
					if value is not "":
						widget.setValue(float(value))
					if storeProperties:
						self.storeValue(attr, widget.value())
					widget.valueChanged.connect(self.storeSpinBoxValue)

				# Line edits...
				elif isinstance(widget, QtWidgets.QLineEdit):
					if value is not "":
						widget.setText(value)
					if storeProperties:
						self.storeValue(attr, widget.text())
					widget.textEdited.connect(self.storeLineEditValue)

				# Plain text edits...
				elif isinstance(widget, QtWidgets.QPlainTextEdit):
					if value is not "":
						widget.setPlainText(value)
					if storeProperties:
						self.storeValue(attr, widget.toPlainText())
					widget.textChanged.connect(self.storeTextEditValue)

				# Check boxes...
				elif isinstance(widget, QtWidgets.QCheckBox):
					if value is not "":
						if value == "True":
							widget.setCheckState(QtCore.Qt.Checked)
						elif value == "False":
							widget.setCheckState(QtCore.Qt.Unchecked)
					if storeProperties:
						self.storeValue(attr, self.getCheckBoxValue(widget))
					widget.toggled.connect(self.storeCheckBoxValue)

				# Radio buttons...
				elif isinstance(widget, QtWidgets.QRadioButton):
					if value is not "":
						widget.setAutoExclusive(False)
						if value == widget.text():
							widget.setChecked(True)
						else:
							widget.setChecked(False)
						widget.setAutoExclusive(True)
					if storeProperties:
						if widget.isChecked():
							self.storeValue(attr, widget.text())
					widget.toggled.connect(self.storeRadioButtonValue)

				# Combo boxes...
				elif isinstance(widget, QtWidgets.QComboBox):
					if value is not "":
						if widget.findText(value) == -1:
							self.ui.pool_comboBox.addItem(value)
						widget.setCurrentIndex(widget.findText(value))
					if storeProperties:
						self.storeValue(attr, widget.currentText())
					widget.currentIndexChanged.connect(self.storeComboBoxValue)


	def getCheckBoxValue(self, checkBox):
		""" Get the value from a checkbox and return a Boolean value.
		"""
		if checkBox.checkState() == QtCore.Qt.Checked:
			return True
		else:
			return False


	# # @QtCore.Slot()
	# def storeWidgetValue(self):
	# 	widget = self.sender()
	# 	attr = widget.property('xmlTag')

	# 	if isinstance(widget, QtWidgets.QSpinBox):
	# 		value = widget.value()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QDoubleSpinBox):
	# 		value = widget.value()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QLineEdit):
	# 		value = widget.text()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QPlainTextEdit):
	# 		value = widget.toPlainText()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QCheckBox):
	# 		value = self.getCheckBoxValue(widget)
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QRadioButton):
	# 		if widget.isChecked():
	# 			value = widget.text()
	# 			self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QComboBox):
	# 		value = widget.currentText()
	# 		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeSpinBoxValue(self):
		""" Get the value from a Spin Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().value()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeLineEditValue(self):
		""" Get the value from a Line Edit and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().text()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeTextEditValue(self):
		""" Get the value from a Plain Text Edit and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().toPlainText()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeCheckBoxValue(self):
		""" Get the value from a Check Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.getCheckBoxValue(self.sender())
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeRadioButtonValue(self):
		""" Get the value from a Radio Button group and store in XML data.
		"""
		if self.sender().isChecked():
			attr = self.sender().property('xmlTag')
			value = self.sender().text()
			self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeComboBoxValue(self):
		""" Get the value from a Combo Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().currentText()
		self.storeValue(attr, value)


	def storeValue(self, attr, value=""):
		""" Store value in XML data.
		"""
		verbose.print_("%20s %s.%s=%s" %(type(value), category, attr, value))
		# userPrefs.edit(category, attr, value)
		self.xd.setValue(category, attr, str(value))

	# End widget handlers
	# ------------------------------------------------------------------------


	def strToList(self, string):
		""" Convert string to list by splitting into lines.
			Encode bytes to string for Python 3.
		"""
		string = string.decode()
		ls = string.splitlines()
		verbose.print_(ls)
		return ls


	def populateComboBox(self, comboBox, contentsLs):
		""" Populate combo box.
		"""
		# Store current value
		current = comboBox.currentText()

		# Clear menu
		comboBox.clear()

		# Populate menu
		for item in contentsLs:
			if item:
				comboBox.addItem(item)

		# Set to current value
		index = comboBox.findText(current)
		if index == -1:
			comboBox.setCurrentIndex(0)
		else:
			comboBox.setCurrentIndex(index)




	def reloadStyleSheet(self):
		""" Reload stylesheet.
		"""
		if STYLESHEET is not None:
			qss=os.path.join(os.environ['IC_FORMSDIR'], STYLESHEET)
			with open(qss, "r") as fh:
				self.ui.setStyleSheet(fh.read())


	def showEvent(self, event):
		""" Event handler for when window is shown.
		"""
		pass


	def save(self):
		""" Save data.
		"""
		if self.xd.saveXML():
			verbose.message("Settings saved.")
			return True
		else:
			verbose.error("Settings could not be saved.")
			return False


	def saveAndExit(self):
		""" Save data and close window.
		"""
		if self.save():
			self.returnValue = True
			self.hide()
		else:
			self.exit()


	def exit(self):
		""" Exit the dialog.
		"""
		self.returnValue = False
		self.hide()

# ----------------------------------------------------------------------------
# End of main window class
# ----------------------------------------------------------------------------


# def run_(**kwargs):
# 	# for key, value in kwargs.iteritems():
# 	# 	print "%s = %s" % (key, value)
# 	customUI = TemplateUI(**kwargs)
# 	#customUI.setAttribute( QtCore.Qt.WA_DeleteOnClose )
# 	print customUI
# 	customUI.show()
# 	#customUI.raise_()
# 	#customUI.exec_()


# ----------------------------------------------------------------------------
# DCC application helper functions - MOVE TO MODULE
# ----------------------------------------------------------------------------

def _maya_delete_ui():
	""" Delete existing UI in Maya.
	"""
	if mc.window(WINDOW_OBJECT, query=True, exists=True):
		mc.deleteUI(WINDOW_OBJECT)  # Delete window
	if mc.dockControl('MayaWindow|' + WINDOW_TITLE, query=True, exists=True):
		mc.deleteUI('MayaWindow|' + WINDOW_TITLE)  # Delete docked window


def _nuke_delete_ui():
	""" Delete existing UI in Nuke.
	"""
	for obj in QtWidgets.QApplication.allWidgets():
		if obj.objectName() == WINDOW_OBJECT:
			obj.deleteLater()


def _maya_main_window():
	""" Return Maya's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if obj.objectName() == 'MayaWindow':
			return obj
	raise RuntimeError("Could not find MayaWindow instance")


def _nuke_main_window():
	""" Returns Nuke's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'):
			return obj
	raise RuntimeError("Could not find DockMainWindow instance")


# ----------------------------------------------------------------------------
# Run functions
# ----------------------------------------------------------------------------

def run_maya(**kwargs):
	""" Run in Maya.
	"""
	_maya_delete_ui()  # Delete any already existing UI
	customUI = TemplateUI(parent=_maya_main_window())

	# Makes Maya perform magic which makes the window stay on top in OS X and
	# Linux. As an added bonus, it'll make Maya remember the window position.
	customUI.setProperty("saveWindowPref", True)

	customUI.display(**kwargs)  # Show the UI


def run_nuke(**kwargs):
	""" Run in Nuke.
	"""
	_nuke_delete_ui()  # Delete any already existing UI
	customUI = TemplateUI(parent=_nuke_main_window())

	customUI.display(**kwargs)  # Show the UI


# Detect environment and run application
if os.environ['IC_ENV'] == 'STANDALONE':
	verbose.print_("[GPS] %s" %WINDOW_TITLE)
elif os.environ['IC_ENV'] == 'MAYA':
	import maya.cmds as mc
	verbose.print_("[GPS] %s for Maya" %WINDOW_TITLE)
	# run_maya()
elif os.environ['IC_ENV'] == 'NUKE':
	import nuke
	import nukescripts
	verbose.print_("[GPS] %s for Nuke" %WINDOW_TITLE)
	# run_nuke()
# elif __name__ == '__main__':
# 	run_standalone()

