#!/usr/bin/python

# [Icarus] ui_template.py
#
# Mike Bonnington <mike.bonnington@gps-ldn.com>
# (c) 2018 Gramercy Park Studios
#
# UI Template.
# A class derived from QMainWindow to act as a template for all windows and
# dialogs.
# This module provides windowing / UI helper functions for better integration
# of PySide / PyQt UIs in supported DCC applications.
# Currently only supports Maya and Nuke.


import os

from Qt import QtCompat, QtCore, QtGui, QtWidgets
import rsc_rc  # Import resource file as generated by pyside-rcc

# Import custom modules
import osOps
import settingsData
#import userPrefs
import verbose


# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------

VENDOR = "Gramercy Park Studios"
COPYRIGHT = "(c) 2013-2018"
DEVELOPERS = "Nuno Pereira, Mike Bonnington"

# Set window title and object names
# WINDOW_TITLE = "Custom Window"
# WINDOW_OBJECT = "customUI"

# Set the UI and the stylesheet
# UI_FILE = "settings_test_ui.ui"
# STYLESHEET = "style.qss"  # Set to None to use the parent app's stylesheet

# Prevent spawned processes from opening a shell window
CREATE_NO_WINDOW = 0x08000000


# ----------------------------------------------------------------------------
# Main window class
# ----------------------------------------------------------------------------

class TemplateUI(QtWidgets.QMainWindow):
	""" Main window class.
	"""
	def __init__(self, parent=None):
		super(TemplateUI, self).__init__(parent)

		# Instantiate XML data classes
		self.xd = settingsData.settingsData()


	def setupUI(self, WINDOW_OBJECT, WINDOW_TITLE, UI_FILE, STYLESHEET):
		""" Setup the UI.
		"""
		# Set object name and window title
		self.setObjectName(WINDOW_OBJECT)
		self.setWindowTitle(WINDOW_TITLE)

		# Load UI & stylesheet
		self.ui = QtCompat.load_ui(fname=os.path.join(os.environ['IC_FORMSDIR'], UI_FILE))
		self.reloadStyleSheet(STYLESHEET)

		# Set the main widget & perform custom widget setup
		self.setCentralWidget(self.ui)
		self.setupWidgets(self.ui)

		# Restore window geometry and state
		if os.environ['IC_ENV'] == 'STANDALONE':
			# (Restore state may cause issues with PyQt5)
			verbose.print_("Restoring window geometry.")
			try:
				#print(self.windowTitle())
				self.settings = QtCore.QSettings(VENDOR, WINDOW_TITLE)
				self.restoreGeometry(self.settings.value("geometry", ""))
				# self.restoreState(self.settings.value("windowState", ""))
			except:
				pass

		elif os.environ['IC_ENV'] == 'MAYA':
			# Makes Maya perform magic which makes the window stay on top in
			# OS X and Linux. As an added bonus, it'll make Maya remember the
			# window position.
			self.setProperty("saveWindowPref", True)

		elif os.environ['IC_ENV'] == 'NUKE':
			pass




	# def fileDialog(self, dialogHome):
	# 	""" Opens a dialog from which to select a single file.
	# 		The env check puts the main window in the background so dialog pop
	# 		up can return properly when running inside certain applications.
	# 		The window flags bypass a Mac bug that made the dialog always
	# 		appear under the Icarus window. This is ignored in a Linux env.
	# 	"""
	# 	envOverride = ['MAYA', 'NUKE']
	# 	if os.environ['IC_ENV'] in envOverride:
	# 		if os.environ['IC_RUNNING_OS'] == 'Darwin':
	# 			self.setWindowFlags(QtCore.Qt.WindowStaysOnBottomHint | QtCore.Qt.X11BypassWindowManagerHint | QtCore.Qt.WindowCloseButtonHint)
	# 			self.show()
	# 		dialog = QtWidgets.QFileDialog.getOpenFileName(self, self.tr('Files'), dialogHome, 'All files (*.*)')
	# 		if os.environ['IC_RUNNING_OS'] == 'Darwin':
	# 			self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.X11BypassWindowManagerHint | QtCore.Qt.WindowCloseButtonHint)
	# 			self.show()
	# 	else:
	# 		dialog = QtWidgets.QFileDialog.getOpenFileName(self, self.tr('Files'), dialogHome, 'All files (*.*)')

	# 	return dialog[0]


	# def folderDialog(self, dialogHome):
	# 	""" Opens a dialog from which to select a folder.
	# 		The env check puts the main window in the background so dialog pop
	# 		up can return properly when running inside certain applications.
	# 		The window flags bypass a Mac bug that made the dialog always
	# 		appear under the Icarus window. This is ignored in a Linux env.
	# 	"""
	# 	envOverride = ['MAYA', 'NUKE']
	# 	if os.environ['IC_ENV'] in envOverride:
	# 		if os.environ['IC_RUNNING_OS'] == 'Darwin':
	# 			self.setWindowFlags(QtCore.Qt.WindowStaysOnBottomHint | QtCore.Qt.X11BypassWindowManagerHint | QtCore.Qt.WindowCloseButtonHint)
	# 			self.show()
	# 		dialog = QtWidgets.QFileDialog.getExistingDirectory(self, self.tr('Directory'), dialogHome, QtWidgets.QFileDialog.DontResolveSymlinks | QtWidgets.QFileDialog.ShowDirsOnly)
	# 		if os.environ['IC_RUNNING_OS'] == 'Darwin':
	# 			self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.X11BypassWindowManagerHint | QtCore.Qt.WindowCloseButtonHint)
	# 			self.show()
	# 	else:
	# 		dialog = QtWidgets.QFileDialog.getExistingDirectory(self, self.tr('Directory'), dialogHome, QtWidgets.QFileDialog.DontResolveSymlinks | QtWidgets.QFileDialog.ShowDirsOnly)

	# 	return dialog


	# def sceneBrowse(self):
	# 	""" Browse for a scene/script file.
	# 	"""
	# 	if self.jobType == 'Maya':
	# 		fileDir = os.environ.get('MAYASCENESDIR', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'Maya files (*.ma *.mb)'
	# 		fileTerminology = 'scenes'
	# 	elif self.jobType == 'Nuke':
	# 		fileDir = os.environ.get('NUKESCRIPTSDIR', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'Nuke files (*.nk)'
	# 		fileTerminology = 'scripts'
	# 	else:
	# 		fileDir = os.environ.get('JOBPATH', '.')  # Go to current dir if env var is not set
	# 		fileFilter = 'All files (*.*)'
	# 		fileTerminology = 'commands'

	# 	currentDir = os.path.dirname(self.makePathAbsolute(self.ui.scene_comboBox.currentText()))
	# 	if os.path.exists(currentDir):
	# 		startingDir = currentDir
	# 	else:
	# 		startingDir = fileDir

	# 	filePath = QtWidgets.QFileDialog.getOpenFileName(self, self.tr('Files'), startingDir, fileFilter)
	# 	if filePath[0]:
	# 		newEntry = self.makePathRelative(osOps.absolutePath(filePath[0]))
	# 		#newEntry = osOps.absolutePath(filePath[0])
	# 		if newEntry:
	# 			self.ui.scene_comboBox.removeItem(self.ui.scene_comboBox.findText(newEntry))  # If the entry already exists in the list, delete it
	# 			self.ui.scene_comboBox.insertItem(0, newEntry)
	# 			self.ui.scene_comboBox.setCurrentIndex(0)  # Always insert the new entry at the top of the list and select it
	# 		else:
	# 			verbose.warning("Only %s belonging to the current shot can be submitted." %fileTerminology)


	# ------------------------------------------------------------------------
	# Widget handlers

	def setupWidgets(self, parentObject, storeProperties=True, updateOnly=False):
		""" Set up all the child widgets of the specified parent object.
			If 'storeProperties' is True, the values will be stored in the XML
			data as well as applied to the widgets.
			If 'updateOnly' is True, only the widgets' values will be updated.
		"""
		if updateOnly:
			storeProperties = False

		for widget in parentObject.findChildren(QtWidgets.QWidget):

			# Enable expansion of custom rollout group box controls...
			if widget.property('expandable'):
				if isinstance(widget, QtWidgets.QGroupBox):
					widget.setCheckable(True)
					# widget.setChecked(expand)
					widget.setFixedHeight(widget.sizeHint().height())
					if not updateOnly:
						widget.toggled.connect(self.toggleExpandGroup)

			# Set up handler for push buttons...
			if widget.property('exec'):
				if isinstance(widget, QtWidgets.QPushButton):
					if not updateOnly:
						widget.clicked.connect(self.execPushButton)

			# Set up handlers for different widget types & apply values
			attr = widget.property('xmlTag')
			if attr:
				self.base_widget = widget.objectName()
				category = self.findCategory(widget)
				if category:
					widget.setProperty('xmlCategory', category)
					value = self.xd.getValue(category, attr)

					# Spin boxes...
					if isinstance(widget, QtWidgets.QSpinBox):
						if value is not "":
							widget.setValue(int(value))
						if storeProperties:
							self.storeValue(category, attr, widget.value())
						if not updateOnly:
							widget.valueChanged.connect(self.storeSpinBoxValue)

					# Double spin boxes...
					elif isinstance(widget, QtWidgets.QDoubleSpinBox):
						if value is not "":
							widget.setValue(float(value))
						if storeProperties:
							self.storeValue(category, attr, widget.value())
						if not updateOnly:
							widget.valueChanged.connect(self.storeSpinBoxValue)

					# Line edits...
					elif isinstance(widget, QtWidgets.QLineEdit):
						if value is not "":
							widget.setText(value)
						if storeProperties:
							self.storeValue(category, attr, widget.text())
						if not updateOnly:
							# widget.textEdited.connect(self.storeLineEditValue)
							widget.textChanged.connect(self.storeLineEditValue)

					# Plain text edits...
					elif isinstance(widget, QtWidgets.QPlainTextEdit):
						if value is not "":
							widget.setPlainText(value)
						if storeProperties:
							self.storeValue(category, attr, widget.toPlainText())
						if not updateOnly:
							widget.textChanged.connect(self.storeTextEditValue)

					# Check boxes...
					elif isinstance(widget, QtWidgets.QCheckBox):
						if value is not "":
							if value == "True":
								widget.setCheckState(QtCore.Qt.Checked)
							elif value == "False":
								widget.setCheckState(QtCore.Qt.Unchecked)
						if storeProperties:
							self.storeValue(category, attr, self.getCheckBoxValue(widget))
						if not updateOnly:
							widget.toggled.connect(self.storeCheckBoxValue)

					# Radio buttons...
					elif isinstance(widget, QtWidgets.QRadioButton):
						if value is not "":
							widget.setAutoExclusive(False)
							if value == widget.text():
								widget.setChecked(True)
							else:
								widget.setChecked(False)
							widget.setAutoExclusive(True)
						if storeProperties:
							if widget.isChecked():
								self.storeValue(category, attr, widget.text())
						if not updateOnly:
							widget.toggled.connect(self.storeRadioButtonValue)

					# Combo boxes...
					elif isinstance(widget, QtWidgets.QComboBox):
						if value is not "":
							if widget.findText(value) == -1:
								widget.addItem(value)
							widget.setCurrentIndex(widget.findText(value))
						if storeProperties:
							self.storeValue(category, attr, widget.currentText())
						if not updateOnly:
							if widget.isEditable():
								widget.editTextChanged.connect(self.storeComboBoxValue)
							else:
								widget.currentIndexChanged.connect(self.storeComboBoxValue)


	def findCategory(self, widget):
		""" Recursively check the parents of the given widget until a custom
			property 'xmlCategory' is found.
		"""
		if widget.property('xmlCategory'):
			#verbose.print_("Category '%s' found for '%s'." %(widget.property('xmlCategory'), widget.objectName()))
			return widget.property('xmlCategory')
		else:
			# Stop iterating if the widget's parent in the main window...
			if isinstance(widget.parent(), QtWidgets.QMainWindow):
				verbose.warning("No category could be found for '%s'. The widget's value cannot be stored." %self.base_widget)
				return None
			else:
				return self.findCategory(widget.parent())


	def getCheckBoxValue(self, checkBox):
		""" Get the value from a checkbox and return a Boolean value.
		"""
		if checkBox.checkState() == QtCore.Qt.Checked:
			return True
		else:
			return False


	# @QtCore.Slot()
	def storeSpinBoxValue(self):
		""" Get the value from a Spin Box and store in XML data.
		"""
		category = self.sender().property('xmlCategory')
		attr = self.sender().property('xmlTag')
		value = self.sender().value()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeLineEditValue(self):
		""" Get the value from a Line Edit and store in XML data.
		"""
		category = self.sender().property('xmlCategory')
		attr = self.sender().property('xmlTag')
		value = self.sender().text()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeTextEditValue(self):
		""" Get the value from a Plain Text Edit and store in XML data.
		"""
		category = self.sender().property('xmlCategory')
		attr = self.sender().property('xmlTag')
		value = self.sender().toPlainText()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeCheckBoxValue(self):
		""" Get the value from a Check Box and store in XML data.
		"""
		category = self.sender().property('xmlCategory')
		attr = self.sender().property('xmlTag')
		value = self.getCheckBoxValue(self.sender())
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeRadioButtonValue(self):
		""" Get the value from a Radio Button group and store in XML data.
		"""
		if self.sender().isChecked():
			category = self.sender().property('xmlCategory')
			attr = self.sender().property('xmlTag')
			value = self.sender().text()
			self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeComboBoxValue(self):
		""" Get the value from a Combo Box and store in XML data.
		"""
		category = self.sender().property('xmlCategory')
		attr = self.sender().property('xmlTag')
		value = self.sender().currentText()
		self.storeValue(category, attr, value)


	def storeValue(self, category, attr, value=""):
		""" Store value in XML data.
		"""
		verbose.print_("%20s %s.%s=%s" %(type(value), category, attr, value))
		# userPrefs.edit(category, attr, value)
		self.xd.setValue(category, attr, str(value))


	# @QtCore.Slot()
	def toggleExpandGroup(self):
		""" Toggle expansion of custom rollout group box control.
		"""
		groupBox = self.sender()
		state = groupBox.isChecked()
		if state:
			groupBox.setFixedHeight(groupBox.sizeHint().height())
		else:
			groupBox.setFixedHeight(20)  # Slightly hacky - needs to match value defined in QSS


	def populateComboBox(self, comboBox, contents_list):
		""" Use a list (contents_list) to populate a combo box.
		"""
		# Store current value
		current = comboBox.currentText()

		# Clear menu
		comboBox.clear()

		# Populate menu
		for item in contents_list:
			if item:
				comboBox.addItem(item)

		# Set to current value
		index = comboBox.findText(current)
		if index == -1:
			comboBox.setCurrentIndex(0)
		else:
			comboBox.setCurrentIndex(index)

	# End widget handlers
	# ------------------------------------------------------------------------


	def strToList(self, string):
		""" Convert string to list by splitting into lines.
			Encode bytes to string for Python 3.
		"""
		string = string.decode()
		ls = string.splitlines()
		#verbose.print_(ls)
		return ls


	def reloadStyleSheet(self, STYLESHEET):
		""" Reload stylesheet.
		"""
		if STYLESHEET is not None:
			qss=os.path.join(os.environ['IC_FORMSDIR'], STYLESHEET)
			with open(qss, "r") as fh:
				self.ui.setStyleSheet(fh.read())


	# def showEvent(self, event):
	# 	""" Event handler for when window is shown.
	# 	"""
	# 	pass


	def closeEvent(self, event):
		""" Event handler for when window is closed.
			Store window geometry and state.
			(Save state may cause issues with PyQt5)
		"""
		if os.environ['IC_ENV'] == 'STANDALONE':
			verbose.print_("Storing window geometry.")
			try:
				self.settings.setValue("geometry", self.saveGeometry())
				# self.settings.setValue("windowState", self.saveState())
			except:
				pass

			QtWidgets.QMainWindow.closeEvent(self, event)


	def save(self):
		""" Save data.
		"""
		if self.xd.saveXML():
			verbose.message("Settings saved.")
			return True
		else:
			verbose.error("Settings could not be saved.")
			return False


	def saveAndExit(self):
		""" Save data and close window.
		"""
		if self.save():
			self.returnValue = True
			self.hide()
		else:
			self.exit()


	def exit(self):
		""" Exit the window with negative return value.
		"""
		self.returnValue = False
		self.hide()

# ----------------------------------------------------------------------------
# End of main window class
# ----------------------------------------------------------------------------


# def run_(**kwargs):
# 	# for key, value in kwargs.iteritems():
# 	# 	print "%s = %s" % (key, value)
# 	customUI = TemplateUI(**kwargs)
# 	#customUI.setAttribute( QtCore.Qt.WA_DeleteOnClose )
# 	print customUI
# 	customUI.show()
# 	#customUI.raise_()
# 	#customUI.exec_()


# ----------------------------------------------------------------------------
# DCC application helper functions
# ----------------------------------------------------------------------------

def _maya_delete_ui(WINDOW_OBJECT, WINDOW_TITLE):
	""" Delete existing UI in Maya.
	"""
	if mc.window(WINDOW_OBJECT, query=True, exists=True):
		mc.deleteUI(WINDOW_OBJECT)  # Delete window
	if mc.dockControl('MayaWindow|' + WINDOW_TITLE, query=True, exists=True):
		mc.deleteUI('MayaWindow|' + WINDOW_TITLE)  # Delete docked window


def _nuke_delete_ui(WINDOW_OBJECT, WINDOW_TITLE):
	""" Delete existing UI in Nuke.
	"""
	for obj in QtWidgets.QApplication.allWidgets():
		if obj.objectName() == WINDOW_OBJECT:
			obj.deleteLater()


def _maya_main_window():
	""" Return Maya's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if obj.objectName() == 'MayaWindow':
			return obj
	raise RuntimeError("Could not find MayaWindow instance")


def _nuke_main_window():
	""" Returns Nuke's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'):
			return obj
	raise RuntimeError("Could not find DockMainWindow instance")


def _nuke_set_zero_margins(widget_object):
	""" Remove Nuke margins when docked UI.
		More info:
		https://gist.github.com/maty974/4739917
	"""
	parentApp = QtWidgets.QApplication.allWidgets()
	parentWidgetList = []
	for parent in parentApp:
		for child in parent.children():
			if widget_object.__class__.__name__ == child.__class__.__name__:
				parentWidgetList.append(parent.parentWidget())
				parentWidgetList.append(parent.parentWidget().parentWidget())
				parentWidgetList.append(parent.parentWidget().parentWidget().parentWidget())

				for sub in parentWidgetList:
					for tinychild in sub.children():
						try:
							tinychild.setContentsMargins(0, 0, 0, 0)
						except:
							pass


# ----------------------------------------------------------------------------
# Run functions
# ----------------------------------------------------------------------------

# def run_maya(**kwargs):
# 	""" Run in Maya.
# 	"""
# 	_maya_delete_ui()  # Delete any already existing UI
# 	customUI = TemplateUI(parent=_maya_main_window())

# 	# Makes Maya perform magic which makes the window stay on top in OS X and
# 	# Linux. As an added bonus, it'll make Maya remember the window position.
# 	customUI.setProperty("saveWindowPref", True)

# 	customUI.display(**kwargs)  # Show the UI


# def run_nuke(**kwargs):
# 	""" Run in Nuke.
# 	"""
# 	_nuke_delete_ui()  # Delete any already existing UI
# 	customUI = TemplateUI(parent=_nuke_main_window())

# 	customUI.display(**kwargs)  # Show the UI


# Detect environment and run application
if os.environ['IC_ENV'] == 'STANDALONE':
	pass
	# verbose.print_("[GPS] %s" %WINDOW_TITLE)
elif os.environ['IC_ENV'] == 'MAYA':
	import maya.cmds as mc
	# verbose.print_("[GPS] %s for Maya" %WINDOW_TITLE)
	# run_maya()
elif os.environ['IC_ENV'] == 'NUKE':
	import nuke
	import nukescripts
	# verbose.print_("[GPS] %s for Nuke" %WINDOW_TITLE)
	# run_nuke()
# elif __name__ == '__main__':
# 	run_standalone()

