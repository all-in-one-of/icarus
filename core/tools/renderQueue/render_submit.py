#!/usr/bin/python

# [Icarus] render_submit.py
#
# Mike Bonnington <mike.bonnington@gps-ldn.com>
# (c) 2015-2017 Gramercy Park Studios
#
# Batch Render Submitter
# A UI for creating render jobs to send to a render queue manager.


import os
import subprocess
import sys
import time

from Qt import QtCompat, QtCore, QtGui, QtWidgets
import rsc_rc  # Import resource file as generated by pyside-rcc

# Import custom modules
import osOps
import renderQueue
import sequence
import settingsData
import userPrefs
import verbose


# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------

# Set window title and object names
WINDOW_TITLE = "Render Submit"
WINDOW_OBJECT = "renderSubmitUI"

# Set the UI and the stylesheet
UI_FILE = "render_submit_ui.ui"
STYLESHEET = "style.qss"  # Set to None to use the parent app's stylesheet

# Prevent spawned processes from opening a shell window
CREATE_NO_WINDOW = 0x08000000


# ----------------------------------------------------------------------------
# Main dialog class
# ----------------------------------------------------------------------------

class RenderSubmitUI(QtWidgets.QMainWindow):
	""" Main dialog class.
	"""
	def __init__(self, parent=None):
		super(RenderSubmitUI, self).__init__(parent)
		self.parent = parent

		# Set object name and window title
		self.setObjectName(WINDOW_OBJECT)
		self.setWindowTitle(WINDOW_TITLE)

		# Load UI & stylesheet
		self.ui = QtCompat.load_ui(fname=os.path.join(os.environ['IC_FORMSDIR'], UI_FILE))
		self.reloadStyleSheet()

		# Set the main widget
		self.setCentralWidget(self.ui)

		# Set window flags
		self.setWindowFlags(QtCore.Qt.Tool)

		# Set up keyboard shortcuts
		# self.shortcutReloadStyleSheet = QtWidgets.QShortcut(self)
		# self.shortcutReloadStyleSheet.setKey('Ctrl+R')
		# self.shortcutReloadStyleSheet.activated.connect(self.reloadStyleSheet)

		# Connect signals & slots
		self.ui.submitTo_comboBox.currentIndexChanged.connect(self.setQueueManagerFromComboBox)
		self.ui.type_comboBox.currentIndexChanged.connect(self.setJobTypeFromComboBox)
		self.ui.sceneBrowse_toolButton.clicked.connect(self.sceneBrowse)

		# self.ui.layers_groupBox.toggled.connect(self.getRenderLayers)
		# self.ui.layers_lineEdit.editingFinished.connect(self.checkRenderLayers)

		# self.setupWidgets(self.ui.submitOptions_scrollAreaWidgetContents)
		# self.ui.renderer_comboBox.currentIndexChanged.connect(self.storeComboBoxValue)
		# self.ui.layers_lineEdit.textEdited.connect(self.storeLineEditValue)

		self.ui.frames_lineEdit.editingFinished.connect(self.calcFrameList)  # was textEdited
		self.ui.taskSize_spinBox.valueChanged.connect(self.calcFrameList)

		# # self.ui.pool_comboBox.currentIndexChanged.connect(self.storeComboBoxValue)
		# # self.ui.group_comboBox.currentIndexChanged.connect(self.storeComboBoxValue)
		# self.ui.pool_comboBox.editTextChanged.connect(self.storeComboBoxValue)
		# self.ui.group_comboBox.editTextChanged.connect(self.storeComboBoxValue)
		self.ui.getPools_toolButton.clicked.connect(self.getDeadlinePools)
		self.ui.getGroups_toolButton.clicked.connect(self.getDeadlineGroups)
		# self.ui.priority_spinBox.valueChanged.connect(self.storeSpinBoxValue)
		# self.ui.comment_lineEdit.textEdited.connect(self.storeLineEditValue)

		self.ui.submit_pushButton.clicked.connect(self.submit)
		self.ui.close_pushButton.clicked.connect(self.saveAndExit)

		# Set up custom expandable group boxes...
		for widget in self.ui.submitOptions_scrollAreaWidgetContents.children():
			if widget.property('expandable'):
				if isinstance(widget, QtWidgets.QGroupBox):
					self.setupExpandableGroupBox(widget)

		# Context menus
		self.ui.frameListOptions_toolButton.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

		self.actionFrameListOption1 = QtWidgets.QAction("Shot default", None)
		self.actionFrameListOption1.triggered.connect(self.getFrameRangeFromShotSettings)
		self.ui.frameListOptions_toolButton.addAction(self.actionFrameListOption1)

		self.actionFrameListOption2 = QtWidgets.QAction("Render settings", None)
		self.actionFrameListOption2.triggered.connect(self.getFrameRangeFromRenderSettings)
		self.ui.frameListOptions_toolButton.addAction(self.actionFrameListOption2)

		self.actionFrameListOption3 = QtWidgets.QAction("Sequential", None)
		self.actionFrameListOption3.triggered.connect(self.setFrameListPreset)
		self.ui.frameListOptions_toolButton.addAction(self.actionFrameListOption3)

		self.actionFrameListOption4 = QtWidgets.QAction("First, last, sequential", None)
		self.actionFrameListOption4.triggered.connect(self.setFrameListPreset)
		self.ui.frameListOptions_toolButton.addAction(self.actionFrameListOption4)

		self.ui.layerOptions_toolButton.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

		self.actionLayerOption1 = QtWidgets.QAction("Current layer only", None)
		self.actionLayerOption1.triggered.connect(self.getCurrentRenderLayer)
		self.ui.layerOptions_toolButton.addAction(self.actionLayerOption1)

		self.actionLayerOption2 = QtWidgets.QAction("All renderable layers", None)
		self.actionLayerOption2.triggered.connect(self.getRenderLayers)
		self.ui.layerOptions_toolButton.addAction(self.actionLayerOption2)

		self.ui.writeNodeOptions_toolButton.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

		self.actionWriteNodeOption1 = QtWidgets.QAction("Selected write node only", None)
		self.actionWriteNodeOption1.triggered.connect(self.getCurrentRenderLayer)
		self.ui.writeNodeOptions_toolButton.addAction(self.actionWriteNodeOption1)

		self.actionWriteNodeOption2 = QtWidgets.QAction("All write nodes", None)
		self.actionWriteNodeOption2.triggered.connect(self.getRenderLayers)
		self.ui.writeNodeOptions_toolButton.addAction(self.actionWriteNodeOption2)

		# Set input validators
		layer_list_validator = QtGui.QRegExpValidator(QtCore.QRegExp(r'[\w, ]+'), self.ui.layers_lineEdit)
		self.ui.layers_lineEdit.setValidator(layer_list_validator)

		frame_list_validator = QtGui.QRegExpValidator(QtCore.QRegExp(r'[\d\-, ]+'), self.ui.frames_lineEdit)
		self.ui.frames_lineEdit.setValidator(frame_list_validator)


	def display(self, frameRange=None, layers=None, flags=None):
		""" Display the dialog.
		"""
		self.returnValue = False
		# self.xmlData = 

		# Read user prefs config file - if it doesn't exist it will be created
		userPrefs.read()

		# Instantiate XML data classes
		self.xd = settingsData.settingsData()
		# xd_load = self.xd.loadXML(self.xmlData)

		# Set 'Submit to' option depending on the parent window, or user prefs
		if self.parent.windowTitle() == "Render Queue":
			self.submitTo = "Render Queue"
			self.ui.submitTo_frame.setEnabled(False)
			self.ui.submitTo_frame.hide()
		else:
			self.submitTo = userPrefs.query('rendersubmit', 'submitto', default=self.ui.submitTo_comboBox.currentText())
			self.ui.submitTo_frame.setEnabled(True)
			self.ui.submitTo_frame.show()
		self.ui.submitTo_comboBox.setCurrentIndex(self.ui.submitTo_comboBox.findText(self.submitTo))
		self.ui.submit_pushButton.setText("Submit to %s" %self.submitTo)

		# # Restore widgets from user prefs settings
		# pool = userPrefs.query('rendersubmit', 'pool', datatype='str', default='')
		# self.ui.pool_comboBox.addItem(pool)

		# group = userPrefs.query('rendersubmit', 'group', datatype='str', default='')
		# self.ui.group_comboBox.addItem(group)

		# priority = userPrefs.query('rendersubmit', 'priority', datatype='int', default=50)
		# self.ui.priority_spinBox.setValue(priority)

		# comment = userPrefs.query('rendersubmit', 'comment', datatype='str', default='')
		# self.ui.comment_lineEdit.setText(comment)

		# Set job type from Icarus environment when possible
		if os.environ['IC_ENV'] == 'STANDALONE':
			self.jobType = userPrefs.query('rendersubmit', 'lastrenderjobtype', default=self.ui.type_comboBox.currentText())
			self.ui.type_comboBox.setCurrentIndex(self.ui.type_comboBox.findText(self.jobType))
			self.setJobType()
			self.setSceneList()

		elif os.environ['IC_ENV'] == 'MAYA':
			self.jobType = 'Maya'
			self.ui.type_comboBox.setCurrentIndex(self.ui.type_comboBox.findText(self.jobType))
			self.setJobType()

			# import maya.cmds as mc
			sceneName = mc.file(query=True, sceneName=True)
			if sceneName:  # Check we're not working in an unsaved scene
				relPath = self.makePathRelative(osOps.absolutePath(sceneName))
				if relPath:
					self.ui.scene_comboBox.addItem(relPath)
			else:
				msg = "Scene must be saved before submitting render."
				mc.warning(msg)
				#mc.confirmDialog(title="Scene not saved", message=msg, icon="warning", button="Close")
				self.ui.scene_comboBox.addItem(msg)
				self.ui.submit_pushButton.setToolTip(msg)
				self.ui.submit_pushButton.setEnabled(False)

			self.ui.render_groupBox.setEnabled(False)
			self.ui.sceneBrowse_toolButton.hide()

			self.getRenderLayers()
			self.getRenderers()

			if layers:
				# self.ui.layers_groupBox.setChecked(True)
				self.ui.layers_lineEdit.setText(layers)

		elif os.environ['IC_ENV'] == 'NUKE':
			self.jobType = 'Nuke'
			self.ui.type_comboBox.setCurrentIndex(self.ui.type_comboBox.findText(self.jobType))
			self.setJobType()

			# import nuke
			scriptName = nuke.value("root.name")
			if scriptName:  # Check we're not working in an unsaved script
				relPath = self.makePathRelative(osOps.absolutePath(scriptName))
				if relPath:
					self.ui.scene_comboBox.addItem(relPath)
			else:
				msg = "Script must be saved before submitting render."
				nuke.warning(msg)
				#nuke.message(msg)
				self.ui.scene_comboBox.addItem(msg)
				self.ui.submit_pushButton.setToolTip(msg)
				self.ui.submit_pushButton.setEnabled(False)

			self.ui.render_groupBox.setEnabled(False)
			self.ui.sceneBrowse_toolButton.hide()

		self.numList = []
		if frameRange:
			self.ui.frames_lineEdit.setText(frameRange)
		else:
			self.getFrameRangeFromShotSettings()
		self.calcFrameList()

		if flags:
			# self.ui.flags_groupBox.setChecked(True)
			self.ui.flags_lineEdit.setText(flags)

		scene = self.makePathAbsolute(self.ui.scene_comboBox.currentText()).replace("\\", "/")
		self.xmlData = os.path.splitext(scene)[0] + "_icSubmissionData.xml"
		self.xd.loadXML(self.xmlData)
		self.setupWidgets(self.ui.submitOptions_scrollAreaWidgetContents)

		self.show()
		self.raise_()
		return self.returnValue


	def setupExpandableGroupBox(self, ctrl, expand=True):
		""" Enable expansion of custom rollout group box controls.
		"""
		ctrl.setCheckable(True)
		ctrl.setChecked(expand)
		ctrl.setFixedHeight(ctrl.sizeHint().height())
		ctrl.toggled.connect(self.toggleExpandGroup)


	def toggleExpandGroup(self):
		""" Toggle expansion of custom rollout group box control.
		"""
		ctrl = self.sender()
		state = ctrl.isChecked()
		if state:
			ctrl.setFixedHeight(ctrl.sizeHint().height())
		else:
			ctrl.setFixedHeight(20)  # Slightly hacky - needs to match the QSS


	def setQueueManagerFromComboBox(self):
		""" Set queue manager to submit job to - called when the job type
			combo box value is changed.
		"""
		self.submitTo = self.ui.submitTo_comboBox.currentText()
		userPrefs.edit('rendersubmit', 'submitto', self.submitTo)
		self.ui.submit_pushButton.setText("Submit to %s" %self.submitTo)


	def setJobTypeFromComboBox(self):
		""" Set job type - called when the job type combo box value is
			changed.
		"""
		self.jobType = self.ui.type_comboBox.currentText()
		userPrefs.edit('rendersubmit', 'lastrenderjobtype', self.jobType)
		self.setJobType()
		self.setSceneList()


	def setJobType(self):
		""" Setup some global variables and UI elements depending on the job
			type.
		"""
		if self.jobType == 'Generic command':
			# try:
			# 	self.relativeScenesDir = osOps.absolutePath('%s/%s' %(os.environ['MAYADIR'], 'scenes'))
			# except KeyError:
			# 	self.relativeScenesDir = ""
			self.ui.scene_label.setText("Command:")
			self.ui.mayaOptions_groupBox.hide()
			self.ui.nukeOptions_groupBox.hide()
		elif self.jobType == 'Maya':
			try:
				self.relativeScenesDir = osOps.absolutePath('%s/%s' %(os.environ['MAYADIR'], 'scenes'))
			except KeyError:
				self.relativeScenesDir = ""
			self.ui.scene_label.setText("Scene:")
			self.ui.mayaOptions_groupBox.show()
			self.ui.nukeOptions_groupBox.hide()
		elif self.jobType == 'Nuke':
			try:
				self.relativeScenesDir = osOps.absolutePath('%s/%s' %(os.environ['NUKEDIR'], 'scripts'))
			except KeyError:
				self.relativeScenesDir = ""
			self.ui.scene_label.setText("Script:")
			self.ui.nukeOptions_groupBox.show()
			self.ui.mayaOptions_groupBox.hide()

		# Representative string to replace the path specified above
		self.relativeScenesToken = '...'


	def setSceneList(self):
		""" Clear scene menu and populate from recent file list. Only used in
			standalone mode.
		"""
		self.ui.scene_comboBox.clear()

		try:
			import recentFiles
			for filePath in recentFiles.getLs(self.jobType):
				fullPath = osOps.absolutePath(os.environ['SHOTPATH'] + filePath)
				relPath = self.makePathRelative(fullPath)
				if relPath:
					self.ui.scene_comboBox.addItem(relPath)
		except:
			pass


	def makePathRelative(self, absPath):
		""" Convert an absolute path to a relative path.
		"""
		if absPath.startswith(self.relativeScenesDir):
			return absPath.replace(self.relativeScenesDir, self.relativeScenesToken)
		else:
			return False


	def makePathAbsolute(self, relPath):
		""" Convert a relative path to an absolute path.
		"""
		return relPath.replace(self.relativeScenesToken, self.relativeScenesDir)


	def sceneBrowse(self):
		""" Browse for a scene/script file.
		"""
		if self.jobType == 'Maya':
			fileDir = os.environ.get('MAYASCENESDIR', '.')  # Go to current dir if env var is not set
			fileFilter = 'Maya files (*.ma *.mb)'
			fileTerminology = 'scenes'
		elif self.jobType == 'Nuke':
			fileDir = os.environ.get('NUKESCRIPTSDIR', '.')  # Go to current dir if env var is not set
			fileFilter = 'Nuke files (*.nk)'
			fileTerminology = 'scripts'
		else:
			fileDir = os.environ.get('JOBPATH', '.')  # Go to current dir if env var is not set
			fileFilter = 'All files (*.*)'
			fileTerminology = 'commands'

		currentDir = os.path.dirname(self.makePathAbsolute(self.ui.scene_comboBox.currentText()))
		if os.path.exists(currentDir):
			startingDir = currentDir
		else:
			startingDir = fileDir

		filePath = QtWidgets.QFileDialog.getOpenFileName(self, self.tr('Files'), startingDir, fileFilter)
		if filePath[0]:
			newEntry = self.makePathRelative(osOps.absolutePath(filePath[0]))
			#newEntry = osOps.absolutePath(filePath[0])
			if newEntry:
				self.ui.scene_comboBox.removeItem(self.ui.scene_comboBox.findText(newEntry))  # If the entry already exists in the list, delete it
				self.ui.scene_comboBox.insertItem(0, newEntry)
				self.ui.scene_comboBox.setCurrentIndex(0)  # Always insert the new entry at the top of the list and select it
			else:
				verbose.warning("Only %s belonging to the current shot can be submitted." %fileTerminology)


	# ------------------------------------------------------------------------
	# Widget handlers - same as in settings.py. Perhaps rewrite into a module
	# or subclass of QtMainWindow, QtDialog etc.

	def setupWidgets(self, parentObject, storeProperties=True):
		""" Set up all the child widgets of the specified parent object.
		"""
		for widget in parentObject.findChildren(QtWidgets.QWidget):

			# # Set up handler for push button(s)...
			# if widget.property('exec'):
			# 	if isinstance(widget, QtWidgets.QPushButton):
			# 		widget.clicked.connect(self.execPushButton)

			# Set up handlers for different widget types & apply values
			attr = widget.property('xmlTag')
			if attr:
				value = self.xd.getValue('rendersubmit', attr)

				# Spin box(es)...
				if isinstance(widget, QtWidgets.QSpinBox):
					if value is not "":
						widget.setValue(int(value))
					if storeProperties:
						self.storeValue(attr, widget.value())
					widget.valueChanged.connect(self.storeSpinBoxValue)

				# Double spin box(es)...
				elif isinstance(widget, QtWidgets.QDoubleSpinBox):
					if value is not "":
						widget.setValue(float(value))
					if storeProperties:
						self.storeValue(attr, widget.value())
					widget.valueChanged.connect(self.storeSpinBoxValue)

				# Line edit(s)...
				elif isinstance(widget, QtWidgets.QLineEdit):
					if value is not "":
						widget.setText(value)
					if storeProperties:
						self.storeValue(attr, widget.text())
					widget.textEdited.connect(self.storeLineEditValue)

				# Plain text edit(s)...
				elif isinstance(widget, QtWidgets.QPlainTextEdit):
					if value is not "":
						widget.setPlainText(value)
					if storeProperties:
						self.storeValue(attr, widget.toPlainText())
					widget.textChanged.connect(self.storeTextEditValue)

				# Check box(es)...
				elif isinstance(widget, QtWidgets.QCheckBox):
					if value is not "":
						if value == "True":
							widget.setCheckState(QtCore.Qt.Checked)
						elif value == "False":
							widget.setCheckState(QtCore.Qt.Unchecked)
					if storeProperties:
						self.storeValue(attr, self.getCheckBoxValue(widget))
					widget.toggled.connect(self.storeCheckBoxValue)

				# Radio button(s)...
				elif isinstance(widget, QtWidgets.QRadioButton):
					if value is not "":
						widget.setAutoExclusive(False)
						if value == widget.text():
							widget.setChecked(True)
						else:
							widget.setChecked(False)
						widget.setAutoExclusive(True)
					if storeProperties:
						if widget.isChecked():
							self.storeValue(attr, widget.text())
					widget.toggled.connect(self.storeRadioButtonValue)

				# Combo box(es)...
				elif isinstance(widget, QtWidgets.QComboBox):
					if value is not "":
						if widget.findText(value) == -1:
							self.ui.pool_comboBox.addItem(value)
						widget.setCurrentIndex(widget.findText(value))
					if storeProperties:
						self.storeValue(attr, widget.currentText())
					widget.currentIndexChanged.connect(self.storeComboBoxValue)


	def getCheckBoxValue(self, checkBox):
		""" Get the value from a checkbox and return a Boolean value.
		"""
		if checkBox.checkState() == QtCore.Qt.Checked:
			return True
		else:
			return False


	# # @QtCore.Slot()
	# def storeWidgetValue(self):
	# 	widget = self.sender()
	# 	attr = widget.property('xmlTag')

	# 	if isinstance(widget, QtWidgets.QSpinBox):
	# 		value = widget.value()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QDoubleSpinBox):
	# 		value = widget.value()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QLineEdit):
	# 		value = widget.text()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QPlainTextEdit):
	# 		value = widget.toPlainText()
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QCheckBox):
	# 		value = self.getCheckBoxValue(widget)
	# 		self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QRadioButton):
	# 		if widget.isChecked():
	# 			value = widget.text()
	# 			self.storeValue(attr, value)
	# 	elif isinstance(widget, QtWidgets.QComboBox):
	# 		value = widget.currentText()
	# 		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeSpinBoxValue(self):
		""" Get the value from a Spin Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().value()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeLineEditValue(self):
		""" Get the value from a Line Edit and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().text()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeTextEditValue(self):
		""" Get the value from a Plain Text Edit and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().toPlainText()
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeCheckBoxValue(self):
		""" Get the value from a Check Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.getCheckBoxValue(self.sender())
		self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeRadioButtonValue(self):
		""" Get the value from a Radio Button group and store in XML data.
		"""
		if self.sender().isChecked():
			attr = self.sender().property('xmlTag')
			value = self.sender().text()
			self.storeValue(attr, value)


	# @QtCore.Slot()
	def storeComboBoxValue(self):
		""" Get the value from a Combo Box and store in XML data.
		"""
		attr = self.sender().property('xmlTag')
		value = self.sender().currentText()
		self.storeValue(attr, value)


	def storeValue(self, attr, value=""):
		""" Store value in XML data.
		"""
		verbose.print_("%20s %s.%s=%s" %(type(value), 'rendersubmit', attr, value), 4)
		# userPrefs.edit('rendersubmit', attr, value)
		self.xd.setValue('rendersubmit', attr, str(value))

	# End widget handlers
	# ------------------------------------------------------------------------


	def getFrameRangeFromShotSettings(self):
		""" Get frame range from shot settings.
		"""
		try:
			self.ui.frames_lineEdit.setText("%d-%d" %(int(os.environ['STARTFRAME']), int(os.environ['ENDFRAME'])))
			self.ui.frames_groupBox.setChecked(True)
		except KeyError:
			self.ui.frames_lineEdit.setText("")
			self.ui.frames_groupBox.setChecked(False)


	def getFrameRangeFromRenderSettings(self):
		""" Get frame range from Maya render settings.
		"""
		if os.environ['IC_ENV'] == 'MAYA':
			self.ui.frames_lineEdit.setText("%d-%d" %(int(mc.getAttr('defaultRenderGlobals.startFrame')), int(mc.getAttr('defaultRenderGlobals.endFrame'))))
			#self.ui.frames_lineEdit.setText("%d-%d" %(int(mc.playbackOptions(min=True, q=True)), int(mc.playbackOptions(max=True, q=True))))
			self.ui.frames_groupBox.setChecked(True)


	def getCurrentRenderLayer(self):
		""" Get current Maya render layer & populate widget.
		"""
		if os.environ['IC_ENV'] == 'MAYA':
			currentLayer = mc.editRenderLayerGlobals(query=True, currentRenderLayer=True)
			self.ui.layers_lineEdit.setText(currentLayer)


	def getRenderLayers(self):
		""" Get Maya render layers & populate widget.
		"""
		if os.environ['IC_ENV'] == 'MAYA':
			layerStr = ", ".join(n for n in self.getRenderableLayers())
			self.ui.layers_lineEdit.setText(layerStr)
			# currentLayer = mc.editRenderLayerGlobals(query=True, currentRenderLayer=True)
			# startFrame = int(mc.getAttr('defaultRenderGlobals.startFrame'))
			# endFrame = int(mc.getAttr('defaultRenderGlobals.endFrame'))
			# frames = "%d-%d" %(startFrame, endFrame)

			# self.ui.layers_treeWidget.clear()

			# for layer in layers:
			# 	item = QtWidgets.QTreeWidgetItem(self.ui.layers_treeWidget)
			# 	layerFrames = frames
			# 	adjustments = mc.editRenderLayerAdjustment(layer, query=True, layer=True)
			# 	# overrides = ['defaultRenderGlobals.startFrame', 'defaultRenderGlobals.endFrame']
			# 	if adjustments:
			# 		if 'defaultRenderGlobals.startFrame' in adjustments:
			# 			startFrame = "*"
			# 		if 'defaultRenderGlobals.endFrame' in adjustments:
			# 			endFrame = "*"
			# 		layerFrames = "%s-%s" %(startFrame, endFrame)
			# 	# item.setText(0, mc.getAttr('renderLayerManager.renderLayerId[%d]'))
			# 	item.setText(2, layer)
			# 	item.setText(3, layerFrames)

			# 	# Check renderable layers
			# 	if mc.getAttr(layer+'.renderable'):
			# 		item.setCheckState(1, QtCore.Qt.Checked)
			# 	else:
			# 		item.setCheckState(1, QtCore.Qt.Unchecked)

			# # Resize columns
			# self.ui.layers_treeWidget.resizeColumnToContents(0)
			# self.ui.layers_treeWidget.resizeColumnToContents(1)
			# self.ui.layers_treeWidget.resizeColumnToContents(2)

		# else:
		# 	self.ui.layers_groupBox.hide()


	def getDeadlinePools(self):
		""" Get Deadline pools & populate combo box.
		"""
		try:
			pools = subprocess.check_output([os.environ['DEADLINECMDVERSION'], '-pools'], creationflags=CREATE_NO_WINDOW)
			self.populateComboBox(self.ui.pool_comboBox, self.strToList(pools))
		except:
			verbose.warning("Could not retrieve Deadline pools.")


	def getDeadlineGroups(self):
		""" Get Deadline groups & populate combo box.
		"""
		try:
			groups = subprocess.check_output([os.environ['DEADLINECMDVERSION'], '-groups'], creationflags=CREATE_NO_WINDOW)
			self.populateComboBox(self.ui.group_comboBox, self.strToList(groups))
		except:
			verbose.warning("Could not retrieve Deadline groups.")


	def getRenderers(self):
		""" Get Maya renderers & populate combo box.
		"""
		renderers = self.getRenderer()
		rendererLs = [renderers]
		# verbose.print_(rendererLs)
		self.populateComboBox(self.ui.renderer_comboBox, rendererLs)


	def strToList(self, string):
		""" Convert string to list by splitting into lines.
			Encode bytes to string for Python 3.
		"""
		string = string.decode()
		ls = string.splitlines()
		verbose.print_(ls)
		return ls


	def populateComboBox(self, comboBox, contentsLs):
		""" Populate combo box.
		"""
		# Store current value
		current = comboBox.currentText()

		# Clear menu
		comboBox.clear()

		# Populate menu
		for item in contentsLs:
			if item:
				comboBox.addItem(item)

		# Set to current value
		index = comboBox.findText(current)
		if index == -1:
			comboBox.setCurrentIndex(0)
		else:
			comboBox.setCurrentIndex(index)


	# @QtCore.Slot()
	def setFrameListPreset(self):
		""" Set frame list from preset
		"""
		pass
		print(self.sender().text())



	def calcFrameList(self, quiet=True):
		""" Calculate list of frames to be rendered.
		"""
		self.numList = sequence.numList(self.ui.frames_lineEdit.text(), quiet=True)
		taskSize = self.ui.taskSize_spinBox.value()
		if self.numList == False:
			if not quiet:
				verbose.warning("Invalid entry for frame range.")
			return False
		else:
			self.ui.frames_lineEdit.setText(sequence.numRange(self.numList))
			nFrames = len(self.numList)
			if taskSize < nFrames:
				self.ui.taskSize_slider.setMaximum(nFrames)
				self.ui.taskSize_spinBox.setMaximum(nFrames)
				self.ui.taskSize_spinBox.setValue(taskSize)
			else:
				self.ui.taskSize_slider.setMaximum(nFrames)
				self.ui.taskSize_spinBox.setMaximum(nFrames)
				self.ui.taskSize_spinBox.setValue(nFrames)

			# Generate task list for rendering
			self.taskList = []
			sequences = list(sequence.seqRange(self.numList, gen_range=True))
			for seq in sequences:
				chunks = list(sequence.chunks(seq, taskSize))
				for chunk in chunks:
					#self.taskList.append(list(sequence.seqRange(chunk))[0])
					self.taskList.append(sequence.numRange(chunk))

		return True
					

	def getMayaProject(self, scene):
		""" Get the Maya project. If the environment variable is not set, try
			to guess the Maya project directory based on the scene name.
		"""
		try:  # Project is implicit if job is set
			mayaProject = os.environ['MAYADIR'].replace("\\", "/")
		except KeyError:
			mayaProject = scene.split('/scenes')[0]

		return mayaProject


	def getRenderer(self):
		""" Get the current Maya renderer.
		"""
		try:
			renderer = mc.getAttr("defaultRenderGlobals.currentRenderer")
		except:
			renderer = ""

		return renderer


	def getRenderableLayers(self):
		""" Get Maya render layers that are enabled (renderable).
		"""
		layers = mc.ls(type='renderLayer')
		renderableLayers = []
		for layer in layers:
			if mc.getAttr(layer+'.renderable'):
				renderableLayers.append(layer)

		return renderableLayers


	def getOutput(self, layer=None):
		""" Get the path of Maya's render output.
		"""
		try:
			padding = "#" * mc.getAttr("defaultRenderGlobals.extensionPadding")
			if layer is None:
				path = mc.renderSettings(fullPath=True, 
				                         leaveUnmatchedTokens=True, 
				                         genericFrameImageName=padding)
			else:
				path = mc.renderSettings(fullPath=True, 
				                         layer=layer, 
				                         leaveUnmatchedTokens=True, 
				                         genericFrameImageName=padding)
		except:
			path = ""

		return path[0]


	def getOutputFilePath(self):
		""" Get Maya's render output file path from the Maya project.
		"""
		try:
			path = mc.workspace(expandName=mc.workspace(fileRuleEntry="images"))
		except:
			path = ""

		return path


	def getOutputFilePrefix(self):
		""" Get Maya's output file prefix from the render settings.
		"""
		try:
			prefix = mc.getAttr("defaultRenderGlobals.imageFilePrefix")
		except:
			prefix = ""

		return prefix


	def submit(self):
		""" Submit job.
		"""
		self.save()

		if self.submitTo == "Render Queue":
			self.submitToRenderQueue()
		if self.submitTo == "Deadline":
			self.submitToDeadline()


	def submitToRenderQueue(self):
		""" Submit job to render queue.
		"""
		timeFormatStr = "%Y/%m/%d %H:%M:%S" # "%a, %d %b %Y %H:%M:%S"

		if not self.calcFrameList(quiet=False):
			return

		# Instantiate render queue class and load data
		self.rq = renderQueue.renderQueue()
		self.rq.loadXML(os.path.join(os.environ['IC_CONFIGDIR'], 'renderQueue.xml'))

		###################
		# Generic options #
		###################

		if self.ui.frames_groupBox.isChecked():
			frames = self.ui.frames_lineEdit.text()
			taskSize = self.ui.taskSize_spinBox.value()
			framesMsg = '%d %s to be rendered; %d %s to be submitted.\n' %(len(self.numList), verbose.pluralise("frame", len(self.numList)), len(self.taskList), verbose.pluralise("task", len(self.taskList)))
		else:
			frames = 'Unknown'
			taskSize = 'Unknown'
			self.numList = []
			self.taskList = [frames, ]
			framesMsg = 'The frame range was not specified so the job cannot be distributed into tasks. The job will be submitted as a single task and the frame range will be read from the scene at render time.\n'

		if self.ui.flags_groupBox.isChecked():
			flags = self.ui.flags_lineEdit.text()
		else:
			flags = ""

		priority = self.ui.priority_spinBox.value()
		comment = self.ui.comment_lineEdit.text()

		#############################
		# Renderer-specific options #
		#############################

		if self.jobType == 'Maya':
			renderCmdEnvVar = 'MAYARENDERVERSION'
			mayaScene = self.makePathAbsolute(self.ui.scene_comboBox.currentText()).replace("\\", "/")  # Implicit if submitting from Maya UI
			mayaProject = self.getMayaProject(mayaScene)
			jobName = os.path.splitext(os.path.basename(mayaScene))[0]
		elif self.jobType == 'Nuke':
			renderCmdEnvVar = 'NUKEVERSION'
			nukeScript = self.makePathAbsolute(self.ui.scene_comboBox.currentText()).replace("\\", "/")  # Implicit if submitting from Nuke UI
			jobName = os.path.splitext(os.path.basename(nukeScript))[0]

		try:
			renderCmd = os.environ[renderCmdEnvVar].replace("\\", "/")
		except KeyError:
			verbose.error("Path to %s render command executable not found. This can be set with the environment variable '%s'." %(self.jobType, renderCmdEnvVar))

		# Package option variables into tuples
		genericOpts = jobName, self.jobType, frames, taskSize, priority
		if self.jobType == 'Maya':
			renderOpts = mayaScene, mayaProject, flags, renderCmd
		elif self.jobType == 'Nuke':
			renderOpts = nukeScript, flags, renderCmd

		# Confirmation dialog
		import pDialog

		dialogTitle = 'Submit Render - %s' %jobName
		dialogMsg = ''
		dialogMsg += 'Name:\t%s\nType:\t%s\nFrames:\t%s\nTask size:\t%s\nPriority:\t%s\n\n' %genericOpts
		# if self.jobType == 'Maya':
		# 	dialogMsg += 'Scene:\t%s\nProject:\t%s\nFlags:\t%s\nCommand:\t%s\n\n' %renderOpts
		# elif self.jobType == 'Nuke':
		# 	dialogMsg += 'Script:\t%s\nFlags:\t%s\nCommand:\t%s\n\n' %renderOpts
		dialogMsg += framesMsg
		dialogMsg += 'Do you want to continue?'

		dialog = pDialog.dialog()
		if dialog.display(dialogMsg, dialogTitle):
			self.rq.newJob(genericOpts, renderOpts, self.taskList, os.environ['IC_USERNAME'], time.strftime(timeFormatStr), comment)

			# Post-confirmation dialog
			dialogTitle = 'Submission Results - %s' %jobName
			dialogMsg = ''
			dialogMsg += 'Name:\t%s\nType:\t%s\nFrames:\t%s\nTask size:\t%s\nPriority:\t%s\n\n' %genericOpts
			dialogMsg += 'Render job submitted succesfully.'
			dialog.display(dialogMsg, dialogTitle, conf=True)
		else:
			return


	def submitToDeadline(self):
		""" Submit job to Deadline.
		"""
		# pluginInfoFile = ""

		if not self.calcFrameList(quiet=False):
			return

		###################
		# Generic options #
		###################

		frames = self.ui.frames_lineEdit.text()
		taskSize = self.ui.taskSize_spinBox.value()
		framesMsg = '%d %s to be rendered; %d %s to be submitted.\n' %(len(self.numList), verbose.pluralise("frame", len(self.numList)), len(self.taskList), verbose.pluralise("task", len(self.taskList)))

		pool = self.ui.pool_comboBox.currentText()
		group = self.ui.group_comboBox.currentText()
		priority = self.ui.priority_spinBox.value()
		comment = self.ui.comment_lineEdit.text()

		#############################
		# Renderer-specific options #
		#############################

		if self.jobType == 'Maya':
			plugin = 'MayaBatch'
			version = os.environ['MAYA_VER']  #jobData.getAppVersion('Maya')
			renderer = self.ui.renderer_comboBox.currentText()  # Maya submit only
			scene = self.makePathAbsolute(self.ui.scene_comboBox.currentText()).replace("\\", "/")
			mayaProject = self.getMayaProject(scene)  # Maya submit only
			outputFilePath = self.getOutputFilePath()  # Maya submit only
			outputFilePrefix = self.getOutputFilePrefix()  # Maya submit only
			jobName = os.path.splitext(os.path.basename(scene))[0]
			output = []  # Maya submit only
			for layer in self.getRenderableLayers():
				output.append(os.path.split(self.getOutput(layer)))
			renderLayers = False  # temp
		elif self.jobType == 'Nuke':
			plugin = 'Nuke'
			scene = self.makePathAbsolute(self.ui.scene_comboBox.currentText()).replace("\\", "/")
			jobName = os.path.splitext(os.path.basename(scene))[0]

		# Package option variables into tuples
		genericOpts = jobName, self.jobType, frames, taskSize, priority
		# if self.jobType == 'Maya':
		# 	renderOpts = scene, mayaProject, flags, renderCmd
		# elif self.jobType == 'Nuke':
		# 	renderOpts = scene, flags, renderCmd

		# Confirmation dialog
		import pDialog

		dialogTitle = 'Submit Render to Deadline - %s' %jobName
		dialogMsg = ''
		dialogMsg += 'Name:\t%s\nType:\t%s\nFrames:\t%s\nTask size:\t%s\nPriority:\t%s\n\n' %genericOpts
		dialogMsg += framesMsg
		dialogMsg += 'Do you want to continue?'

		dialog = pDialog.dialog()
		if dialog.display(dialogMsg, dialogTitle):
			try:
				# Generate submission info files
				jobInfoFile = os.path.splitext(scene)[0] + "_deadlineJobInfo.txt"
				fh = open(jobInfoFile, 'w')
				fh.write("Plugin=%s\n" %plugin)
				if renderLayers:
					fh.write("Name=%s - %s\n" %(jobName, renderLayer))
					fh.write("BatchName=%s\n" %jobName)
				else:
					fh.write("Name=%s\n" %jobName)
				fh.write("Comment=%s\n" %comment)
				fh.write("Frames=%s\n" %frames)
				fh.write("ChunkSize=%s\n" %taskSize)
				fh.write("Pool=%s\n" %pool)
				fh.write("Group=%s\n" %group)
				fh.write("Priority=%s\n" %priority)
				if priority == 0:
					fh.write("InitialStatus=Suspended\n")
				for i, outputPath in enumerate(output):
					fh.write("OutputDirectory%d=%s\n" %(i, outputPath[0]))
					fh.write("OutputFilename%d=%s\n" %(i, outputPath[1]))
				#fh.write("IncludeEnvironment=True\n")
				fh.write("ExtraInfo0=%s\n" %os.environ['JOB'])
				fh.write("ExtraInfo1=%s\n" %os.environ['SHOT'])
				fh.close()

				pluginInfoFile = os.path.splitext(scene)[0] + "_deadlinePluginInfo.txt"
				fh = open(pluginInfoFile, 'w')
				fh.write("Version=%s\n" %version)
				fh.write("Build=64bit\n")
				fh.write("Renderer=%s\n" %renderer)
				fh.write("StrictErrorChecking=1\n")
				fh.write("ProjectPath=%s\n" %mayaProject)
				fh.write("OutputFilePath=%s\n" %outputFilePath)
				fh.write("OutputFilePrefix=%s\n" %outputFilePrefix)
				fh.write("SceneFile=%s\n" %scene)
				if renderLayers:
					fh.write("UsingRenderLayers=1\n")
					fh.write("UseLegacyRenderLayers=1\n")
					fh.write("RenderLayer=%s\n" %renderLayer)
				fh.close()

				# Execute deadlinecommand
				output = subprocess.check_output([os.environ['DEADLINECMDVERSION'], jobInfoFile, pluginInfoFile], creationflags=CREATE_NO_WINDOW)

				# Delete submission info files
				# osOps.recurseRemove(jobInfoFile)
				# osOps.recurseRemove(pluginInfoFile)

			except:
				output = "Could not submit job to Deadline."
				verbose.error(output)
				output += "\nEither the Deadline executable could not be found, or the submission info files could not be written."

			# Post-confirmation dialog
			dialogTitle = 'Submission Results - %s' %jobName
			dialogMsg = ''
			dialogMsg += 'Name:\t%s\nType:\t%s\nFrames:\t%s\nTask size:\t%s\nPriority:\t%s\n\n' %genericOpts
			dialogMsg += output
			dialog.display(dialogMsg, dialogTitle, conf=True)
		else:
			return


	def reloadStyleSheet(self):
		""" Reload stylesheet.
		"""
		if STYLESHEET is not None:
			qss=os.path.join(os.environ['IC_FORMSDIR'], STYLESHEET)
			with open(qss, "r") as fh:
				self.ui.setStyleSheet(fh.read())


	def showEvent(self, event):
		""" Event handler for when window is shown.
		"""
		self.setJobTypeFromComboBox()
		# self.getFrameRangeFromShotSettings()
		# self.display()


	def save(self):
		""" Save data.
		"""
		if self.xd.saveXML():
			verbose.message("Submission settings saved.")
			return True
		else:
			verbose.error("Submission settings could not be saved.")
			return False


	def saveAndExit(self):
		""" Save data and exit dialog.
		"""
		if self.save():
			self.returnValue = True
			self.hide()
		else:
			self.exit()  # There's a bug where all property panel widgets become visible if a save fails. As a quick dodgy workaround we exit so we don't see it happen.


	def exit(self):
		""" Exit the dialog.
		"""
		self.returnValue = False
		self.hide()

# ----------------------------------------------------------------------------
# End of main dialog class
# ----------------------------------------------------------------------------


# def run_(**kwargs):
# 	# for key, value in kwargs.iteritems():
# 	# 	print "%s = %s" % (key, value)
# 	renderSubmitUI = RenderSubmitUI(**kwargs)
# 	#renderSubmitUI.setAttribute( QtCore.Qt.WA_DeleteOnClose )
# 	print renderSubmitUI
# 	renderSubmitUI.show()
# 	#renderSubmitUI.raise_()
# 	#renderSubmitUI.exec_()


# ----------------------------------------------------------------------------
# DCC application helper functions - MOVE TO MODULE
# ----------------------------------------------------------------------------

def _maya_delete_ui():
	""" Delete existing UI in Maya.
	"""
	if mc.window(WINDOW_OBJECT, query=True, exists=True):
		mc.deleteUI(WINDOW_OBJECT)  # Delete window
	if mc.dockControl('MayaWindow|' + WINDOW_TITLE, query=True, exists=True):
		mc.deleteUI('MayaWindow|' + WINDOW_TITLE)  # Delete docked window


def _nuke_delete_ui():
	""" Delete existing UI in Nuke.
	"""
	for obj in QtWidgets.QApplication.allWidgets():
		if obj.objectName() == WINDOW_OBJECT:
			obj.deleteLater()


def _maya_main_window():
	""" Return Maya's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if obj.objectName() == 'MayaWindow':
			return obj
	raise RuntimeError("Could not find MayaWindow instance")


def _nuke_main_window():
	""" Returns Nuke's main window.
	"""
	for obj in QtWidgets.QApplication.topLevelWidgets():
		if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'):
			return obj
	raise RuntimeError("Could not find DockMainWindow instance")


# ----------------------------------------------------------------------------
# Run functions
# ----------------------------------------------------------------------------

def run_maya(**kwargs):
	""" Run in Maya.
	"""
	_maya_delete_ui()  # Delete any already existing UI
	renderSubmitUI = RenderSubmitUI(parent=_maya_main_window())

	# Makes Maya perform magic which makes the window stay on top in OS X and
	# Linux. As an added bonus, it'll make Maya remember the window position.
	renderSubmitUI.setProperty("saveWindowPref", True)

	renderSubmitUI.display(**kwargs)  # Show the UI


def run_nuke(**kwargs):
	""" Run in Nuke.
	"""
	_nuke_delete_ui()  # Delete any already existing UI
	renderSubmitUI = RenderSubmitUI(parent=_nuke_main_window())

	renderSubmitUI.display(**kwargs)  # Show the UI


# Detect environment and run application
if os.environ['IC_ENV'] == 'STANDALONE':
	verbose.print_("[GPS] Render Submit", 4)
elif os.environ['IC_ENV'] == 'MAYA':
	import maya.cmds as mc
	verbose.print_("[GPS] Render Submit for Maya", 4)
	# run_maya()
elif os.environ['IC_ENV'] == 'NUKE':
	import nuke
	import nukescripts
	verbose.print_("[GPS] Render Submit for Nuke", 4)
	# run_nuke()
# elif __name__ == '__main__':
# 	run_standalone()

