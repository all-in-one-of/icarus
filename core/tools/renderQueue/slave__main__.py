#!/usr/bin/python

# [Icarus] Batch Render Slave slave__main__.py
# v0.1
#
# Mike Bonnington <mike.bonnington@gps-ldn.com>
# (c) 2016 Gramercy Park Studios
#
# Runs on the client machine and looks in the render queue for render jobs to execute.


from PySide import QtCore, QtGui
from slave_ui import * # <- import your app's UI file (as generated by pyside-uic)
import os, socket, sys, time

# Import custom modules
import renderQueue
import sequence as seq
import verbose


class gpsRenderSlaveApp(QtGui.QDialog):

	def __init__(self, parent = None):
		super(gpsRenderSlaveApp, self).__init__()
		self.ui = Ui_Dialog()
		self.ui.setupUi(self)

		self.localhost = socket.gethostname()

		# Instantiate render queue class and load data
		self.rq = renderQueue.renderQueue()
		self.rq.loadXML(os.path.join(os.environ['PIPELINE'], 'core', 'config', 'renderQueue.xml'))

		# Connect signals & slots
		self.ui.dequeue_pushButton.clicked.connect(self.dequeue)
		self.ui.close_pushButton.clicked.connect(self.exit)

		#self.dequeue() # should only be done if slave is idle


	def dequeue(self):
		""" THIS IS ALL A BIT ROPEY ATM
		"""
		import signal, subprocess

		timeFormatStr = "%Y/%m/%d %H:%M:%S" # "%a, %d %b %Y %H:%M:%S"
		startTimeSec = time.time() # used for measuring the time spent rendering
		startTime = time.strftime(timeFormatStr)

		#self.rq.loadXML(quiet=True) # reload XML data - this is being done by the dequeuing function

		jobElement = self.rq.dequeueJob()
		if jobElement is None:
			print "No jobs to render."
			return False
		jobID = jobElement.get('id')

		taskID, frames = self.rq.dequeueTask(jobID, self.localhost)
		if not taskID:
			print "Job ID %s: no tasks to render." %jobID
			return False

		print "Job ID %s, Task ID %s: Rendering..." %(jobID, taskID)
		frameList = seq.numList(frames)
		startFrame = min(frameList)
		endFrame = max(frameList)

		slaveStatus = "Busy"
		self.ui.dequeue_pushButton.setEnabled(False)

		# Fill info fields
		self.ui.slave_lineEdit.setText(self.localhost)
		self.ui.job_lineEdit.setText(self.rq.getValue(jobElement, 'name'))
		self.ui.user_lineEdit.setText(self.rq.getValue(jobElement, 'user'))

		self.ui.submitted_lineEdit.setText(self.rq.getValue(jobElement, 'submitTime'))
		self.ui.started_lineEdit.setText(startTime)
		self.ui.elapsed_lineEdit.setText("")

		self.ui.scene_lineEdit.setText(self.rq.getValue(jobElement, 'mayaScene'))
		self.ui.project_lineEdit.setText(self.rq.getValue(jobElement, 'mayaProject'))
		self.ui.frames_lineEdit.setText(frames)
		self.ui.flags_lineEdit.setText(self.rq.getValue(jobElement, 'mayaFlags'))
		self.ui.command_lineEdit.setText(self.rq.getValue(jobElement, 'mayaRenderCmd'))
		#self.ui.Dialog.setWindowTitle("Render Slave: %s" %(self.localhost)) # this doesn't seem to work

		# try:
		# 	renderCmd = '"%s"' %os.environ['MAYARENDERVERSION'] # store this in XML as maya version may vary with project
		# except KeyError:
		# 	print "ERROR: Path to Maya Render command executable not found. This can be set with the environment variable 'MAYARENDERVERSION'."
		#renderCmd = '"%s"' %os.path.normpath(self.rq.getValue(jobElement, 'mayaRenderCmd'))
		renderCmd = '"%s"' %self.rq.getValue(jobElement, 'mayaRenderCmd')

		cmdStr = ''
		args = '-proj "%s"' %self.rq.getValue(jobElement, 'mayaProject')
		frameRangeArgs = ''

		sceneName = '"%s"' %self.rq.getValue(jobElement, 'mayaScene')

		mayaFlags = self.rq.getValue(jobElement, 'mayaFlags')
		if mayaFlags is not None:
			args += ' %s' %self.rq.getValue(jobElement, 'mayaFlags')

		# Construct command(s)
		if True: # replace with check if the job jas any tasks
			frameRangeArgs = '-s %d -e %d' %(int(startFrame), int(endFrame))

			cmdStr += '%s %s %s %s' %(renderCmd, args, frameRangeArgs, sceneName)

		else:
			cmdStr = '%s %s %s' %(renderCmd, args, sceneName)

		if os.environ['ICARUS_RUNNING_OS'] == 'Windows':
			verbose.print_(cmdStr, 4)
			#self.ui.output_textEdit.setPlainText(cmdStr)
			#self.renderProcess = subprocess.Popen(cmdStr, shell=True) #, stdout=subprocess.PIPE, shell=True)
			output = subprocess.Popen(cmdStr, stdout=subprocess.PIPE).communicate()[0] # find a way to do this without locking the UI
			self.ui.output_textEdit.setPlainText(output)
			#os.system(cmdStr) #, stdout=subprocess.PIPE, shell=True)
		else:
			#print cmdStr
			self.ui.output_textEdit.setPlainText(cmdStr)
			#self.renderProcess = subprocess.Popen(cmdStr, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid)

		# Disable UI to prevent new renders being submitted
		#self.tglUI(False)

		# print "waiting 3 sec"
		# time.sleep(3) # wait 3 seconds
		slaveStatus = "Idle"
		self.ui.dequeue_pushButton.setEnabled(True)
		#self.rq.setStatus(jobID, "In Progress (0%)")
		totalTimeSec = time.time() - startTimeSec # calculate time spent rendering task

		self.rq.completeTask(jobID, taskID, totalTimeSec)



	# def kill(self):
	# 	""" Kill the rendering process.
	# 	"""
	# 	try:
	# 		print "Attempting to kill rendering process (PID=%s)" %self.renderProcess.pid
	# 		if os.environ['ICARUS_RUNNING_OS'] == 'Windows':
	# 			os.killpg(self.renderProcess.pid, signal.SIGTERM)
	# 		else:
	# 			os.kill(self.renderProcess.pid, signal.CTRL_C_EVENT)

	# 	except (OSError, AttributeError):
	# 		print "Warning: Cannot kill rendering process as there is no render in progress."

	# 	# Re-enable UI
	# 	self.tglUI(True)


	def exit(self):
		""" Exit the dialog.
		"""
		self.hide()


if __name__ == "__main__":
	app = QtGui.QApplication(sys.argv)

	# Initialise Icarus environment
	os.environ['ICWORKINGDIR'] = "N:\Dev\icarus\core\ui" # temp assignment
	sys.path.append(os.environ['ICWORKINGDIR'])
	import env__init__
	env__init__.setEnv()

	import rsc_rc # TODO: Check why this isn't working from within the UI file

	#app.setStyle('fusion') # Set UI style - you can also use a flag e.g. '-style plastique'

	# Apply UI style sheet
	qss=os.path.join(os.environ['ICWORKINGDIR'], "style.qss")
	with open(qss, "r") as fh:
		app.setStyleSheet(fh.read())

	renderSlaveApp = gpsRenderSlaveApp()
	renderSlaveApp.show()
	sys.exit(app.exec_())

else:
	renderSlaveApp = gpsRenderSlaveApp()
	print renderSlaveApp
	renderSlaveApp.show()

