#!/usr/bin/python

# [Icarus] Batch Render Queue Manager queue__main__.py
# v0.3
#
# Mike Bonnington <mike.Bonnington@gps-ldn.com>
# (c) 2016 Gramercy Park Studios
#
# A UI for managing the render queue, as well as executing render jobs.


from PySide import QtCore, QtGui
from queue_ui import * # <- import your app's UI file (as generated by pyside-uic)
import datetime, os, socket, sys, time

# Import custom modules
import renderQueue, sequence, verbose


class gpsRenderQueueApp(QtGui.QMainWindow):

	def __init__(self, parent = None):
		super(gpsRenderQueueApp, self).__init__()
		self.ui = Ui_MainWindow()
		self.ui.setupUi(self)

		self.timeFormatStr = "%Y/%m/%d %H:%M:%S"
		self.localhost = socket.gethostname()
		self.selection = []
		#verbose.registerStatusBar(self.ui.statusbar)

		# Instantiate render queue class and load data
		self.rq = renderQueue.renderQueue()
		self.rq.loadXML(os.path.join(os.environ['PIPELINE'], 'core', 'config', 'renderQueue.xml'))

		# Connect signals & slots
		self.ui.renderQueue_treeWidget.itemSelectionChanged.connect(self.updateToolbarUI)

		self.ui.jobSubmit_toolButton.clicked.connect(self.launchRenderSubmit)
		self.ui.refresh_toolButton.clicked.connect(self.updateRenderQueueView)

		self.ui.jobPause_toolButton.clicked.connect(lambda *args: self.changePriority(0, absolute=True)) # this lambda function is what's causing the multiple windows issue, no idea why though
		#self.ui.jobPause_toolButton.clicked.connect(self.changePriority)
		self.ui.jobDelete_toolButton.clicked.connect(self.deleteRenderJob)
		#self.ui.jobResubmit_toolButton.clicked.connect(self.resubmitJob)
		self.ui.jobPriority_slider.sliderMoved.connect(lambda value: self.changePriority(value)) # valueChanged # this lambda function is what's causing the multiple windows issue, no idea why though
		self.ui.jobPriority_slider.sliderReleased.connect(self.updatePriority)

		self.ui.taskComplete_toolButton.clicked.connect(self.completeTask)
		self.ui.taskRequeue_toolButton.clicked.connect(self.requeueTask)

		#self.ui.slave_toolButton.clicked.connect(self.toggleSlave)
		#self.ui.dequeue_toolButton.clicked.connect(self.dequeue)
		#self.ui.processKill_toolButton.clicked.connect(self.killRenderProcess)

		# Add context menu to slave control tool button
		self.ui.slaveControl_toolButton.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

		self.actionSlaveStart = QtGui.QAction("Start Slave", None)
		self.actionSlaveStart.triggered.connect(self.toggleSlave)
		#self.ui.slaveControl_toolButton.addAction(self.actionSlaveStart)

		self.actionSlaveStop = QtGui.QAction("Stop Slave", None)
		self.actionSlaveStop.triggered.connect(self.toggleSlave)
		#self.ui.slaveControl_toolButton.addAction(self.actionSlaveStop)

		self.actionKillTask = QtGui.QAction("Kill Current Task", None)
		self.actionKillTask.triggered.connect(self.killRenderProcess)
		#self.ui.slaveControl_toolButton.addAction(self.actionKillTask)

		self.actionSlaveStopAfterTask = QtGui.QAction("Stop Slave After Current Task Completion", None)
		self.actionSlaveStopAfterTask.triggered.connect(self.killRenderProcess)
		self.actionSlaveStopAfterTask.setCheckable(True)
		#self.ui.slaveControl_toolButton.addAction(self.actionSlaveStopAfterTask)

		self.setSlaveStatus("disabled")
		# statusIcon = QtGui.QIcon()
		# statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_stopped.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
		# self.ui.slaveControl_toolButton.setIcon(statusIcon)

		# Create timer to refresh the view and dequeue tasks every n milliseconds
		timer = QtCore.QTimer(self)
		self.connect(timer, QtCore.SIGNAL("timeout()"), self.updateRenderQueueView)
		self.connect(timer, QtCore.SIGNAL("timeout()"), self.dequeue)
		timer.start(5000)

		self.updateRenderQueueView()
		#self.updateSlaveView()
		self.updateToolbarUI()


	# def getCheckBoxValue(self, checkBox):
	# 	""" Get the value from a checkbox and return a Boolean value.
	# 	"""
	# 	if checkBox.checkState() == QtCore.Qt.Checked:
	# 		return True
	# 	else:
	# 		return False


	def launchRenderSubmit(self):
		""" Launches Render Submit dialog.
			TODO: Add support for Nuke jobs
		"""
		import submit__main__
		reload(submit__main__)
		# try:
		# 	self.renderSubmitApp.show()
		# 	self.renderSubmitApp.raise_()
		# except AttributeError:
		# 	self.renderSubmitApp = submit__main__.gpsRenderSubmitApp()
		# 	#print self.renderSubmitApp
		# 	self.renderSubmitApp.show()


	def updateRenderQueueView(self):
		""" Populates the render queue tree view widget with entries for render jobs and tasks.
			This probably shouldn't be writing to the XML file
		"""
		self.rq.loadXML(quiet=True) # reload XML data

		# Stop the widget from emitting signals
		self.ui.renderQueue_treeWidget.blockSignals(True)

		# Store expanded items
		expandedJobs = []
		root = self.ui.renderQueue_treeWidget.invisibleRootItem()
		child_count = root.childCount()
		for i in range(child_count):
			item = root.child(i)
			if item.isExpanded():
				expandedJobs.append( int(item.text(1)) )

		# Clear tree widget
		self.ui.renderQueue_treeWidget.clear()

		# Populate tree widget with render jobs
		for jobElement in self.rq.getJobs():
			renderJobItem = QtGui.QTreeWidgetItem(self.ui.renderQueue_treeWidget)

			jobTotalTimeSeconds = 0
			inProgressTasks = 0
			completedTasks = 0

			# Populate render tasks
			taskElements = jobElement.findall('task')
			for taskElement in taskElements:
				renderTaskItem = QtGui.QTreeWidgetItem(renderJobItem)

				renderTaskItem.setText(0, "Task %s" %taskElement.get('id'))
				renderTaskItem.setText(1, taskElement.get('id'))
				renderTaskItem.setText(3, self.rq.getValue(taskElement, 'frames'))

				taskStatus = self.rq.getValue(taskElement, 'status')
				renderTaskItem.setText(4, taskStatus)

				if taskStatus == "In Progress":
					inProgressTasks += 1
				if taskStatus == "Done":
					completedTasks += 1

				try:
					totalTimeSeconds = float(self.rq.getValue(taskElement, 'totalTime')) # use float and round for millisecs
					jobTotalTimeSeconds += totalTimeSeconds
					totalTime = str(datetime.timedelta(seconds=int(totalTimeSeconds)))
				except (TypeError, ValueError):
					totalTime = None
				renderTaskItem.setText(8, totalTime)

				renderTaskItem.setText(9, self.rq.getValue(taskElement, 'slave'))
				#renderTaskItem.setText(9, self.rq.getValue(taskElement, 'command'))

			renderJobItem.setText(0, self.rq.getValue(jobElement, 'name'))
			renderJobItem.setText(1, jobElement.get('id'))
			renderJobItem.setText(2, self.rq.getValue(jobElement, 'type'))
			renderJobItem.setText(3, self.rq.getValue(jobElement, 'frames'))

			# Calculate job progress and update status
			percentComplete = (float(completedTasks) / float(len(taskElements))) * 100 # this logic is wrong if tasks are unequal size
			if percentComplete == 0:
				if inProgressTasks == 0:
					jobStatus = "Queued"
				else:
					jobStatus = "In Progress (0%)"
			elif percentComplete == 100:
				jobStatus = "Done"
			else:
				jobStatus = "In Progress (%d%%)" %percentComplete
			self.rq.setStatus(jobElement.get('id'), jobStatus) # write to xml
			renderJobItem.setText(4, jobStatus)

			renderJobItem.setText(5, self.rq.getValue(jobElement, 'priority'))
			renderJobItem.setText(6, self.rq.getValue(jobElement, 'user'))
			renderJobItem.setText(7, self.rq.getValue(jobElement, 'submitTime'))

			# Calculate time taken
			try:
				jobTotalTime = str(datetime.timedelta(seconds=int(jobTotalTimeSeconds)))
			except (TypeError, ValueError):
				jobTotalTime = None
			renderJobItem.setText(8, str(jobTotalTime))

			# Re-expand items
			if int(jobElement.get('id')) in expandedJobs:
				renderJobItem.setExpanded(True)

			# Resize columns
			for i in range(0, self.ui.renderQueue_treeWidget.columnCount()):
				self.ui.renderQueue_treeWidget.resizeColumnToContents(i)

			# Hide ID column
			#self.ui.renderQueue_treeWidget.setColumnHidden(1, True)

			# Sort by submit time column - move this somewhere else?
			self.ui.renderQueue_treeWidget.sortByColumn(7, QtCore.Qt.DescendingOrder)

			# Retain selection
			#renderJobItem.setSelected(True)
			self.restoreSelection()

		# Re-enable signals
		self.ui.renderQueue_treeWidget.blockSignals(False)

		self.updateSlaveView()


	def updateSlaveView(self):
		""" Update the information in the slave info area.
		"""
		self.ui.slaveControl_toolButton.setText("%s (%s)" %(self.localhost, self.slaveStatus))


	def updateToolbarUI(self):
		""" Store the current selection.
			Only allow jobs OR tasks to be selected, not both.
			Update the toolbar UI based on the selection in the render queue view.
		"""
		self.selection = []
		selectionType = None

		for item in self.ui.renderQueue_treeWidget.selectedItems():
			if item.parent(): # task is selected
				currentItem = self.ui.renderQueue_treeWidget.currentItem()
				if selectionType == "Job":
					self.selection = []
					self.ui.renderQueue_treeWidget.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
					self.ui.renderQueue_treeWidget.clearSelection()
					self.ui.renderQueue_treeWidget.setCurrentItem(currentItem)
				else:
					selectionType = "Task"
					self.ui.renderQueue_treeWidget.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
					jobTaskID = int(item.parent().text(1)), int(item.text(1))
					#print "Task selected: %s %s" %jobTaskID
					self.selection.append(jobTaskID)
					self.ui.job_groupBox.setEnabled(False)
					self.ui.task_groupBox.setEnabled(True)
			else: # job is selected
				currentItem = self.ui.renderQueue_treeWidget.currentItem()
				if selectionType == "Task":
					self.selection = []
					self.ui.renderQueue_treeWidget.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
					self.ui.renderQueue_treeWidget.clearSelection()
					self.ui.renderQueue_treeWidget.setCurrentItem(currentItem)
				else:
					selectionType = "Job"
					self.ui.renderQueue_treeWidget.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
					jobTaskID = int(item.text(1)), -1
					#print "Job selected: %s %s" %jobTaskID
					self.selection.append(jobTaskID)
					self.ui.job_groupBox.setEnabled(True)
					self.ui.task_groupBox.setEnabled(False)

		if not self.selection: # nothing is selected
			#print "Nothing selected."
			self.ui.job_groupBox.setEnabled(False)
			self.ui.task_groupBox.setEnabled(False)

		#print self.selection


	def restoreSelection(self):
		""" Reselect items.
		"""
		expandedJobs = []
		root = self.ui.renderQueue_treeWidget.invisibleRootItem()
		for j in range(root.childCount()):
			jobItem = root.child(j)
			jobID = int(jobItem.text(1))
			jobTaskID = jobID, -1
			if jobTaskID in self.selection:
				jobItem.setSelected(True)

			for t in range(jobItem.childCount()):
				taskItem = jobItem.child(t)
				taskID = int(taskItem.text(1))
				jobTaskID = jobID, taskID
				#jobTaskID = int(taskItem.parent().text(1)), int(taskItem.text(1))
				if jobTaskID in self.selection:
					taskItem.setSelected(True)


	def deleteRenderJob(self):
		""" Removes selected render job from the database and updates the view.
		"""
		jobIDs = []

		try:
			for item in self.ui.renderQueue_treeWidget.selectedItems():
				if not item.parent(): # if item has no parent then it must be a top level item, and therefore also a job
					jobIDs.append( int(item.text(1)) )

			for jobID in jobIDs:
				print "Deleting job: ID %d" %jobID
				self.rq.deleteJob(jobID)

			self.updateRenderQueueView()

		except ValueError:
			pass


	def changePriority(self, amount=0, absolute=False):
		""" Changes priority of the selected render.
		"""
		try:
			for item in self.ui.renderQueue_treeWidget.selectedItems():
				if not item.parent(): # if item has no parent then it must be a top level item, and therefore also a job
					index = int(item.text(1))
					minPriority = 0
					maxPriority = 100

					if absolute:
						newPriority = amount
					else:
						currentPriority = self.rq.getPriority(index)
						newPriority = currentPriority+amount

					if newPriority <= minPriority:
						item.setText(5, str(minPriority))
					elif newPriority >= maxPriority:
						item.setText(5, str(maxPriority))
					else:
						item.setText(5, str(newPriority))

					if absolute:
						self.updatePriority()

		except ValueError:
			pass


	def updatePriority(self):
		""" Store the changed priority value(s).
		"""
		try:
			for item in self.ui.renderQueue_treeWidget.selectedItems():
				if not item.parent(): # if item has no parent then it must be a top level item, and therefore also a job
					index = int(item.text(1))
					priority = int(item.text(5))
					self.rq.setPriority(index, priority)

			self.updateRenderQueueView()

		except ValueError:
			pass

		self.ui.jobPriority_slider.setValue(0) # reset priority slider to zero when released


	# def resubmitJob(self):
	# 	""" Resubmit selected job(s) to render queue.
	# 	"""
	# 	try:
	# 		for item in self.ui.renderQueue_treeWidget.selectedItems():
	# 			if not item.parent(): # if item has no parent then it must be a top level item, and therefore also a job

	# 				jobName = self.rq.getValue(item, 'name')
	# 				jobType = self.rq.getValue(item, 'type')
	# 				priority = self.rq.getValue(item, 'priority')
	# 				frames = self.rq.getValue(item, 'frames')
	# 				taskSize = self.rq.getValue(item, 'taskSize')

	# 				mayaScene = self.rq.getValue(item, 'mayaScene')
	# 				mayaProject = self.rq.getValue(item, 'mayaProject')
	# 				mayaFlags = self.rq.getValue(item, 'mayaFlags')
	# 				mayaRenderCmd = self.rq.getValue(item, 'mayaRenderCmd')

	# 				taskList = []

	# 				genericOpts = jobName, jobType, priority, frames, taskSize
	# 				mayaOpts = mayaScene, mayaProject, mayaFlags, mayaRenderCmd

	# 				self.rq.newJob(genericOpts, mayaOpts, taskList, os.environ['USERNAME'], time.strftime(self.timeFormatStr))

	# 	except ValueError:
	# 		pass


	def completeTask(self):
		""" Mark the selected task as completed.
		"""
		jobTaskIDs = [] # this will hold a tuble containing (job id, task id)

		try:
			for item in self.ui.renderQueue_treeWidget.selectedItems():
				if item.parent(): # if item has parent then it must be a subitem, and therefore also a task
					jobTaskID = int(item.parent().text(1)), int(item.text(1))
					jobTaskIDs.append(jobTaskID)

			for jobTaskID in jobTaskIDs:
				print "Completing task: Job ID %d, Task ID %d" %jobTaskID
				self.rq.completeTask(jobTaskID[0], jobTaskID[1], 0)

			self.updateRenderQueueView()

		except ValueError:
			pass


	def requeueTask(self):
		""" Requeue the selected task.
		"""
		jobTaskIDs = [] # this will hold a tuble containing (job id, task id)

		try:
			for item in self.ui.renderQueue_treeWidget.selectedItems():
				if item.parent(): # if item has parent then it must be a subitem, and therefore also a task
					jobTaskID = int(item.parent().text(1)), int(item.text(1))
					jobTaskIDs.append(jobTaskID)

			for jobTaskID in jobTaskIDs:
				print "Requeuing task: Job ID %d, Task ID %d" %jobTaskID
				self.rq.requeueTask(jobTaskID[0], jobTaskID[1])

			self.updateRenderQueueView()

		except ValueError:
			pass


	def toggleSlave(self):
		""" Enable or disable the local slave.
		"""
		if self.slaveStatus == "disabled":
			self.setSlaveStatus("idle")
			# self.slaveStatus = "idle"
			# statusIcon = QtGui.QIcon()
			# statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_waiting.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
			# self.ui.slaveControl_toolButton.setIcon(statusIcon)
		else:
			self.setSlaveStatus("disabled")
			# self.slaveStatus = "disabled"
			# statusIcon = QtGui.QIcon()
			# statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_stopped.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
			# self.ui.slaveControl_toolButton.setIcon(statusIcon)

		self.updateSlaveView()


	def setSlaveStatus(self, status):
		""" Enable or disable the local slave.
			TODO: dynamically update the pop-up menu options
		"""
		self.slaveStatus = status
		statusIcon = QtGui.QIcon()

		if status == "disabled":
			statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_stopped.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
			self.ui.slaveControl_toolButton.setChecked(False)
			self.ui.slaveControl_toolButton.addAction(self.actionSlaveStart)
		elif status == "idle":
			self.ui.slaveControl_toolButton.setChecked(True)
			statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_ready.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
			self.ui.slaveControl_toolButton.addAction(self.actionSlaveStop)
		elif status == "rendering":
			self.ui.slaveControl_toolButton.setChecked(True)
			statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_ok.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
			self.ui.slaveControl_toolButton.addAction(self.actionSlaveStop)
			self.ui.slaveControl_toolButton.addAction(self.actionKillTask)
			self.ui.slaveControl_toolButton.addAction(self.actionSlaveStopAfterTask)

		self.ui.slaveControl_toolButton.setIcon(statusIcon)
		#self.updateSlaveView()


	def dequeue(self):
		""" Dequeue a render task from the queue and start rendering.
			THIS IS ALL A BIT ROPEY ATM
		"""
		if self.slaveStatus != "idle":
			return False
		#elif self.slaveStatus != "rendering":

		startTimeSec = time.time() # used for measuring the time spent rendering
		startTime = time.strftime(self.timeFormatStr)

		#self.rq.loadXML(quiet=True) # reload XML data - this is being done by the dequeuing function

		# Look for a suitable job to render - perhaps check here for a few easy-to-detect errors, i.e. existence of scene, render command, etc.
		jobElement = self.rq.dequeueJob()
		if jobElement is None:
			print "[%s] No jobs to render." %self.localhost
			return False
		jobID = jobElement.get('id')

		# Look for tasks to start rendering
		taskID, frames = self.rq.dequeueTask(jobID, self.localhost)
		if not taskID:
			print "[%s] Job ID %s: no tasks to render." %(self.localhost, jobID)
			return False

		print "[%s] Job ID %s, Task ID %s: Rendering..." %(self.localhost, jobID, taskID)
		if frames == 'Unknown':
			frameList = frames
		else:
			frameList = sequence.numList(frames)
			startFrame = min(frameList)
			endFrame = max(frameList)

		# Fill info fields
		self.ui.taskInfo_label.setText("Rendering %s %s from '%s'" %(verbose.pluralise("frame", frameList), frames, self.rq.getValue(jobElement, 'name')))
		#self.ui.runningTime_label.setText(self.rq.getValue(jobElement, 'submitTime')) # change this to display the task running time
		self.ui.runningTime_label.setText(startTime) # change this to display the task running time

		# try:
		# 	renderCmd = '"%s"' %os.environ['MAYARENDERVERSION'] # store this in XML as maya version may vary with project
		# except KeyError:
		# 	print "ERROR: Path to Maya Render command executable not found. This can be set with the environment variable 'MAYARENDERVERSION'."
		#renderCmd = '"%s"' %os.path.normpath(self.rq.getValue(jobElement, 'mayaRenderCmd'))
		renderCmd = self.rq.getValue(jobElement, 'mayaRenderCmd')
		# if not os.path.isfile(renderCmd): # disabled this check 
		# 	print "ERROR: Maya render command not found: %s" %renderCmd
		# 	return False

		sceneName = self.rq.getValue(jobElement, 'mayaScene')
		if not os.path.isfile(sceneName):
			print "ERROR: Scene not found: %s" %sceneName
			self.rq.requeueTask(jobID, taskID)
			#self.rq.setStatus(jobID, "Failed")
			return False

		cmdStr = ''
		args = '-proj "%s"' %self.rq.getValue(jobElement, 'mayaProject')

		mayaFlags = self.rq.getValue(jobElement, 'mayaFlags')
		if mayaFlags is not None:
			args += ' %s' %self.rq.getValue(jobElement, 'mayaFlags')

		# Construct command(s)
		if frames == 'Unknown':
			cmdStr = '"%s" %s "%s"' %(renderCmd, args, sceneName)
		else:
			cmdStr += '"%s" %s -s %d -e %d "%s"' %(renderCmd, args, int(startFrame), int(endFrame), sceneName)

		# Set rendering status
		self.setSlaveStatus("rendering")
		# statusIcon = QtGui.QIcon()
		# statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_ok.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
		# self.ui.slaveControl_toolButton.setIcon(statusIcon)

		#self.ui.processKill_toolButton.setEnabled(True)
		#self.ui.dequeue_toolButton.setEnabled(False)
		self.ui.slaveControl_toolButton.setText("%s (%s)" %(self.localhost, self.slaveStatus))

		#self.ui.command_lineEdit.setText(cmdStr)
		self.startRender(cmdStr) # start the rendering command

		if self.renderProcess.poll() is not None:
			totalTimeSec = time.time() - startTimeSec # calculate time spent rendering task

			# if self.getCheckBoxValue(self.ui.stopAfterTask_checkBox):
			# 	self.slaveStatus = "disabled"
			# 	self.ui.slave_toolButton.setChecked(False)
			# else:
			# 	self.slaveStatus = "idle"
			# 	#self.ui.slave_toolButton.setChecked(True)

			self.setSlaveStatus("idle")

			#self.ui.dequeue_toolButton.setEnabled(True)
			self.ui.taskInfo_label.setText("")
			self.ui.runningTime_label.setText("")
			#self.rq.setStatus(jobID, "In Progress (0%)")
			self.rq.completeTask(jobID, taskID, totalTimeSec)
			self.updateRenderQueueView()


	def startRender(self, cmdStr):
		""" Start rendering.
			TODO: find a way to capture the output without locking the UI
		"""
		#import signal
		import subprocess

		if os.environ['ICARUS_RUNNING_OS'] == 'Windows':
			verbose.print_(cmdStr, 4)
			self.renderProcess = subprocess.Popen(cmdStr, shell=False, stdout=subprocess.PIPE)
			output = self.renderProcess.communicate()[0] # find a way to do this without locking the UI
			self.ui.output_textEdit.setPlainText(output)

		#	self.renderProcess = subprocess.Popen(cmdStr, shell=False)

			#os.system(cmdStr) #, stdout=subprocess.PIPE, shell=True)
		else:
			verbose.print_(cmdStr, 4)
			#self.ui.output_textEdit.setPlainText(cmdStr)
			#self.renderProcess = subprocess.Popen(cmdStr, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid)

		#while self.renderProcess.poll() is None:
		#	pass


	def killRenderProcess(self):
		""" Kill the rendering process.
		"""
		#import signal
		#import subprocess

		print "Attempting to kill process %s" %self.renderProcess
		self.renderProcess.terminate() # kill()
		# if self.slaveStatus == "rendering":
		# 	self.renderProcess.terminate()
		# else:
		# 	print "No render in progress."

		#totalTimeSec = time.time() - startTimeSec # calculate time spent rendering task

		# if self.getCheckBoxValue(self.ui.stopAfterTask_checkBox):
		# 	self.slaveStatus = "disabled"
		# 	self.ui.slave_toolButton.setChecked(False)
		# else:
		# 	self.slaveStatus = "idle"

		self.setSlaveStatus("idle")
		# statusIcon = QtGui.QIcon()
		# statusIcon.addPixmap(QtGui.QPixmap(":/rsc/rsc/status_icon_waiting.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
		# self.ui.slaveControl_toolButton.setIcon(statusIcon)

		self.ui.taskInfo_label.setText("")
		self.ui.runningTime_label.setText("")
		self.rq.completeTask(jobID, taskID)
		self.updateRenderQueueView()



if __name__ == "__main__":
	app = QtGui.QApplication(sys.argv)

	# Initialise Icarus environment
	sys.path.append(os.environ['ICWORKINGDIR'])
	import env__init__
	env__init__.setEnv()
	#env__init__.appendSysPaths()

	import rsc_rc # TODO: Check why this isn't working from within the UI file

	#app.setStyle('fusion') # Set UI style - you can also use a flag e.g. '-style plastique'

	# Apply UI style sheet
	qss=os.path.join(os.environ['ICWORKINGDIR'], "style.qss")
	with open(qss, "r") as fh:
		app.setStyleSheet(fh.read())

	renderQueueApp = gpsRenderQueueApp()
	renderQueueApp.show()
	sys.exit(app.exec_())

# else:
# 	renderQueueApp = gpsRenderQueueApp()
# 	print renderQueueApp
# 	renderQueueApp.show()

