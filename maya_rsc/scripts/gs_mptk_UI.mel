/*
Copyright (c) 2011, Glyph Software, LLC.  All Rights Reserved.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


//v009 swap and reorder working
//v011 swatchDisplay and projection path UI working with swap and reorder.   
//v012 changed text "interpolation" to "angle" to match new gs_projCamMix attr naming.   
//v013 added functionality for image path button (open file dialog). Projection name text now renameable text field.
//v015 button highlighting for active projections now reorders and swaps
//v016 projAttrs camera selection and assign buttons working
//v017 useFacingRatio and Angle working in Projection Attributes, changed layout for projection list to include add/remove/pick buttons
//v018 object list now populates with geo assigned to shading groups of which gs_projCamMix nodes have connections
//v019 object list buttons now working, NOTE: no support for shaders assigned to components, and no error handling for improper selection types
//v020 code cleanup
//v021 fixed bug with button highlight on reorder that caused more than one button to be highlighted
//v022 updated highlighting for bkgnd of rowColumnLayout instead of button
//v023 new createUI global proc for building and top-level refreshing, gs_projCamMix +, -, ^ woking
//v025 switched to MR shader
//v026 added support for colors without connections in projection list, updated reorder and swatch to support mental ray shader attrs
//v027 image multi attrs without inputs (projections) can now create projection networks through the update path button
//v028 added support for file node connections
//v029 adding and removing projections through the + and - buttons now works. code cleanup. proj list highlighting now works with adding and removing projections.
//v030 aesthetic update for object list; it now encompasses the entire pane
//v033 additional mattes now working.  new code for UI refresh (window doesn't redraw). new code for AEremoveMulti to better handle layout paths (not perfect).
//v034 added About in Help menu for versioning, fixed bug when trying to assign new matte file to exisiting matte projection
//v035 removed _MR_v127 for new versioning
//v037 fixed camera "none" in attrs for projections that have camera connections. mptk_tabs separated from mptk_createUI, but gs_mptk_deleteMixNode still destroys UI completely, then calls mptk_createUI due to unknown bug.
//v038 Additional Matte +/- working
//v039 + cam now links world matrix to placement matrix
//v040 fixed +/- shader and modified global procs to better handle refreshing within child UI layout
//v041 added renameMatteNode global proc
//v042 changed all procs to global procs
//v043 changed camera fitType to film gate
//v044 added debug options; all projection name text fields now load projection node name instead of file or ramp names; create new gs_projCamMix node now loads projection attrs after creation
//v045 loadMatteAttrs now only called when new matte is created; added channel selection for matte loading
//v046 fixed various bugs in network relationships of matte create/destroy procs
//v047 fixed reorder issue with wrong buffer index on drop callback; removed restriction of camera button label requiring input in path field (loadProjAttrs); fixed camera assignment mismatching; fixed UV wrap on matte place2d nodes
//v048 modified path to AEReplaceNonNumeric
//v049 modified path to AEReplaceNonNumeric with new method of seeking the UI tree
//v050 updated reorder connections proc to retain matte attribute list of selected projection group
//v052 adding a new projection now detects alpha channels and automatically adds to the matte list if desired; new file filtering option in Options menu allows for setting the filtering of all files in the node network
//v053 added create coverage map to File menu
//v054 commented out elliptical filtering as filtering option; refresh UI from File menu now calls proper number of arguments; enable/disable of shadow occlusion and facing ratio parameters now working in UI
//v055 updating UI path field now updates connections; addProj now properly handles files without projections
//v056 updated object list assignments to automatically add a new surface shader if none is attached, and also to look for all outgoing connections from gs_projCamMix, including outMattes
//v057 fixed Additional Mattes channel connection issue
//v058 fixed loadMatteAttrs highlight bug; numProjections var input was receiving the current proj num, not the total mattes num; commented AENewNonNumericMulti--not necessary and causing errors; fixed bug in loadMatteImage that prevented ramps from being reassigned as file textures
//v059 commenting AENewNonNumericMulti in last version broke addProj proc so this version modified code to get it working; useShadowOcclusion and useFacingRatio now enable/disable for proj indices > 0
//v061 replaced AERemoveMultiElement with refreshAE, which is more stable; removing the last projection group no longer throws an index error; removing a projection group now creates a new UI index for each tab, which fixes useShadowOcclusion enable/disable bug; addProj update to fix bug when adding new projection from index 0
//v062 updated Create Coverage Map to reassign original shaders after map creation
//v066 added force update all gs_viewportProj
//v067 added import bundle
//v068 fixed UI stretch pane bug for Maya 2012
//v069 fixed infinite loops with parent constraints on cameras
//v072 image sequence working, fixed a number of bugs from v069 relating to while loops
//v073 sequence expressions on file nodes can now overwrite each other
//v074 changed mask connection from .outColorR to .outAlpha to get around Maya bug on Linux during batch render
//v076 auto import added, alpha detection for images set properly for mental ray, ramps replaced with alpha if alpha channel detected in projection
//v077 added VRay support
//v078 fixed VRay rebuilding only 1 network when multiple exist
//v079 added layered projection option for gs_viewport, and connected menu options for each mix node
//v082 changing matte attributes now updates vray networks, and enabling vray rendering now creates networks for all tabs
//v084 set default color to 0 0 0 for mattes when alpha channel detected
//v085 fixed image sequence padding issue; disabled refreshUI
//v086 auto-import SFM data now correctly assigns projection camera to default ramp matte
//v087 fixed viewport layering bug when more than 7 projections in the projection list
//v088 fixed shadow occlusion alpha compositing issue by disabling alpha compositing when using shadow occlusion; fixed viewport connection mangling when relaunching UI with multiple gs_projCamMix nodes in the scene; deleting a gs_projCamMix node now correctly removes all associated nodes; deleting gs_projCamMix does not delete irrelevant camera connections such as animation
//v089 set outAlpha to outColorR for V-Ray mask projections.  Mental Ray remains unchanged due to bug during batch rendering.
//v090 V-Ray mtlWrapper is now connected properly the first time the vraySpecificSurfaceShader attribute is created; added camera offsets, film back size, and fit type connections to gs_viewportProj for automatic updating
//v091 image sequence handling now supports additional mattes, projection reordering.  Fixed poor network graph maintenence for projections sending the alpha channel to the additional mattes list. 

mptk_createUI (0,0,0,0,0,0);

// since this is the first time loading the UI, select first index for each gs_projCamMix node
string $mptk_allProjCamMix[] = `ls -type gs_projCamMix`;     
for ($x=0; $x<`size $mptk_allProjCamMix`; $x++){
    int $mptk_numProjections = gs_projCamMix_query_num($mptk_allProjCamMix[$x]);
    string $mptk_projNode = `textField -q -tx ("mptk_UI_tabs_child_0_mptk_UI_projName0")`;
    gs_mptk_loadProjAttrs($mptk_allProjCamMix[$x], $mptk_projNode, $mptk_numProjections, $x, 0);
}

/////////////////  START UI //////////////////////


global proc mptk_createUI (int $debugOption, int $debugStep, int $fileFiltering, int $vpGamma, int $layeredTex, int $vrayRendering){
   
   if (`window -exists gs_mptk_UI`) deleteUI -window gs_mptk_UI;
        
   string $gs_mptk_UI = `window -t "gs_mptk" gs_mptk_UI`;
   
   //    MENU BAR    //
   string $gs_mptk_UI_menuBar = `menuBarLayout gs_mptk_UI_menuBar`;
   menu -label "File";
       menuItem -label "Import..." -c gs_mptk_import;
       menuItem -label "New Shader" -c gs_mptk_createMixNode;
       menuItem -label "Refresh UI" refreshUI;
       menuItem -label "Create Coverage Map" -c gs_createCoverageMap;
       menuItem -label "Close" -c "deleteUI -window gs_mptk_UI";
   menu -label "Options" gs_mptk_menuOptions; 
       string $gs_mptk_vrayRenderCmd = "gs_mptk_vrayRebuildAll";
       menuItem -cb $vrayRendering -label "VRay Rendering" -c $gs_mptk_vrayRenderCmd gs_mptk_vrayRender;
       menuItem -subMenu 1 -label "File Filtering";
           string $filterOffCmd = "gs_mptk_fileFiltering(\"Off\")";
           menuItem -cb $fileFiltering -label "Off" -c $filterOffCmd gs_mptk_fileFiltering_Off;
           string $filterMipmapCmd = "gs_mptk_fileFiltering(\"Mipmap\")";
           menuItem -cb $fileFiltering -label "Mipmap" -c $filterMipmapCmd gs_mptk_fileFiltering_Mipmap;
           string $filterBoxCmd = "gs_mptk_fileFiltering(\"Box\")";
           menuItem -cb $fileFiltering -label "Box" -c $filterBoxCmd gs_mptk_fileFiltering_Box;
           string $filterQuadraticCmd = "gs_mptk_fileFiltering(\"Quadratic\")";
           menuItem -cb $fileFiltering -label "Quadratic" -c $filterQuadraticCmd gs_mptk_fileFiltering_Quadratic;
           string $filterQuarticCmd = "gs_mptk_fileFiltering(\"Quartic\")";
           menuItem -cb $fileFiltering -label "Quartic" -c $filterQuarticCmd gs_mptk_fileFiltering_Quartic;
           string $filterGaussianCmd = "gs_mptk_fileFiltering(\"Gaussian\")";
           menuItem -cb $fileFiltering -label "Gaussian" -c $filterGaussianCmd gs_mptk_fileFiltering_Gaussian;
           //string $filterEllipticalCmd = "gs_mptk_fileFiltering(\"Elliptical\")";
           //menuItem -cb $fileFiltering -label "Elliptical" -c $filterEllipticalCmd gs_mptk_fileFiltering_Elliptical;
       setParent -menu gs_mptk_menuOptions;
       string $gs_mptk_sRGBtoggleCmd = "gs_mptk_sRGBtoggle";
       menuItem -cb $vpGamma -label "Viewport Lin to sRGB" -c $gs_mptk_sRGBtoggleCmd gs_mptk_viewport;
       string $gs_mptk_layeredProjCmd = "gs_mptk_layeredProjToggle";
       menuItem -cb $layeredTex -label "Viewport Layering" -c $gs_mptk_layeredProjCmd gs_mptk_layered;
       menuItem -cb $debugOption -label "Debug Mode" gs_mptk_debugMode;
       menuItem -cb $debugStep -label "Debug Step" gs_mptk_debugStep;
   menu -label "Help";
       menuItem -label "Documentation" -c gs_mptk_docs;
       menuItem -label "About..." -c gs_mptk_aboutDialog;
   setParent ..;
   
   string $debugMode = "mptk_createUI( `menuItem -q -cb gs_mptk_debugMode`, `menuItem -q -cb gs_mptk_debugStep`, 0, 0, 0)";
   menuItem -e -c $debugMode refreshUI;
   menuItem -e -en 0 refreshUI;
   
   //    MAIN FORM    //
   
   string $form = `formLayout mptk_form`;  
   
   // Add Remove Pick //
   
   string $gs_mptk_UI_AddRemovePick = `rowColumnLayout -nc 4 -cw 1 30 -cw 2 30 -cw 3 30 -cw 4 30 gs_mptk_UI_AddRemovePick`;
       string $addTabBtn = `button -l "+" -c gs_mptk_createMixNode`;
       string $removeTabBtn = `button -l "-" -c gs_mptk_deleteMixNode`;
       string $selectTabBtn = `button -l "^" -c gs_mptk_selectMixNode`;
   setParent ..;
   
   
   // Bottom Controls //
   
   string $mptk_UI_bottomControls = `rowColumnLayout -nc 3 mptk_UI_bottomControls`;
       //button -en 0; button; button;
   setParent ..;
   
   // End Bottom Controls //
   
   
   formLayout -edit
   
       //  -attachForm         $gs_mptk_UI_menuBar "top"   5
       //  -attachForm         $gs_mptk_UI_menuBar "left"  5
   
       -attachForm     $gs_mptk_UI_AddRemovePick     "top"    0
       -attachForm     $gs_mptk_UI_AddRemovePick     "left"   0
        
        
       //-attachControl    $column "top"    5    $mptk_UI_tabs
       -attachForm    mptk_UI_bottomControls "bottom" 0
       -attachForm    mptk_UI_bottomControls "left"   0
        
   mptk_form;
                       
           
   gs_mptk_createTabs();

   window -edit -widthHeight 900 525 $gs_mptk_UI;
   showWindow $gs_mptk_UI;
   
   // force update all gs_viewportProj
   string $allViewportProjs[] = `lsType gs_viewportProj`;
   for ($allViewportProj in $allViewportProjs){
      if ($allViewportProj != "<done>") dgdirty $allViewportProj;
   }

}

global proc gs_mptk_createTabs() {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_createTabs\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
   // Tabs //
   
   if (`layout -exists mptk_UI_tabs`) deleteUI mptk_UI_tabs;
   string $mptk_UI_tabs = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5 mptk_UI_tabs`;
   
       gs_mptk_createTabChildren();
        
   setParent mptk_form;
   
   // End Tabs //
   
   formLayout -edit
        
       -attachControl    $mptk_UI_tabs    "top"    0    gs_mptk_UI_AddRemovePick
       -attachForm    $mptk_UI_tabs    "left"    0
       -attachControl    $mptk_UI_tabs    "bottom"    0    mptk_UI_bottomControls
       -attachForm    $mptk_UI_tabs    "right"    0
   
   mptk_form;

}


global proc gs_mptk_createTabChildren(){
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_createTabChildren\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

       // swatch image and file paths need to sit outside loops
       string $swatchImage[], $swatchFilePath;
        
       // get all gs_projCamMix nodes and add their names to tabs
       string $mptk_allProjCamMix[] = `ls -type gs_projCamMix`;
       
       // set file filtering for UI
       if ($mptk_allProjCamMix[0] != "") {
           // find first file
           string $allIncoming[], $files[];
           string $oldList[];
           clear $allIncoming;
           clear $files;
           clear $oldList;
           $allIncoming[0] = $mptk_allProjCamMix[0] ;
           $allIncoming = `listConnections -s on -d off $allIncoming`;
           while (`size $allIncoming`){
               for ($n=0; $n<`size $allIncoming`; $n++){
                   if (`nodeType $allIncoming[$n]` == "file") {
                       $files[`size $files`] = $allIncoming[$n];
                       break;
                   }
               }
               appendStringArray($oldList, $allIncoming, `size $allIncoming`);
               $oldList = stringArrayRemoveDuplicates($oldList);
               $allIncoming = `listConnections -s on -d off $allIncoming`;
               $allIncoming = stringArrayRemoveDuplicates($allIncoming);
               $allIncoming = stringArrayRemove($oldList, $allIncoming);
           }
           if ($files[0] != "") {
               int $filterTypeIndex = `getAttr ($files[0]+".filterType")`;
               string $chosen;
               //int $elliptical;
               if ($filterTypeIndex == 0) $chosen = "Off";
               if ($filterTypeIndex == 1) $chosen = "Mipmap";
               if ($filterTypeIndex == 2) $chosen = "Box";
               if ($filterTypeIndex == 3) $chosen = "Quadratic";
               if ($filterTypeIndex == 4) $chosen = "Quartic";
               if ($filterTypeIndex == 5) $chosen = "Gaussian";
               /*if ($filterTypeIndex == 1) {
                   if (`getAttr ($files[0]+".miUseEllipticalFilter")` == 1) $chosen = "Elliptical";
               }*/
               menuItem -e -cb 1 ("gs_mptk_fileFiltering_"+$chosen);
           }
       }

        // set vray rendering on or off
        string $gs_vrayNodes[] = `lsType gs_occlusionMatteVRay`;
        if (`size $gs_vrayNodes` > 1) menuItem -e -cb 1 gs_mptk_vrayRender;
        
       // remove from the list those that already have layouts
       string $allTabs[] = `tabLayout -q -tabLabel mptk_UI_tabs`;
       string $additionsToLayout[] = stringArrayRemoveExact($allTabs, $mptk_allProjCamMix);
       int $startIndex = `size $mptk_allProjCamMix` - `size $additionsToLayout`;
        
       //print $additionsToLayout;
        
       for ($x=$startIndex; $x<`size $mptk_allProjCamMix`; $x++){
           
       
        
       string $newTab = `paneLayout -cn "vertical3" -p mptk_UI_tabs -ps 1 30 0 -ps 2 50 80 -ps 3 20 0 ("mptk_UI_tabs_child_" + $x)`;
       tabLayout -edit -tabLabel $newTab $mptk_allProjCamMix[$x] -cc gs_mptk_tabChanged mptk_UI_tabs;
   
       // get list of projections connected to current gs_projCamMix shader
       
       // projection scroll list | Pane 1
       
       string $mptk_UI_projListLayout = `formLayout`;
           string $mptk_UI_projListText = `text -fn "boldLabelFont" -l "Projection List"`;
           string $mptk_UI_separator = `separator -style out`;
       
           string $gs_mptk_UI_AddRemovePick = `rowColumnLayout -nc 3 -cw 1 30 -cw 2 30 -cw 3 30`;
           string $addProjCmd = "gs_mptk_addProj " + $mptk_allProjCamMix[$x];
           string $addProjBtn = `button -l "+" -c $addProjCmd addProjBtn`;
           string $removeProjBtn = `button -l "-" -c gs_mptk_removeProj removeProjBtn`;
           string $selectProjBtn = `button -l "^" -c gs_mptk_selectProjNode selectProjBtn`;
           setParent ..;
       
           string $mptk_UI_projList = `scrollLayout -cr 1 -horizontalScrollBarThickness 16 -verticalScrollBarThickness 16 ("gs_mptk_projScrollLayout"+$x)`;
                
               string $gs_mptk_projListLayout = `columnLayout -adj 1 ("gs_mptk_projListLayout"+$x)`;
                
               gs_mptk_build_projList($mptk_allProjCamMix[$x], ("gs_mptk_projListLayout"+$x), $x);
                  
               setParent ("gs_mptk_projScrollLayout"+$x);
                
            
           setParent ..;
            
       setParent ..;
       
       formLayout -edit
           -attachForm $mptk_UI_projListText "left" 0
           -attachForm $mptk_UI_separator "left" 0
           -attachForm $mptk_UI_separator "right" 0
           -attachControl $mptk_UI_separator "top" 0 $mptk_UI_projListText
           -attachControl $gs_mptk_UI_AddRemovePick "top" 1 $mptk_UI_separator
           -attachControl $mptk_UI_projList "top" 2 $gs_mptk_UI_AddRemovePick
           -attachForm $mptk_UI_projList "left" 0
           -attachForm $mptk_UI_projList "right" 0
           -attachForm $mptk_UI_projList "bottom" 0
       $mptk_UI_projListLayout;
       
       /////////////////////////////  PROJECTION ATTRS UI ////////////////////////////////////////////////////////////////////////////////////////////////////////
            
           string $mptk_UI_projAttrsLayout = `formLayout gs_mptk_projAttrsUI`;
           string $tx1 = `text -fn "boldLabelFont" -l "Projection Attributes"`;
           string $separator = `separator -style out`;
           string $scrollProjAttrs = `scrollLayout -cr 1 -horizontalScrollBarThickness 16 -verticalScrollBarThickness 16 ("gs_mptk_scrollProjAttrsLayout"+$x)`;
               string $mptk_UI_projAttrsLayout2 = `formLayout`;
                
               int $indexNameMapping = gs_indexToNameMapping($mptk_allProjCamMix[$x], 0);
               string $tx2 = `text -l "Camera"`;
               int $mptk_numProjections = gs_projCamMix_query_num($mptk_allProjCamMix[$x]);
               string $mptk_assignCameraCmd = "gs_mptk_assignCamera " + $mptk_numProjections + " " + $x;
               string $btn1 = `button -w 30 -l "+" -c $mptk_assignCameraCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsAssignCameraBtn")`;
               string $mptk_selectCameraCmd = "gs_mptk_selectCamera `button -q -l mptk_UI_tabs_child_" + $x + "_mptk_projAttrsCameraBtn`";
               string $btn2 = `button -c $mptk_selectCameraCmd -l "None" (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsCameraBtn")`;
               string $attrControl0 =  `attrColorSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].colorOffset") (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsColorOffset")`;
               string $attrControlPassthrough =  `attrControlGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].passThrough") (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsPassThrough")`;
                   /*  rowColumnLayout -numberOfColumns 2 -cal 1 "left";
                       checkBox -l "Use Proxy";
                       checkBox -l "Render Proxy";
                   setParent ..;
                   rowColumnLayout -numberOfColumns 2 -cat 1 "both" 0 -cal 1 "left" -cw 2 30;
                       textField;
                       button -l "...";
                   setParent ..;  */
                   string $separator1 = `separator -style out`;
               string $tx3 = `text -l "Matte Attributes"`;
               string $attrControl1 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].distanceThreshold") -cc gs_mptk_changeDistanceThreshold (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsDistanceThreshold")`;
               string $attrControl2 =  `attrControlGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].useShadowOcclusion") -cc gs_mptk_enableShadowOcclusion (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsUseShadowOcclusion")`;
               string $attrControl3 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].dilate") -cc gs_mptk_changeDilate (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsDilate")`;
               string $attrControl4 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].samples") -cc gs_mptk_changeSamples (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSamples")`;
               string $attrControl5 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].softEdge") -cc gs_mptk_changeSoftEdge (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSoftEdge")`;
               string $attrControl6 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].power") -cc gs_mptk_changePower (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsPower")`;
               string $attrControl7 =    `attrControlGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].useFacingRatio") -cc gs_mptk_enableFacingRatio (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsUseFacingRatio")`;
               string $attrControl8 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].angleThreshold") -cc gs_mptk_changeAngleThreshold (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsAngleThreshold")`;
               string $attrControl9 =  `attrFieldSliderGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].labelExclude") -cc gs_mptk_changeLabelExclude (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsLabelExclude")`;
               string $attrControl10 =  `attrControlGrp -attribute ($mptk_allProjCamMix[$x]+".images["+$indexNameMapping+"].premult") -cc gs_mptk_changePremult (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsPremult")`;
               
               string $separator2 = `separator -style out`;
               string $tx4 = `text -l "Additional Mattes"`;
               
               string $gs_mptk_UI_AddRemovePick = `rowColumnLayout -nc 4 -cw 1 30 -cw 2 30 -cw 3 30 -cw 4 30`;
                   string $addMatteCmd = "gs_mptk_addMatte " + $mptk_allProjCamMix[$x];
                   string $addTabBtn = `button -l "+" -c $addMatteCmd`;
                   string $deleteMatteCmd = "gs_mptk_deleteMatte " + $mptk_allProjCamMix[$x];
                   string $removeTabBtn = `button -l "-" -c $deleteMatteCmd`;
               setParent ..;
                    
               setParent ..;
                
           
                
               // start matte list //
                
               string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 ("gs_mptk_additionalMattesLayout"+$x)`;
                
               gs_mptk_build_additionalMattes($mptk_allProjCamMix[$x], ("gs_mptk_additionalMattesLayout"+$x), $x);
                
               setParent ("gs_mptk_scrollProjAttrsLayout"+$x);
                
                
                
                    
            
               formLayout -edit
               -attachForm $tx2 "left" 0
               
               -attachForm $btn1 "left" 0
               -attachControl $btn1 "top" 0 $tx2
               
               -attachForm $btn2 "right" 0
               -attachControl $btn2 "left" 0 $btn1
               -attachControl $btn2 "top" 0 $tx2
               
               -attachForm $attrControl0 "left" 0
               -attachControl $attrControl0 "top" 0 $btn2
               
               -attachForm $attrControlPassthrough "left" 0
               -attachControl $attrControlPassthrough "top" 0 $attrControl0
               
               -attachForm $separator1 "left" 0
               -attachForm $separator1 "right" 0
               -attachControl $separator1 "top" 2 $attrControlPassthrough
               
               -attachForm $tx3 "left" 0
               -attachControl $tx3 "top" 0 $separator1
               
               -attachForm $attrControl1 "left" 0
               -attachControl $attrControl1 "top" 0 $tx3
               
               -attachForm $attrControl2 "left" 0
               -attachControl $attrControl2 "top" 0 $attrControl1
               
               -attachForm $attrControl3 "left" 0
               -attachControl $attrControl3 "top" 0 $attrControl2
               
               -attachForm $attrControl4 "left" 0
               -attachControl $attrControl4 "top" 0 $attrControl3
               
               -attachForm $attrControl5 "left" 0
               -attachControl $attrControl5 "top" 0 $attrControl4
               
               -attachForm $attrControl6 "left" 0
               -attachControl $attrControl6 "top" 0 $attrControl5
               
               -attachForm $attrControl7 "left" 0
               -attachControl $attrControl7 "top" 0 $attrControl6
               
               -attachForm $attrControl8 "left" 0
               -attachControl $attrControl8 "top" 0 $attrControl7
               
               -attachForm $attrControl9 "left" 0
               -attachControl $attrControl9 "top" 0 $attrControl8
               
               -attachForm $attrControl10 "left" 0
               -attachControl $attrControl10 "top" 0 $attrControl9

               -attachForm $separator2 "left" 0
               -attachForm $separator2 "right" 0
               -attachControl $separator2 "top" 2 $attrControl10
               
               -attachForm $tx4 "left" 0
               -attachControl $tx4 "top" 0 $separator2
               
               -attachForm $gs_mptk_UI_AddRemovePick "left" 0
               -attachControl $gs_mptk_UI_AddRemovePick "top" 0 $tx4
               
               
               $mptk_UI_projAttrsLayout2;
            
                    
               
           setParent ..;
           setParent ..;
            
            
            
           formLayout -edit
           -attachForm $tx1 "left" 0
           -attachControl $separator "top" 0 $tx1
           -attachForm $separator "left" 0
           -attachForm $separator "right" 0
           
           -attachForm $scrollProjAttrs "left" 0
           -attachForm $scrollProjAttrs "right" 0
           -attachForm $scrollProjAttrs "bottom" 0
           -attachControl $scrollProjAttrs "top" 0 $separator
           $mptk_UI_projAttrsLayout;
            
            
       /////////////////////////////  OBJECT LIST UI ////////////////////////////////////////////////////////////////////////////////////////////////////////
            
        string $mptk_UI_objListUI = `formLayout gs_mptk_objListUI`;
           string $tx1 = `text -fn "boldLabelFont" -l "Object List"`;
           string $separator = `separator -style out`;
                
               string $gs_mptk_UI_AddRemovePick = `rowColumnLayout -nc 3 -cw 1 30 -cw 2 30 -cw 3 30`;
               string $addGeoCmd = "mptk_addGeo " + $mptk_allProjCamMix[$x];
                       string $b1 = `button -l "+" -c $addGeoCmd`;
               string $removeGeoCmd = "mptk_removeGeo `textScrollList -q -si mptk_UI_tabs_child_" + $x + "_mptk_objList`";
                       string $b1a = `button -l "-" -c $removeGeoCmd`;
               string $selectGeoCmd = "select `textScrollList -q -si mptk_UI_tabs_child_" + $x + "_mptk_objList`";
                       string $b1b = `button -l "^" -c $selectGeoCmd`;
                   setParent ..;
                   
                   string $gs_mptk_UI_objTextScrollList = `textScrollList -ams 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_objList")`;
               string $geoListItems[] = `mptk_assignedGeo $mptk_allProjCamMix[$x]`;

               for ($geoListItem in $geoListItems){
                   textScrollList -e -append $geoListItem (("mptk_UI_tabs_child_" + $x)+"_mptk_objList");
               }
            
           formLayout -edit
               -attachForm $tx1 "left" 0
               -attachControl $separator "top" 0 $tx1
               -attachForm $separator "left" 0
               -attachForm $separator "right" 0
                
               -attachForm $gs_mptk_UI_AddRemovePick "left" 0
               -attachControl $gs_mptk_UI_AddRemovePick "top" 0 $separator
                
               -attachForm $gs_mptk_UI_objTextScrollList "left" 0
               -attachForm $gs_mptk_UI_objTextScrollList "right" 0
               -attachForm $gs_mptk_UI_objTextScrollList "bottom" 0
               -attachControl $gs_mptk_UI_objTextScrollList "top" 0 $gs_mptk_UI_AddRemovePick
           $mptk_UI_objListUI;
           
           setParent ..;
                
       setParent ..;
       
       }


       // The following is deprecated since gs_mptk_viewportSetup now handles the creation of gs_const and shading engine

       /*
       /////////////////////////////  SET OPTIONS MENU ////////////////////////////////////////////////////////////////////////////////////////////////////////

        // viewport proj attrs
        string $gs_projCamMix = $mptk_allProjCamMix[0];
        if ($gs_projCamMix != "") {
           int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMix);
           string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
           string $shadingEngine, $surfaceShader, $src[];
           if ($allObjs[0] != "") {
             string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
             string $currentShaders[], $allShaders[];
             clear $allShaders;
             for ($x=0; $x<`size $allDescendents`; $x++){
               $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
               $allShaders = stringArrayCatenate($allShaders, $currentShaders);
               $allShaders = stringArrayRemoveDuplicates($allShaders);
             }
             $shadingEngine = $allShaders[0];
           }
           if ($shadingEngine == "") // if no geo or assigned shading engine
           {
             // find all shading engines assigned to gs_projCamMix
             string $shadEngine[];
             clear $src;
             $src[0] = $gs_projCamMix;
             while (`size $src`) {
                //step through chain
                $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
                if (`size $shadEngine`) break;
                $src = `listConnections -s off -d on -scn 1 $src`;
             }
             $shadingEngine = $shadEngine[0];
           }
           if ($shadingEngine == "") // if still no assigned shading engine, create one
           {
             $shadingEngine = `sets -renderable true -noSurfaceShader true -empty -name gs_mptkSG`;
           }
           // now get surfaceShader assigned to shading engine
           clear $src;
           $src = `listConnections -s on -d off -p 1 ($shadingEngine+".miMaterialShader")`;
           if (!`size $src`) // if no connection to .miMaterialShader, create gs_const and connect
           {
           print "No surface shader found. Creating gs_const and connecting.\n";
                 $surfaceShader = `shadingNode -asShader gs_const`;
           //connectAttr -f ($surfaceShader+".outValue") ($shadingEngine+".miMaterialShader");
           connectAttr -f ($gs_projCamMix+".outColor") ($surfaceShader+".color");
           if (`nodeType $surfaceShader` == "gs_const") connectAttr -f ($gs_projCamMix+".outAlpha") ($surfaceShader+".opacity");
           //if (`nodeType $surfaceShader` == "gs_const") setAttr ($surfaceShader+".custom_alpha") 1;
           $surfaceShader = ($surfaceShader+".outValue"); // include plug
             
           }else{
              $surfaceShader = $src[0];
           }
           // now work on viewport shader
           string $viewportProj[] = `listConnections -s on -d off -t gs_viewportProj $shadingEngine`;
           if (`size $viewportProj`) {
             int $doLayering = `getAttr ($viewportProj[0]+".layeredTexture")`;
             int $cc = `getAttr ($viewportProj[0]+".viewportLinToVid")`;
             menuItem -e -cb $cc gs_mptk_viewport;
             menuItem -e -cb $doLayering gs_mptk_layered;
           }
        }
        */
}



global proc gs_mptk_build_projList(string $gs_projCamMixNode, string $scrollProjList, int $x){
   
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_build_projList\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

       // start proj cam list //
        
       string $mptk_projListItem;
       string $mptk_launchImageEdit, $mptk_imageFilePath;
        
       // get number of projections from gs_projCamMix
        
       int $mptk_numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
       if ($mptk_numProjections == 0) $mptk_numProjections = 1; // there must be at least 1 input
        
       for ($mptk_numProj = 0; $mptk_numProj < $mptk_numProjections; $mptk_numProj++){
            
           $mptk_projListItem = ("mptk_projListItem_" + $mptk_numProj);
           string $mptk_UI_projListItem = `formLayout -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback $mptk_projListItem`;
            
               // setup all vars
               string $mptk_current_color_proj[], $mptk_swatchDisplay, $mptk_UI_swatch, $mptk_separator_bottom, $mptk_UI_projColumn, $mptk_renameProjNodeCmd, $mptk_projNodeEnterCmd, $mptk_UI_projName, $mptk_UI_path, $mptk_UI_pathBtn, $mptk_loadAttrsCmd, $mptk_UI_loadAttrsBtn;
            
               // get projection name
               int $indexNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $mptk_numProj);
               
               $mptk_current_color_proj = `listConnections ($gs_projCamMixNode+".images["+$indexNameMapping+"].color")`; // get input connection
                
               $mptk_UI_swatch = `swatchDisplayPort`;
                
               string $swatchFilePath;
                
                
               if ($mptk_current_color_proj[0] != "") { // if there's a connection, and not just a color
                
                   if (`nodeType $mptk_current_color_proj[0]` == "projection") { // for projections

                       // find attached file and setup swatch
                       string $swatchImage[] = `listConnections -t file $mptk_current_color_proj[0]`;
                       string $swatchFilePath;
                       if ($swatchImage[0] != "") {
                              $swatchFilePath = `getAttr ($swatchImage[0]+".fileTextureName")`;
                       } else {
                           $swatchImage = `listConnections -t ramp $mptk_current_color_proj[0]`;
                           if ($swatchImage[0] != "") {
                                  $swatchFilePath = $swatchImage[0];
                           } else {
                               $swatchImage = `listConnections $mptk_current_color_proj[0]`;
                                  $swatchFilePath = "";
                                  warning ("Unknown incoming connection type on input " + $mptk_numProj + " of projection " +$x);
                           }
               }
                       $mptk_launchImageEdit = ("launchImageEditor -eif `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_projPath"+$mptk_numProj+"`");
                       string $mptk_swatchDisplay = (("mptk_UI_tabs_child_" + $x)+"_mptk_swatchDisplay"+$mptk_numProj);
                       $mptk_UI_swatch = `swatchDisplayPort -bgc .2 .2 .2 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -rs 64 -sn $swatchImage[0] $mptk_swatchDisplay`;
                       swatchDisplayPort -e -pc $mptk_launchImageEdit $mptk_swatchDisplay;
                        
                        
                       $mptk_UI_projColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBkgnd"+$mptk_numProj)`;

                       $mptk_UI_projColumn1 = `columnLayout -rs 0 -adj 1`;
                           $mptk_renameProjNodeCmd = "gs_mptk_renameProjNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_swatchDisplay" + $mptk_numProj+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_projName"+$mptk_numProj+" projection";
                           $mptk_projNodeEnterCmd = "gs_mptk_enterOnProjText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "`";
                           $mptk_UI_projName = `textField -h 21 -fn "boldLabelFont" -text $mptk_current_color_proj[0] -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -cc $mptk_renameProjNodeCmd -ec $mptk_projNodeEnterCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$mptk_numProj)`;
                            
                            
                           string $updateFilePathProcProj = "gs_mptk_filePathUpdated( \"proj\", " + $mptk_numProj + " )";

                           $mptk_UI_path = `textField -h 21 -tx $swatchFilePath -cc $updateFilePathProcProj -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_projPath"+$mptk_numProj)`;
                        setParent ..;   

                      $mptk_UI_projColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_imageFilePathLoadProc = ("gs_mptk_loadImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName"+$mptk_numProj + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_projPath"+$mptk_numProj+"` mptk_UI_tabs_child_" + $x +"_mptk_projPath"+$mptk_numProj+" projection " + $indexNameMapping + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_pathBtn = `button -w 30 -h 21 -label "..." -c $mptk_imageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadDialogBtn"+$mptk_numProj)`;
                           //text -l "" textNull2; // null text for column space
                           $mptk_loadAttrsCmd = "gs_mptk_loadProjAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName" + $mptk_numProj + "` " + $mptk_numProjections + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_loadAttrsBtn = `button -w 30 -h 25 -label ">" -c $mptk_loadAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBtn"+$mptk_numProj)`;
                       setParent ..;

                    setParent ..;

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_projColumn1     "top"    0
                      -attachForm     $mptk_UI_projColumn1     "left"   1
                      -attachForm     $mptk_UI_projColumn1     "bottom"   0
                      -attachControl  $mptk_UI_projColumn1 "right" 1 $mptk_UI_projColumn2
                      -attachForm  $mptk_UI_projColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_projColumn;

                        
                   }
                    
                   if (`nodeType $mptk_current_color_proj[0]` == "file") { // for files
                        
                       $swatchFilePath = `getAttr ($mptk_current_color_proj[0]+".fileTextureName")`;
                        
                       $mptk_launchImageEdit = ("launchImageEditor -eif `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_projPath"+$mptk_numProj+"`");
                       $mptk_swatchDisplay = (("mptk_UI_tabs_child_" + $x)+"_mptk_swatchDisplay"+$mptk_numProj);
                        
                       $mptk_UI_swatch = `swatchDisplayPort -bgc .2 .2 .2 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -rs 64 -sn $mptk_current_color_proj[0] $mptk_swatchDisplay`;
                        
                       swatchDisplayPort -e -pc $mptk_launchImageEdit $mptk_swatchDisplay;
                             
                       $mptk_UI_projColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBkgnd"+$mptk_numProj)`;

                       $mptk_UI_projColumn1 = `columnLayout -rs 0 -adj 1`;
                           
                           $mptk_renameProjNodeCmd = "gs_mptk_renameProjNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_swatchDisplay" + $mptk_numProj+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_projName"+$mptk_numProj+" file";
                           $mptk_projNodeEnterCmd = "gs_mptk_enterOnProjText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "`";
                           $mptk_UI_projName = `textField -fn "boldLabelFont" -text $mptk_current_color_proj[0] -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -cc $mptk_renameProjNodeCmd -ec $mptk_projNodeEnterCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$mptk_numProj)`;
                            
                            
                           string $updateFilePathProcFile = "gs_mptk_filePathUpdated( \"file\", " + $mptk_numProj + " )";
                           $mptk_UI_path = `textField -tx $swatchFilePath -cc $updateFilePathProcFile -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_projPath"+$mptk_numProj)`;
                           setParent ..;   

                      $mptk_UI_projColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_imageFilePathLoadProc = ("gs_mptk_loadImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName"+$mptk_numProj + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_projPath"+$mptk_numProj+"` mptk_UI_tabs_child_" + $x +"_mptk_projPath"+$mptk_numProj+" file " + $indexNameMapping + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_pathBtn = `button -label "..." -c $mptk_imageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadDialogBtn"+$mptk_numProj)`;
                           text -l "" textNull2; // null text for column space
                           $mptk_loadAttrsCmd = "gs_mptk_loadProjAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName" + $mptk_numProj + "` " + $mptk_numProjections + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_loadAttrsBtn = `button -label ">" -c $mptk_loadAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBtn"+$mptk_numProj)`;

                       setParent ..;

                    setParent ..;

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_projColumn1     "top"    0
                      -attachForm     $mptk_UI_projColumn1     "left"   1
                      -attachForm     $mptk_UI_projColumn1     "bottom"   0
                      -attachControl  $mptk_UI_projColumn1 "right" 1 $mptk_UI_projColumn2
                      -attachForm  $mptk_UI_projColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_projColumn;
                        
                   }              
               } else {
                   $mptk_swatchDisplay = (("mptk_UI_tabs_child_" + $x)+"_mptk_swatchDisplay"+$mptk_numProj);
                    
                   float $returnColorR = `getAttr ($gs_projCamMixNode+".images["+$indexNameMapping+"].colorR")`;
                   float $returnColorG = `getAttr ($gs_projCamMixNode+".images["+$indexNameMapping+"].colorG")`;
                   float $returnColorB = `getAttr ($gs_projCamMixNode+".images["+$indexNameMapping+"].colorB")`;
                   string $gs_mptk_solidColorPickerCmd = "gs_mptk_solidColorPicker " + $gs_projCamMixNode + " " + $mptk_swatchDisplay + " " + $indexNameMapping;
                    
                   $mptk_UI_swatch = `swatchDisplayPort -bgc 1 1 1 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -sn $gs_projCamMixNode $mptk_swatchDisplay`;
                        

                       $mptk_UI_projColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBkgnd"+$mptk_numProj)`;

                       $mptk_UI_projColumn1 = `columnLayout -rs 0 -adj 1`;
                           
                            $mptk_renameProjNodeCmd = "gs_mptk_renameProjNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_swatchDisplay" + $mptk_numProj+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_projName"+$mptk_numProj+" color";
                            $mptk_projNodeEnterCmd = "gs_mptk_enterOnProjText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_projName" + $mptk_numProj + "`";
                            $mptk_UI_projName = `textField -fn "boldLabelFont" -text "No Projection" -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$mptk_numProj)`;
                            
                            
                            $mptk_UI_path = `textField -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_projPath"+$mptk_numProj)`;                           setParent ..;   

                      $mptk_UI_projColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_imageFilePathLoadProc = ("gs_mptk_loadImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName"+$mptk_numProj + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_projPath"+$mptk_numProj+"` mptk_UI_tabs_child_" + $x +"_mptk_projPath"+$mptk_numProj+" color " + $indexNameMapping + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_pathBtn = `button -label "..." -c $mptk_imageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadDialogBtn"+$mptk_numProj)`;
                           text -l "" textNull21; // null text for column space
                           $mptk_loadAttrsCmd = "gs_mptk_loadProjAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_projName" + $mptk_numProj + "` " + $mptk_numProjections + " " + $x + " " + $mptk_numProj;
                           $mptk_UI_loadAttrsBtn = `button -label ">" -c $mptk_loadAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsBtn"+$mptk_numProj)`;

                       setParent ..;

                    setParent ..;

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_projColumn1     "top"    0
                      -attachForm     $mptk_UI_projColumn1     "left"   1
                      -attachForm     $mptk_UI_projColumn1     "bottom"   0
                      -attachControl  $mptk_UI_projColumn1 "right" 1 $mptk_UI_projColumn2
                      -attachForm  $mptk_UI_projColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_projColumn;


               }
                
               $mptk_separator_bottom = `separator -style out`;
                
               setParent $scrollProjList;
            
               formLayout -edit
                   -attachForm $mptk_UI_swatch "left" 0
                   -attachForm $mptk_UI_swatch "top" 3
                   -attachControl $mptk_UI_projColumn "left" 0 $mptk_UI_swatch
                   -attachForm $mptk_UI_projColumn "right" 0
                   -attachControl $mptk_separator_bottom "top" 5 $mptk_UI_swatch  
                   -attachForm $mptk_separator_bottom "left" 0
                   -attachForm $mptk_separator_bottom "right" 0
               $mptk_UI_projListItem;
                
            
       }
        
       // end proj cam list //

}

global proc gs_mptk_build_additionalMattes(string $gs_projCamMixNode, string $scrollProjAttrs, int $x){
     
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_build_additionalMattes\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
       string $mptk_matteListItem;
       string $mptk_launchMatteImageEdit, $mptk_matteImageFilePath;
        
       // get active projection for gs_projCamMix
       int $mptk_activeProj = gs_mptk_getActiveProjIndex($gs_projCamMixNode);
       int $mptk_numMatte = 0;
       int $mptk_numMattes = 0;
        
       $mptk_matteListItem = "mptk_matteListItem_0";
        
       // setup all vars
       string $mptk_current_matte[], $mptk_swatchDisplayMatte, $mptk_UI_swatchMatte, $mptk_separator_matte_bottom, $mptk_UI_matteColumn, $mptk_renameMatteNodeCmd, $mptk_matteNodeEnterCmd, $mptk_UI_matteName, $mptk_UI_matte_path, $mptk_UI_matte_pathBtn, $mptk_loadMatteAttrsCmd, $mptk_UI_loadMatteAttrsBtn, $swatchImageMatte[], $swatchMatteFilePath;
     
       // get matte name
       int $indexNameMappingMatte = gs_indexToNameMapping($gs_projCamMixNode, $mptk_activeProj);
       $mptk_current_matte = `listConnections ($gs_projCamMixNode+".images["+$indexNameMappingMatte+"].mask")`; // get input connection
        
       $mptk_UI_swatchMatte = `swatchDisplayPort`;
        
        
       if ($mptk_current_matte[0] != "") { // if there's a connection, and not just a color
        
        
           if (`nodeType $mptk_current_matte[0]` == "multiplyDivide") { // for mult/div
               
               
               
               string $allIncoming[], $files[];
               string $oldList[];
               clear $allIncoming;
               clear $files;
               clear $oldList;
               $allIncoming[0] = $mptk_current_matte[0];
               $allIncoming = `listConnections -s on -d off $allIncoming`;
               while (`size $allIncoming`){
                   // preserve cameras
                   for ($n=0; $n<`size $allIncoming`; $n++){
                       if (`nodeType $allIncoming[$n]` == "file" || `nodeType $allIncoming[$n]` == "ramp") {
                           $files[`size $files`] = $allIncoming[$n];
                       }
                   }
                   appendStringArray($oldList, $allIncoming, `size $allIncoming`);
                   $oldList = stringArrayRemoveDuplicates($oldList);
                   $allIncoming = `listConnections -s on -d off $allIncoming`;
                   $allIncoming = stringArrayRemoveDuplicates($allIncoming);
                   $allIncoming = stringArrayRemove($oldList, $allIncoming);
               }
               $files = stringArrayRemoveDuplicates($files);  
               $mptk_numMattes = `size $files`;
                
               for ($file in $files) {
                
                  // first test for outAlpha from file, otherwise files that share proj list and additional mattes get confused with UItextName naming
                   string $projectionNode[] = `listConnections -s off -d on -t projection ($file+".outAlpha")`;
                   if (!`size $projectionNode`) $projectionNode = `listConnections -s off -d on -t projection $file`;

                   string $UItextName = $file;
                   string $rampConnection[];
                   clear $rampConnection;
                   if ($projectionNode[0] != "") {
                      $UItextName = $projectionNode[0];
                      $rampConnection = `listConnections -s on -d off -t ramp ($projectionNode[0]+".image")`;
                    }
                       
                   $mptk_matteListItem = ("mptk_matteListItem_" + $mptk_numMatte);
                   $mptk_UI_matteListItem = `formLayout $mptk_matteListItem`;
                    
                       // find attached file and setup swatch
                       $swatchImageMatte[0] = $file;
                       if (`objectType $swatchImageMatte` == "file") $swatchMatteFilePath = `getAttr ($swatchImageMatte[0]+".fileTextureName")`;
                       $mptk_launchMatteImageEdit = ("launchImageEditor -eif `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"`");
                       $mptk_swatchDisplayMatte = (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numMatte);
                        
                       $mptk_UI_swatchMatte = `swatchDisplayPort -bgc .2 .2 .2 -ebg 1 -wh 64 64 -rs 64 -sn $swatchImageMatte[0] $mptk_swatchDisplayMatte`;
                        
                       swatchDisplayPort -e -pc $mptk_launchMatteImageEdit $mptk_swatchDisplayMatte;

                       $mptk_UI_matteColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBkgnd"+$mptk_numMatte)`;

                       $mptk_UI_matteColumn1 = `columnLayout -rs 0 -adj 1`;
                          
                           $mptk_renameMatteNodeCmd = "gs_mptk_renameMatteNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_matteSwatchDisplay" + $mptk_numMatte+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName"+$mptk_numMatte+" projection";
                           $mptk_matteNodeEnterCmd = "gs_mptk_enterOnMatteText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "`";
                           $mptk_UI_matteName = `textField -fn "boldLabelFont" -text $UItextName -cc $mptk_renameMatteNodeCmd -ec $mptk_matteNodeEnterCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_matteName"+$mptk_numMatte)`;
                            
                           string $updateFilePathProcMatte = "gs_mptk_filePathUpdated( \"matte\", " + $mptk_numMatte + " )";
                           
                           // clear path name for ramps
                           if ($rampConnection[0] != "<done>" && $rampConnection[0] != ""){
                              if (`nodeType $rampConnection[0]` == "ramp") $swatchMatteFilePath = "RAMP";
                           }

                           $mptk_UI_matte_path = `textField -tx $swatchMatteFilePath -cc $updateFilePathProcMatte (("mptk_UI_tabs_child_" + $x)+"_mptk_mattePath"+$mptk_numMatte)`;

                        setParent ..;   

                      $mptk_UI_matteColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_matteImageFilePathLoadProc = ("gs_mptk_loadMatteImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName"+$mptk_numMatte + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"` mptk_UI_tabs_child_" + $x +"_mptk_mattePath"+$mptk_numMatte+" projection " + $indexNameMappingMatte + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numMatte;
                           $mptk_UI_matte_pathBtn = `button -label "..." -c $mptk_matteImageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadMatteDialogBtn"+$mptk_numMatte)`;
                           //text -l "" textNull2; // null text for column space
                           $mptk_loadMatteAttrsCmd = "gs_mptk_loadMatteAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName" + $mptk_numMatte + "` " + $mptk_numMattes + " " + $x + " " + $mptk_numMatte; 
                           $mptk_UI_loadMatteAttrsBtn = `button -label ">" -c $mptk_loadMatteAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBtn"+$mptk_numMatte)`;
                       setParent ..;

                    setParent ..;
              

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_matteColumn1     "top"    0
                      -attachForm     $mptk_UI_matteColumn1     "left"   1
                      -attachForm     $mptk_UI_matteColumn1     "bottom"   0
                      -attachControl  $mptk_UI_matteColumn1 "right" 1 $mptk_UI_matteColumn2
                      -attachForm  $mptk_UI_matteColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_matteColumn;
  
                   $mptk_separator_matte_bottom = `separator -style out`;
                   setParent $scrollProjAttrs;
                    
                    
                   formLayout -edit
                       -attachForm $mptk_UI_swatchMatte "left" 0
                       -attachForm $mptk_UI_swatchMatte "top" 3
                       -attachControl $mptk_UI_matteColumn "left" 0 $mptk_UI_swatchMatte
                       -attachForm $mptk_UI_matteColumn "right" 0
                       -attachControl $mptk_separator_matte_bottom "top" 5 $mptk_UI_swatchMatte  
                       -attachForm $mptk_separator_matte_bottom "left" 0
                       -attachForm $mptk_separator_matte_bottom "right" 0
                   $mptk_UI_matteListItem;
        
                   $mptk_numMatte ++;
               }
                
           }
           if (`nodeType $mptk_current_matte[0]` == "projection") { // for projections

               string $rampConnection[];
               clear $rampConnection;
               if ($mptk_current_matte[0] != "") {
                  //$UItextName = $projectionNode[0];
                  $rampConnection = `listConnections -s on -d off -t ramp ($mptk_current_matte[0]+".image")`;
                }

               string $mptk_UI_matteListItem = `formLayout $mptk_matteListItem`;

                   // find attached file and setup swatch
                   $swatchImageMatte = `listConnections -s on -d off $mptk_current_matte[0]`;
                    
                   //if ($swatchImageMatte[0] == "") error "Found matte node without file texture connected; aborting.";
                   if (`nodeType $swatchImageMatte[0]` == "file") $swatchMatteFilePath = `getAttr ($swatchImageMatte[0]+".fileTextureName")`;
                   $mptk_launchMatteImageEdit = ("launchImageEditor -eif `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"`");
                   $mptk_swatchDisplayMatte = (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numMatte);
                    
                   $mptk_UI_swatchMatte = `swatchDisplayPort -bgc .2 .2 .2 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -rs 64 -sn $swatchImageMatte[0] $mptk_swatchDisplayMatte`;
                    
                   swatchDisplayPort -e -pc $mptk_launchMatteImageEdit $mptk_swatchDisplayMatte;

                   $mptk_UI_matteColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBkgnd"+$mptk_numMatte)`;

                       $mptk_UI_matteColumn1 = `columnLayout -rs 0 -adj 1`;
                          
                           $mptk_renameMatteNodeCmd = "gs_mptk_renameMatteNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_matteSwatchDisplay" + $mptk_numMatte+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName"+$mptk_numMatte+" projection";
                           $mptk_matteNodeEnterCmd = "gs_mptk_enterOnMatteText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "`";
                           $mptk_UI_matteName = `textField -fn "boldLabelFont" -text $mptk_current_matte[0] -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -cc $mptk_renameMatteNodeCmd -ec $mptk_matteNodeEnterCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_matteName"+$mptk_numMatte)`;
                            
                           // clear path name for ramps
                           if ($rampConnection[0] != "<done>" && $rampConnection[0] != ""){
                              if (`nodeType $rampConnection[0]` == "ramp") $swatchMatteFilePath = "RAMP";
                           }

                           string $updateFilePathProcMatteProj = "gs_mptk_filePathUpdated( \"matteProj\", " + $mptk_numMatte + " )";
                   
                           $mptk_UI_matte_path = `textField -tx $swatchMatteFilePath -cc $updateFilePathProcMatteProj -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_mattePath"+$mptk_numMatte)`;
                        setParent ..;   

                      $mptk_UI_matteColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_matteImageFilePathLoadProc = ("gs_mptk_loadMatteImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName"+$mptk_numMatte + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"` mptk_UI_tabs_child_" + $x +"_mptk_mattePath"+$mptk_numMatte+" projection " + $indexNameMappingMatte + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numMatte;
                           $mptk_UI_matte_pathBtn = `button -label "..." -c $mptk_matteImageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadMatteDialogBtn"+$mptk_numMatte)`;
                           //text -l "" textNull2; // null text for column space
                           $mptk_loadMatteAttrsCmd = "gs_mptk_loadMatteAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName" + $mptk_numMatte + "` " + $mptk_numMattes + " " + $x + " " + $mptk_numMatte;
                           $mptk_UI_loadMatteAttrsBtn = `button -label ">" -c $mptk_loadMatteAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBtn"+$mptk_numMatte)`;
                       setParent ..;

                    setParent ..;

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_matteColumn1     "top"    0
                      -attachForm     $mptk_UI_matteColumn1     "left"   1
                      -attachForm     $mptk_UI_matteColumn1     "bottom"   0
                      -attachControl  $mptk_UI_matteColumn1 "right" 1 $mptk_UI_matteColumn2
                      -attachForm  $mptk_UI_matteColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_matteColumn;

               $mptk_separator_matte_bottom = `separator -style out`;
                
               setParent $scrollProjAttrs;
            
               formLayout -edit
                   -attachForm $mptk_UI_swatchMatte "left" 0
                   -attachForm $mptk_UI_swatchMatte "top" 3
                   -attachControl $mptk_UI_matteColumn "left" 0 $mptk_UI_swatchMatte
                   -attachForm $mptk_UI_matteColumn "right" 0
                   -attachControl $mptk_separator_matte_bottom "top" 5 $mptk_UI_swatchMatte  
                   -attachForm $mptk_separator_matte_bottom "left" 0
                   -attachForm $mptk_separator_matte_bottom "right" 0
               $mptk_UI_matteListItem;
                
           }
            
           if (`nodeType $mptk_current_matte[0]` == "file") { // for files
                
               string $mptk_UI_matteListItem = `formLayout $mptk_matteListItem`;
                    
                   $swatchMatteFilePath = `getAttr ($mptk_current_matte[0]+".fileTextureName")`;
                    
                   $mptk_launchMatteImageEdit = ("launchImageEditor -eif `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"`");
                   $mptk_swatchDisplayMatte = (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numMatte);
                    
                   $mptk_UI_swatchMatte = `swatchDisplayPort -bgc .2 .2 .2 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -rs 64 -sn $mptk_current_matte[0] $mptk_swatchDisplayMatte`;
                    
                   swatchDisplayPort -e -pc $mptk_launchMatteImageEdit $mptk_swatchDisplayMatte;


                   $mptk_UI_matteColumn = `formLayout -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBkgnd"+$mptk_numMatte)`;

                       $mptk_UI_matteColumn1 = `columnLayout -rs 0 -adj 1`;
                          
                           $mptk_renameMatteNodeCmd = "gs_mptk_renameMatteNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_matteSwatchDisplay" + $mptk_numMatte+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName"+$mptk_numMatte+" file";
                           string $updateFilePathProcMatteFile = "gs_mptk_filePathUpdated( \"matteFile\", " + $mptk_numMatte + " )";
                           $mptk_UI_matte_path = `textField -tx $swatchMatteFilePath -cc $updateFilePathProcMatteFile -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_mattePath"+$mptk_numMatte)`;
                            
                           string $updateFilePathProcMatteFile = "gs_mptk_filePathUpdated( \"matteFile\", " + $mptk_numMatte + " )";
                           $mptk_UI_matte_path = `textField -tx $swatchMatteFilePath -cc $updateFilePathProcMatteFile -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_mattePath"+$mptk_numMatte)`;
                        setParent ..;   

                      $mptk_UI_matteColumn2 = `columnLayout -rs 0 -adj 1`;
                       
                           text -l "" -h 21 textNull2; // null text for column space
                           $mptk_matteImageFilePathLoadProc = ("gs_mptk_loadMatteImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName"+$mptk_numMatte + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"` mptk_UI_tabs_child_" + $x +"_mptk_mattePath"+$mptk_numMatte+" file " + $indexNameMappingMatte + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numMatte;
                           $mptk_UI_matte_pathBtn = `button -label "..." -c $mptk_matteImageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadMatteDialogBtn"+$mptk_numMatte)`;
                           //text -l "" textNull2; // null text for column space
                           $mptk_loadMatteAttrsCmd = "gs_mptk_loadMatteAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName" + $mptk_numMatte + "` " + $mptk_numMattes + " " + $x + " " + $mptk_numMatte;
                           $mptk_UI_loadMatteAttrsBtn = `button -label ">" -c $mptk_loadMatteAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBtn"+$mptk_numMatte)`;
                      setParent ..;

                    setParent ..;

                                    
                    formLayout -edit
                      
                      -attachForm     $mptk_UI_matteColumn1     "top"    0
                      -attachForm     $mptk_UI_matteColumn1     "left"   1
                      -attachForm     $mptk_UI_matteColumn1     "bottom"   0
                      -attachControl  $mptk_UI_matteColumn1 "right" 1 $mptk_UI_matteColumn2
                      -attachForm  $mptk_UI_matteColumn2 "right" 1
                      //-attachForm  $mptk_UI_projColumn2 "top" 2

                    $mptk_UI_matteColumn;

                    
               $mptk_separator_matte_bottom = `separator -style out`;
                
               setParent $scrollProjAttrs;
            
               formLayout -edit
                   -attachForm $mptk_UI_swatchMatte "left" 0
                   -attachForm $mptk_UI_swatchMatte "top" 3
                   -attachControl $mptk_UI_matteColumn "left" 0 $mptk_UI_swatchMatte
                   -attachForm $mptk_UI_matteColumn "right" 0
                   -attachControl $mptk_separator_matte_bottom "top" 5 $mptk_UI_swatchMatte  
                   -attachForm $mptk_separator_matte_bottom "left" 0
                   -attachForm $mptk_separator_matte_bottom "right" 0
               $mptk_UI_matteListItem;
                
           }              
       } else { // for color only
        
           /*string $mptk_UI_matteListItem = `formLayout $mptk_matteListItem`;
               $mptk_swatchDisplayMatte = (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numMatte);
                
               float $returnColorR = `getAttr ($gs_projCamMixNode+".images["+$indexNameMappingMatte+"].colorR")`;
               float $returnColorG = `getAttr ($gs_projCamMixNode+".images["+$indexNameMappingMatte+"].colorG")`;
               float $returnColorB = `getAttr ($gs_projCamMixNode+".images["+$indexNameMappingMatte+"].colorB")`;
               string $gs_mptk_solidColorPickerCmd = "gs_mptk_solidColorPicker " + $gs_projCamMixNode + " " + $mptk_swatchDisplayMatte + " " + $indexNameMappingMatte;
                
               $mptk_UI_swatchMatte = `swatchDisplayPort -bgc 1 1 1 -ebg 1 -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback -wh 64 64 -sn $gs_projCamMixNode $mptk_swatchDisplayMatte`;
                    
               $mptk_UI_matteColumn = `rowColumnLayout -bgc .2 .2 .2 -ebg 1 -numberOfColumns 2 -cat 1 "both" 0 -cw 2 30 -cal 1 "left" -columnSpacing 1 5 (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBkgnd"+$mptk_numMatte)`;
                
                   $mptk_renameMatteNodeCmd = "gs_mptk_renameMatteNode `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "` `swatchDisplayPort -q -sn mptk_UI_tabs_child_" + $x + "_mptk_matteSwatchDisplay" + $mptk_numMatte+"` mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName"+$mptk_numMatte+" color";
                   $mptk_matteNodeEnterCmd = "gs_mptk_enterOnMatteText `textField -q -tx mptk_UI_tabs_child_" + $x + "_mptk_UI_matteName" + $mptk_numMatte + "`";
                   $mptk_UI_matteName = `textField -fn "boldLabelFont" -text "No Matte Input" -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_matteName"+$mptk_numMatte)`;
                    
                   text -l "" textNull1; // null text for column space
                    
                   $mptk_UI_matte_path = `textField -dragCallback mptk_dragCallback -dropCallback mptk_dropCallback (("mptk_UI_tabs_child_" + $x)+"_mptk_mattePath"+$mptk_numMatte)`;
                   $mptk_matteImageFilePathLoadProc = ("gs_mptk_loadMatteImage `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName"+$mptk_numMatte + "` `textField -q -tx mptk_UI_tabs_child_"+$x+"_mptk_mattePath"+$mptk_numMatte+"` mptk_UI_tabs_child_" + $x +"_mptk_mattePath"+$mptk_numMatte+" color " + $indexNameMappingMatte + " " + $gs_projCamMixNode) + " " + $x + " " + $mptk_numMatte;
                   $mptk_UI_matte_pathBtn = `button -label "..." -c $mptk_matteImageFilePathLoadProc (("mptk_UI_tabs_child_" + $x)+"_mptk_loadMatteDialogBtn"+$mptk_numMatte)`;
                   text -l "" textNull2; // null text for column space
                   $mptk_loadMatteAttrsCmd = "gs_mptk_loadMatteAttrs " + $gs_projCamMixNode + " `textField -q -tx mptk_UI_tabs_child_" + $x +"_mptk_UI_matteName" + $mptk_numMatte + "` " + $mptk_numMattes + " " + $x + " " + $mptk_numMatte;
                        
                   $mptk_UI_loadMatteAttrsBtn = `button -label ">" -c $mptk_loadMatteAttrsCmd (("mptk_UI_tabs_child_" + $x)+"_mptk_matteAttrsBtn"+$mptk_numMatte)`;
                
               setParent ..;
                      
               $mptk_separator_matte_bottom = `separator -style out`;
                
               setParent ..;
            
               formLayout -edit
                   -attachForm $mptk_UI_swatchMatte "left" 0
                   -attachForm $mptk_UI_swatchMatte "top" 3
                   -attachControl $mptk_UI_matteColumn "left" 0 $mptk_UI_swatchMatte
                   -attachForm $mptk_UI_matteColumn "right" 0
                   -attachControl $mptk_separator_matte_bottom "top" 5 $mptk_UI_swatchMatte  
                   -attachForm $mptk_separator_matte_bottom "left" 0
                   -attachForm $mptk_separator_matte_bottom "right" 0
               $mptk_UI_matteListItem;*/
       }
        
        
       // end matte list //  
     
}

//////////////////////////////////////////////////////////////////////////////////////////  END UI  //////////////////////////////////////////////////////////////////////////////////////////////


global proc gs_mptk_createMixNode () {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_createMixNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
   string $gs_projCamMixNode = `mrCreateCustomNode -asTexture "" gs_projCamMix`;
    gs_mptk_addProjNetwork( $gs_projCamMixNode, "", 1, 0, 0 );
    // refresh window
    gs_mptk_createTabChildren();
     
    int $tabNumber = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
    int $numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
    string $projectionNode = gs_mptk_getActiveProjNode();
    int $activeIndex = `gs_mptk_getActiveProjIndex $gs_projCamMixNode`;
    gs_mptk_loadProjAttrs $gs_projCamMixNode $projectionNode $numProjections $tabNumber $activeIndex;
     
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_deleteMixNode () {
   
  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_deleteMixNode\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
        

   // if there are no mix nodes found, don't try to delete anything
  int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
  if ($mptk_tabIndex == 0) error "Nothing to remove.";
   
  string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
     
  string $confirmDelete = `confirmDialog -title "Confirm Delete" -message ("This will remove the current projection group " + $mptk_activeTabLabel + " and all of its shading connections.") -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;

    if ($confirmDelete == "Ok"){

       // delete vray network first
       if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayDeleteCurrent();

       string $allIncoming[], $deleteList[], $cameras[], $saveConnections[], $deleteGSTypes[], $deleteGSShapeTypes[];
       string $oldList[];
       clear $allIncoming;
       clear $deleteList;
       clear $cameras;
       clear $oldList;
       clear $deleteGSTypes;
       clear $deleteGSShapeTypes;
       $deleteList[0] = "";
       $allIncoming[0] = $mptk_activeTabLabel;
       $allIncoming = `listConnections -s on -d off $allIncoming`;
       while (`size $allIncoming`){
           // preserve cameras
           for ($x=0; $x<`size $allIncoming`; $x++){
               if (`nodeType $allIncoming[$x]` == "transform") {

                   // make sure not to delete animation on camera, or other user data connections unrelated to the toolkit
                   $saveConnections = `listConnections $allIncoming[$x]`;
                   $deleteGSTypes = `listConnections -t "gs_viewportProj" $allIncoming[$x]`;
                   $saveConnections = stringArrayRemove($deleteGSTypes, $saveConnections);
                   $deleteGSTypes = `listConnections -t "gs_projCamMix" $allIncoming[$x]`;
                   $saveConnections = stringArrayRemove($deleteGSTypes, $saveConnections);
                   $deleteGSTypes = `listConnections -t "projection" $allIncoming[$x]`;
                   $saveConnections = stringArrayRemove($deleteGSTypes, $saveConnections);
                   $deleteGSTypes = `listConnections -t "gs_const" $allIncoming[$x]`;
                   $saveConnections = stringArrayRemove($deleteGSTypes, $saveConnections);

                   string $camShape[] = `listRelatives -s $allIncoming[$x]`;

                   if (`nodeType $camShape[0]` == "camera") {
                      $cameras[`size $cameras`] = $allIncoming[$x];
                      $deleteGSShapeTypes = `listConnections -s on -d on -t "projection" $camShape[0]`;
                      appendStringArray($deleteGSTypes, $deleteGSShapeTypes, `size $deleteGSShapeTypes`);
                      $deleteGSShapeTypes = `listConnections -s on -d on -t "gs_const" $camShape[0]`;
                      appendStringArray($deleteGSTypes, $deleteGSShapeTypes, `size $deleteGSShapeTypes`);
                   }
               }
           }
           appendStringArray($oldList, $allIncoming, `size $allIncoming`);
           $oldList = stringArrayRemove($saveConnections, $oldList);
           appendStringArray($oldList, $deleteGSTypes, `size $deleteGSTypes`);
           $oldList = stringArrayRemoveDuplicates($oldList);
           $allIncoming = `listConnections -s on -d off $allIncoming`;
           $allIncoming = stringArrayRemoveDuplicates($allIncoming);
           $allIncoming = stringArrayRemove($oldList, $allIncoming);
       }
       
       // now delete viewportProj and gs_const
           int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($mptk_activeTabLabel);
     string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
     string $shadingEngine, $surfaceShader, $src[];
     if ($allObjs[0] != "") {
       string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
       string $currentShaders[], $allShaders[];
       clear $allShaders;
       for ($x=0; $x<`size $allDescendents`; $x++){
         $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
         $allShaders = stringArrayCatenate($allShaders, $currentShaders);
         $allShaders = stringArrayRemoveDuplicates($allShaders);
       }
       $shadingEngine = $allShaders[0];
     }
     if ($shadingEngine == "") // if no geo or assigned shading engine
     {
       // find all shading engines assigned to gs_projCamMix
       string $shadEngine[];
       clear $src;
       $src[0] = $mptk_activeTabLabel;
       while (`size $src`) {
          //step through chain
          $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
          if (`size $shadEngine`) break;
          $src = `listConnections -s off -d on -scn 1 $src`;
       }
       $shadingEngine = $shadEngine[0];
     }
     if ($shadingEngine != "")
     {
       string $viewportProj[] = `listConnections -s on -d off ($shadingEngine+".miMaterialShader")`;
       string $surfaceShader[] = `listConnections -s on -d off ($shadingEngine+".surfaceShader")`;
       
       if (`size $viewportProj`) delete $viewportProj[0];
       if (`size $surfaceShader`) delete $surfaceShader[0];
       delete $shadingEngine;
       
     }
       $cameras = stringArrayRemoveDuplicates($cameras);  
       $deleteList = stringArrayRemove($cameras, $oldList);
       $deleteList[0] = $mptk_activeTabLabel;


       // make sure to get rid of all gs_const and projections
       $src[0] = $mptk_activeTabLabel;
       $deleteGSTypes = `listConnections -t "gs_const" $src[0]`;
       appendStringArray($deleteList, $deleteGSTypes, `size $deleteGSTypes`);
       $deleteGSTypes = `listConnections -t "projection" $src[0]`;
       appendStringArray($deleteList, $deleteGSTypes, `size $deleteGSTypes`);

       $deleteList = stringArrayRemoveDuplicates($deleteList);
       
       catchQuiet (`delete $deleteList`);

       // need to delete and recreate manually using -p flag instead of calling gs_mptk_createTabs
       deleteUI mptk_UI_tabs;
       string $mptk_UI_tabs = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5 -p mptk_form mptk_UI_tabs`;
       gs_mptk_createTabChildren();
       
       formLayout -edit
        
           -attachControl    $mptk_UI_tabs    "top"    0    gs_mptk_UI_AddRemovePick
           -attachForm    $mptk_UI_tabs    "left"    0
           -attachControl    $mptk_UI_tabs    "bottom"    0    mptk_UI_bottomControls
           -attachForm    $mptk_UI_tabs    "right"    0
   
       mptk_form;
       
       // now select the first projection, if there is one
          string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
          if ($gs_projCamMixNode != "") {
           int $mptk_numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
           string $mptk_projNode = `textField -q -tx ("mptk_UI_tabs_child_0_mptk_UI_projName0")`;
           gs_mptk_loadProjAttrs ($gs_projCamMixNode, $mptk_projNode, $mptk_numProjections, 0, 0);
       }
        
    }

    print "gs_mptk: Shader and associated connections successfully deleted.\n";
     
}

global proc string gs_mptk_getActiveMixNode () {
   
   if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getActiveMixNode\n";
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // fancy footwork to get current tab label (gs_projCamMixNode)
    int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
    string $mptk_allTabLabels[] = `tabLayout -q -tabLabel mptk_UI_tabs`;
    string $mptk_activeTabLabel;
    if ($mptk_tabIndex != 0){
       $mptk_activeTabLabel = $mptk_allTabLabels[$mptk_tabIndex - 1];
    } else {
   $mptk_activeTabLabel = "";
    }

    return $mptk_activeTabLabel;
     
}

global proc gs_mptk_selectMixNode () {
   
   if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_selectMixNode\n";
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";


    string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
    select $mptk_activeTabLabel;
}

global proc gs_mptk_addProj (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_addProj\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // setup projection network
    string $projectionNode = gs_mptk_getActiveProjNode();
    int $numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
    int $tabNumber = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
    string $projectionTab = ("mptk_UI_tabs_child_"+$tabNumber);
    int $activeIndex = `gs_mptk_getActiveProjIndex $gs_projCamMixNode`;
    int $freeIndex = gs_mptk_getEmptyIndex ();
   
    gs_mptk_addProjNetwork $gs_projCamMixNode $projectionNode $numProjections $tabNumber $freeIndex;
     
    // refreshUI so load image button commands can be updated for changes from No Projection to projection input
    deleteUI ("gs_mptk_projListLayout"+$tabNumber);
    string $gs_mptk_projListLayout = `columnLayout -p ("gs_mptk_projScrollLayout"+$tabNumber) -adj 1 ("gs_mptk_projListLayout"+$tabNumber)`;
    gs_mptk_build_projList($gs_projCamMixNode, ("gs_mptk_projListLayout"+$tabNumber), $tabNumber);
     
    string $projectionNode = gs_mptk_getActiveProjNode();
  
    //$freeIndex = gs_indexToNameMapping($gs_projCamMixNode, $freeIndex);
    //$activeIndex = gs_indexToNameMapping($gs_projCamMixNode, $activeIndex);
   
    if ($freeIndex != $activeIndex) gs_mptk_reorder($freeIndex, $activeIndex, ($numProjections + 1), $projectionTab, $gs_projCamMixNode);

    gs_mptk_loadProjAttrs $gs_projCamMixNode $projectionNode $numProjections $tabNumber $activeIndex;
    
   // set camera button
   string $mptk_projNode = gs_mptk_getActiveProjNode();
   string $mptk_currentProjCamera[] = `listConnections -type camera -s on -d off $mptk_projNode`;
   int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMixNode);
   
   if ($mptk_currentProjCamera[0] != "") {
       button -e -l $mptk_currentProjCamera[0] (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }else{
       button -e -l "None" (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }

   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_removeProj (){
   
   if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_removeProj\n";
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    string $projectionNode = gs_mptk_getActiveProjNode();
    string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
    int $projIndex = gs_mptk_getActiveProjIndex($mptk_activeTabLabel);
    int $projIndexNameMapping = gs_indexToNameMapping ($mptk_activeTabLabel, $projIndex);
    int $mptk_numProjs = gs_projCamMix_query_num($mptk_activeTabLabel);
    int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode($mptk_activeTabLabel);
   
    if ($mptk_numProjs == 1) error "Can not delete the last projection in a projection group.  Remove the projection group instead.";
            
    string $confirmDelete = `confirmDialog -title "Confirm Delete" -message "This will remove the current projection and all incoming connections, except cameras." -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;

    if ($confirmDelete == "Ok"){
       string $allIncoming[], $deleteList[], $cameras[];
       string $oldList[];
       clear $allIncoming;
       clear $deleteList;
       clear $cameras;
       clear $oldList;
       $deleteList[0] = "";
        
       $allIncoming[0] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].color");
       $allIncoming[1] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].mask");
       $allIncoming[2] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].colorOffset");
       $allIncoming[3] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].placementMatrix");
       $allIncoming[4] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].passThrough");
       $allIncoming[5] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].distanceThreshold");
       $allIncoming[6] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].useShadowOcclusion");
       $allIncoming[7] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].dilate");
       $allIncoming[8] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].samples");
       $allIncoming[9] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].softEdge");
       $allIncoming[10] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].power");
       $allIncoming[11] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].useFacingRatio");
       $allIncoming[12] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].angleThreshold");
       $allIncoming[13] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].labelExclude");
       $allIncoming[14] = ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"].premult");
        
       if (`objExists $projectionNode`){
           $allIncoming = `listConnections -s on -d off $allIncoming`;
           while (`size $allIncoming`){
               // preserve cameras
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "transform") {
                       string $camShape[] = `listRelatives -s $allIncoming[$x]`;
                       if (`nodeType $camShape[0]` == "camera") $cameras[`size $cameras`] = $allIncoming[$x];
                   }
               }
               appendStringArray($oldList, $allIncoming, `size $allIncoming`);
               $oldList = stringArrayRemoveDuplicates($oldList);
               $allIncoming = `listConnections -s on -d off $allIncoming`;
               $allIncoming = stringArrayRemoveDuplicates($allIncoming);
               $allIncoming = stringArrayRemove($oldList, $allIncoming);
           }
           $cameras = stringArrayRemoveDuplicates($cameras);  
           $deleteList = stringArrayRemove($cameras, $oldList);
           $deleteList[0] = $projectionNode;
           delete $deleteList;
            
           
           removeMultiInstance -b true ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"]");
           updateAE $mptk_activeTabLabel;  // need to update AE otherwise removeMultiInstance only breaks connections if connections > 1, instead of removing the instance as well
           removeMultiInstance -b true ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"]");
     
       }else{     
           
           removeMultiInstance -b true ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"]");
           updateAE $mptk_activeTabLabel;  // need to update AE otherwise removeMultiInstance only breaks connections if connections > 1, instead of removing the instance as well
           removeMultiInstance -b true ($mptk_activeTabLabel+".images["+$projIndexNameMapping+"]");
           
       }
       // refresh proj list UI
       deleteUI ("gs_mptk_projListLayout"+$mptk_projCamMixNum);
       string $gs_mptk_projListLayout = `columnLayout -p ("gs_mptk_projScrollLayout"+$mptk_projCamMixNum) -adj 1 ("gs_mptk_projListLayout"+$mptk_projCamMixNum)`;
       gs_mptk_build_projList($mptk_activeTabLabel, ("gs_mptk_projListLayout"+$mptk_projCamMixNum), $mptk_projCamMixNum);
     
       if ($projIndex != 0) $projIndex = $projIndex - 1;
       $projectionNode = `textField -q -tx (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_UI_projName"+$projIndex)`;
       gs_mptk_loadProjAttrs $mptk_activeTabLabel $projectionNode ($mptk_numProjs-1) $mptk_projCamMixNum $projIndex;
    }
     
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}


global proc gs_mptk_selectProjNode () {
   
   if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_selectProjNode\n";
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    string $projectionNode = gs_mptk_getActiveProjNode();
    select $projectionNode;
}

global proc gs_mptk_addMatte (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_addMatte\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
     
    int $activeIndex = `gs_mptk_getActiveProjIndex $gs_projCamMixNode`;
    int $indexToNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $activeIndex);
    string $activeMatteNode = gs_mptk_getActiveMatteNode();
    int $activeProjIndex = gs_mptk_getActiveProjIndex ($gs_projCamMixNode);
    int $activeTabIndex = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
     
    gs_mptk_loadMatteImage($activeMatteNode, "", "", "new_matte", $indexToNameMapping, $gs_projCamMixNode, $activeTabIndex, $activeProjIndex);
     
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_deleteMatte (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_deleteMatte\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
   
   int $activeIndex = `gs_mptk_getActiveMatteIndex $gs_projCamMixNode`;
   
   if ($activeIndex != "-1"){
       
       //string $projectionNode = gs_mptk_getActiveProjNode();
       string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
       int $projIndex = gs_mptk_getActiveProjIndex($mptk_activeTabLabel);
       int $projIndexNameMapping = gs_indexToNameMapping ($mptk_activeTabLabel, $projIndex);
       //int $mptk_numProjs = gs_projCamMix_query_num($mptk_activeTabLabel);
       int $mptk_projCamMixTabNum = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
                
                
       string $matteName = `textField -q -tx (("mptk_UI_tabs_child_" + $mptk_projCamMixTabNum)+"_mptk_UI_matteName"+$activeIndex)`;
       if (!`objExists $matteName`) error ("Can not find node named" + $matteName + " to delete");
               
       string $confirmDelete = `confirmDialog -title "Confirm Delete" -message "This will delete the current matte and all incoming connections except cameras." -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;
   
       if ($confirmDelete == "Ok"){
           string $allIncoming[], $deleteList[], $cameras[];
           string $oldList[];
           clear $allIncoming;
           clear $deleteList;
           clear $cameras;
           clear $oldList;
           // delete everything before the file node except the cameras
           $allIncoming[0] = ($matteName);
           $allIncoming = `listConnections -s on -d off $allIncoming`;
           while (`size $allIncoming`){
               // preserve cameras
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "transform") {
                       string $camShape[] = `listRelatives -s $allIncoming[$x]`;
                       if (`nodeType $camShape[0]` == "camera") $cameras[`size $cameras`] = $allIncoming[$x];
                   }
               }
               appendStringArray($oldList, $allIncoming, `size $allIncoming`);
               $oldList = stringArrayRemoveDuplicates($oldList);
               $allIncoming = `listConnections -s on -d off $allIncoming`;
               $allIncoming = stringArrayRemoveDuplicates($allIncoming);
               $allIncoming = stringArrayRemove($oldList, $allIncoming);
           } 
           $cameras = stringArrayRemoveDuplicates($cameras);  
           $deleteList = stringArrayRemove($cameras, $oldList);

           // preserve file node if it's used in the Proj List
           for ($t=0; $t<`size $deleteList`; $t++){
               if (`nodeType $deleteList[$t]` == "file") {
                  if (`connectionInfo -is ($deleteList[$t]+".outColor")`) {
                    $deleteList[$t] = "";
                    //break;
                  }
               }
           }

           if (`size $deleteList`) catchQuiet (`delete $deleteList`);
            
           //delete everything after the file node except the cameras and the mult/divs
           clear $allIncoming;
           clear $deleteList;
           clear $cameras;
           clear $oldList;
           $allIncoming[0] = ($matteName+".outColor");
           $allIncoming = `listConnections -s off -d on $allIncoming`;
           $oldList[0] = $matteName;
           string $saveMultDiv, $lastInChainMultDiv;
           while (`size $allIncoming`){
               if ($saveMultDiv != "") break; //get out of the loop once we reach our first mult/div
               // preserve cameras
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "transform") {
                       string $camShape[] = `listRelatives -s $allIncoming[$x]`;
                       if (`nodeType $camShape[0]` == "camera") $cameras[`size $cameras`] = $allIncoming[$x];
                   }
               }
               // preserve mult/divs going in to gs_projCamMix
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "multiplyDivide") {
                       $saveMultDiv = $allIncoming[$x];
                       $cameras[`size $cameras`] = $allIncoming[$x];
                       break;
                   }
               }
               // preserve gs_projCamMix
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "gs_projCamMix") {
                          $cameras[`size $cameras`] = $allIncoming[$x];
                          break;
                   }
               }
               // preserve defaultRenderUtilityList
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "defaultRenderUtilityList") {
                          $cameras[`size $cameras`] = $allIncoming[$x];
                          break;
                   }
               }
               // preserve defaultTextureList
               for ($x=0; $x<`size $allIncoming`; $x++){
                   if (`nodeType $allIncoming[$x]` == "defaultTextureList") {
                          $cameras[`size $cameras`] = $allIncoming[$x];
                          break;
                   }
               }
               appendStringArray($oldList, $allIncoming, `size $allIncoming`);
               $oldList = stringArrayRemoveDuplicates($oldList);
               $allIncoming = `listConnections -s on -d off $allIncoming`;
               $allIncoming = stringArrayRemoveDuplicates($allIncoming);
               $allIncoming = stringArrayRemove($oldList, $allIncoming);
           }
           
           // now delete everything except the mult div that links the nodes into the chain--we need this to get the other input to rewire
           $cameras = stringArrayRemoveDuplicates($cameras); 
           $deleteList = stringArrayRemove($cameras, $oldList);

           // preserve file node if it's used in the Proj List
           for ($t=0; $t<`size $deleteList`; $t++){
               if (`nodeType $deleteList[$t]` == "file") {
                  if (`connectionInfo -is ($deleteList[$t]+".outColor")`) {
                    $deleteList[$t] = "";
                    //break;
                  }
               }
           }

           catchQuiet (`delete $deleteList`);
            
           // connect incoming connection to mult div to its outgoing connection
           if ($saveMultDiv != "") {
               string $incomingToMultDiv[] = `listConnections -s on -d off -p 1 $saveMultDiv`;
               string $outgoingFromMultDiv[] = `listConnections -s off -d on -p 1 ($saveMultDiv+".output")`;
               // if no .output plug connection, the mult/div should be the last in the chain, so it will have a .outputX connection
               if (!`size $outgoingFromMultDiv`) {
                   $outgoingFromMultDiv = `listConnections -s off -d on -type "gs_projCamMix" -p 1 ($saveMultDiv+".outputX")`;
                   if (`nodeType $incomingToMultDiv[0]` == "projection") $incomingToMultDiv[0] = ($incomingToMultDiv[0] + "R");
                   if (`nodeType $incomingToMultDiv[0]` == "multiplyDivide") $incomingToMultDiv[0] = ($incomingToMultDiv[0] + "X");
               }
               if ($incomingToMultDiv[0] != "" && $outgoingFromMultDiv[0] != "") connectAttr -f $incomingToMultDiv[0] $outgoingFromMultDiv[0];

               // now delete the dangling mult div
               delete $saveMultDiv;
           }
           
           // refresh proj list UI
           deleteUI ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixTabNum);
           string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$mptk_projCamMixTabNum) ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixTabNum)`;
           gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixTabNum), $mptk_projCamMixTabNum);
                        
       }
   }
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}


global proc string gs_mptk_getActiveProjNode () {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getActiveProjNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
     
    int $activeProj = gs_mptk_getActiveProjIndex($mptk_activeTabLabel);
    int $x = gs_mptk_getUITabNumFromMixNode($mptk_activeTabLabel);
     
    string $projectionNode = `textField -q -tx (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$activeProj)`;
     
    return $projectionNode;
}

global proc string gs_mptk_getActiveMatteNode () {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getActiveMatteNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
     
    int $activeMatte = gs_mptk_getActiveMatteIndex($mptk_activeTabLabel);
    int $x = gs_mptk_getUITabNumFromMixNode($mptk_activeTabLabel);
    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
    int $mptk_numMattes = gs_projCamMix_query_numMattes($gs_projCamMixNode);
    
    string $matteNode;
    // if there's no activeMatte, but there are mattes in the list, assume top matte is active
    if (($activeMatte == -1) && ($mptk_numMattes > 0)) {
      $activeMatte = 0; 
      $matteNode = `textField -q -tx (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_matteName"+$activeMatte)`;
    }
     
    return $matteNode;
}


/////////////////////////////////////////////////////////////////////////////////////// PROJ LIST PROCS //////////////////////////////////////////////////////////////////////////////////////////

global proc string[] mptk_dragCallback( string $dragControl, int $x, int $y, int $mods )
{
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_dragCallback\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // The msg array returned from the drag callback must _not_ be empty,
    // else the drop callback will not trigger.
    //
    return { $dragControl };
     
}


global proc mptk_dropCallback( string $drag, string $drop, string $msgs[], int $x, int $y, int $type )
{
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_dropCallback\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    //textFieldButtonGrp -e -label "Test" -text "Test" -buttonLabel "Test" txtFieldBtn3;
     
    //get index from
    string $buffer[];
    $numTokens = `tokenize $drag "|" $buffer`;
    string $indexFrom = $buffer[8]; // *** if UI layout is modified, this index may no longer be valid
    $numTokens = `tokenize $indexFrom "_" $buffer`;
    $indexFrom = $buffer[`size $buffer` - 1];
     
    // get index to
    $numTokens = `tokenize $drop "|" $buffer`;
    string $indexTo = $buffer[8]; // *** if UI layout is modified, this index may no longer be valid
    $numTokens = `tokenize $indexTo "_" $buffer`;
    $indexTo = $buffer[`size $buffer` - 1];
     
    // get projection tab
    $numTokens = `tokenize $msgs[0] "|" $buffer`;
    string $projectionTab = $buffer[4];  // *** if UI layout is modified, this index may no longer be valid
     
    string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
   int $mptk_numProjs = gs_projCamMix_query_num ($mptk_activeTabLabel);
     
    if ($type == 1) {
       gs_mptk_swap ($indexFrom, $indexTo, $mptk_numProjs, $projectionTab, $mptk_activeTabLabel);
    } else {
       gs_mptk_reorder ($indexFrom, $indexTo, $mptk_numProjs, $projectionTab, $mptk_activeTabLabel);
    }
}


global proc int gs_projCamMix_query_num (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_projCamMix_query_num\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $allAttrs[], $outputAttrs[], $placeMatAttrs[];
    $allAttrs = `listAttr -k -m ($gs_projCamMixNode+".images")`;
    $outputAttrs = `listAttr -o -m ($gs_projCamMixNode+".images")`;
    $placeMatAttrs = `listAttr -m -st "placementMatrix" ($gs_projCamMixNode+".images")`;
    $allAttrs = stringArrayRemove($outputAttrs, $allAttrs);
    $allAttrs = stringArrayRemove($placeMatAttrs, $allAttrs);
     
    int $numProjections = `size $allAttrs`;
     
    return $numProjections;
}

global proc int gs_mptk_getEmptyIndex () {

    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
    string $allAttrs[], $outputAttrs[], $placeMatAttrs[];
    $allAttrs = `listAttr -k -m ($gs_projCamMixNode+".images")`;
    $outputAttrs = `listAttr -o -m ($gs_projCamMixNode+".images")`;
    $placeMatAttrs = `listAttr -m -st "placementMatrix" ($gs_projCamMixNode+".images")`;
    $allAttrs = stringArrayRemove($outputAttrs, $allAttrs);
    $allAttrs = stringArrayRemove($placeMatAttrs, $allAttrs);
   
    int $emptyIndex = 0;
    for ($x=0; $x<`size $allAttrs`; $x++){

   $allAttrs[$x] = substituteAllString ($allAttrs[$x], "images[", "");
   $allAttrs[$x] = substituteAllString ($allAttrs[$x], "]", "");

   if ($allAttrs[$x] != $x) {
           $emptyIndex = $x;
           break;
   }
       $emptyIndex = $x+1;
    }
    return $emptyIndex;
}

global proc int gs_projCamMix_query_numMattes (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_projCamMix_query_numMattes\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
   int $activeProjIndex = gs_mptk_getActiveProjIndex($gs_projCamMixNode);
   int $indexToNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $activeProjIndex);
   
    string $allIncoming[], $files[];
    string $oldList[];
    clear $allIncoming;
    clear $files;
    clear $oldList;
    $allIncoming[0] = ($gs_projCamMixNode+".images["+$indexToNameMapping+"].mask");
    $allIncoming = `listConnections -s on -d off $allIncoming`;
    while (`size $allIncoming`){
       // preserve cameras
       for ($n=0; $n<`size $allIncoming`; $n++){
           if (`nodeType $allIncoming[$n]` == "file" || `nodeType $allIncoming[$n]` == "ramp") {
               $files[`size $files`] = $allIncoming[$n];
           }
       }
       appendStringArray($oldList, $allIncoming, `size $allIncoming`);
       $oldList = stringArrayRemoveDuplicates($oldList);
       $allIncoming = `listConnections -s on -d off $allIncoming`;
       $allIncoming = stringArrayRemoveDuplicates($allIncoming);
       $allIncoming = stringArrayRemove($oldList, $allIncoming);
    }
    $files = stringArrayRemoveDuplicates($files);  
    $mptk_numMattes = `size $files`;
     
    return $mptk_numMattes;
     
}


global proc gs_mptk_swap (int $indexFrom, int $indexTo, int $mptk_numProjs, string $projectionTab, string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_swap\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // UI Refresh
     
    string $mptk_projNameFrom = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexFrom)`;
    string $mptk_projNameTo = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
    string $mptk_swatchFrom = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexFrom)`;
    string $mptk_swatchTo = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexTo)`;
    string $mptk_projPathFrom = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexFrom)`;
    string $mptk_projPathTo = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexTo)`;
    int $mptk_enableStateFrom = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexFrom)`;
    int $mptk_enableStateTo = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexTo)`;
     
    textField -e -tx ($mptk_projNameFrom) ($projectionTab+"_mptk_UI_projName"+$indexTo);
    textField -e -tx ($mptk_projNameTo) ($projectionTab+"_mptk_UI_projName"+$indexFrom);
    textField -e -en ($mptk_enableStateFrom) ($projectionTab+"_mptk_UI_projName"+$indexTo);
    textField -e -en ($mptk_enableStateTo) ($projectionTab+"_mptk_UI_projName"+$indexFrom);
     
    swatchDisplayPort -e -sn $mptk_swatchFrom ($projectionTab+"_mptk_swatchDisplay"+$indexTo);
    swatchDisplayPort -e -sn $mptk_swatchTo ($projectionTab+"_mptk_swatchDisplay"+$indexFrom);
     
    textField -e -tx $mptk_projPathFrom ($projectionTab+"_mptk_projPath"+$indexTo);
    textField -e -tx $mptk_projPathTo ($projectionTab+"_mptk_projPath"+$indexFrom);
    textField -e -en ($mptk_enableStateFrom) ($projectionTab+"_mptk_projPath"+$indexTo);
    textField -e -en ($mptk_enableStateTo) ($projectionTab+"_mptk_projPath"+$indexFrom);
     
    button -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_loadDialogBtn"+$indexTo);
    button -e -en $mptk_enableStateTo ($projectionTab+"_mptk_loadDialogBtn"+$indexFrom);
     
     
    int $gs_reorder_indexPairs[], $mptk_projHighlightActive;
    for ($n=0; $n<$mptk_numProjs; $n++) {
       $gs_reorder_indexPairs[$n] = -1;
       //disable button highlighting, but preserve active button
       vector $mptk_projHighlight = `formLayout -q -bgc ($projectionTab+"_mptk_projAttrsBkgnd"+$n)`;
       if ($mptk_projHighlight.x != .2) $mptk_projHighlightActive = $n;
       formLayout -e -bgc .2 .2 .2 ($projectionTab+"_mptk_projAttrsBkgnd"+$n);
    }
     
    // preserve active button highlight
    string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
    string $mptk_projCamMixNum = substituteAllString($projectionTab, "mptk_UI_tabs_child_", "");
     
    if ($mptk_projHighlightActive == $indexFrom) {
       //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+$indexTo);
       string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
       gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum $indexTo;
    } else if ($mptk_projHighlightActive == $indexTo) {
       //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+$indexFrom);
       string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexFrom)`;
       gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum $indexFrom;
    } else {
       //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+$mptk_projHighlightActive);
       string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$mptk_projHighlightActive)`;
       gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum $mptk_projHighlightActive;
    }  
     
     
    $gs_reorder_indexPairs[$indexFrom] = $indexTo;
    $gs_reorder_indexPairs[$indexTo] = $indexFrom;
     
    gs_reorder_connections ($gs_projCamMixNode, $gs_reorder_indexPairs);
     
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_reorder (int $indexFrom, int $indexTo, int $mptk_numProjs, string $projectionTab, string $gs_projCamMixNode) {
     
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_reorder\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    string $mptk_projNameFrom, $mptk_projNameTo, $mptk_swatchFrom, $mptk_swatchTo, $mptk_projPathFrom, $mptk_projPathTo, $mptk_buttonCmdFrom, $mptk_buttonCmdTo;
    int $mptk_enableStateFrom, $mptk_enableStateTo;
    int $gs_reorder_indexPairs[], $mptk_projHighlightActive = "-1";
     
    // fill all indexes with -1 so the connection reorder in gs_reorder_connections can identify which indexes are not to be modified
    for ($n=0; $n<$mptk_numProjs; $n++) {
       $gs_reorder_indexPairs[$n] = -1;
    }
     
    // UI Refresh
     
    if ($indexFrom < $indexTo) { // for reordering in a positive index direction
       for ($mptk_reorderCount = $indexFrom; $mptk_reorderCount <= ($indexFrom + `abs ($indexFrom - $indexTo)`); $mptk_reorderCount ++){
            
                
           //disable button highlighting, but preserve active button
            
           vector $mptk_projHighlight = `formLayout -q -bgc ($projectionTab+"_mptk_projAttrsBkgnd"+$mptk_reorderCount)`;
           if ($mptk_projHighlight.x != .2) $mptk_projHighlightActive = $mptk_reorderCount;
           formLayout -e -bgc .2 .2 .2 ($projectionTab+"_mptk_projAttrsBkgnd"+$mptk_reorderCount);
            
           // for the first index, move to drop site
           if ($mptk_reorderCount == $indexFrom){
               $gs_reorder_indexPairs[$mptk_reorderCount] = $indexTo; // used for graph connections
               //preserve last index for final loop
               $mptk_projNameTo = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
               $mptk_swatchTo = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexTo)`;
               $mptk_projPathTo = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexTo)`;
               $mptk_enableStateTo = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexTo)`;
               //$mptk_buttonCmdTo = `button -q -c ($projectionTab+"_mptk_projAttrsBtn"+$indexTo)`;
               //now replace last index
               $mptk_projNameFrom = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexFrom)`;
               $mptk_swatchFrom = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexFrom)`;
               $mptk_projPathFrom = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexFrom)`;
               $mptk_enableStateFrom = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexFrom)`;
               //$mptk_buttonCmdFrom = `button -q -c ($projectionTab+"_mptk_projAttrsBtn"+$indexFrom)`;
                
               textField -e -tx ($mptk_projNameFrom) ($projectionTab+"_mptk_UI_projName"+$indexTo);
               swatchDisplayPort -e -sn $mptk_swatchFrom ($projectionTab+"_mptk_swatchDisplay"+$indexTo);
               textField -e -tx $mptk_projPathFrom ($projectionTab+"_mptk_projPath"+$indexTo);
                
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_UI_projName"+$indexTo);
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_projPath"+$indexTo);
               button -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_loadDialogBtn"+$indexTo);
              // button -e -c $mptk_buttonCmdFrom ($projectionTab+"_mptk_projAttrsBtn"+$indexTo);
                   
                
           }else if ($mptk_reorderCount < $indexTo){
           // for remaining indexes, reorder
               $gs_reorder_indexPairs[$mptk_reorderCount] = ($mptk_reorderCount - 1); // used for graph connections
                
               $mptk_projNameFrom = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$mptk_reorderCount)`;
               $mptk_swatchFrom = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$mptk_reorderCount)`;
               $mptk_projPathFrom = `textField -q -tx ($projectionTab+"_mptk_projPath"+$mptk_reorderCount)`;
               $mptk_enableStateFrom = `textField -q -en ($projectionTab+"_mptk_projPath"+$mptk_reorderCount)`;
                
               textField -e -tx ($mptk_projNameFrom) ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount - 1));
               swatchDisplayPort -e -sn $mptk_swatchFrom ($projectionTab+"_mptk_swatchDisplay"+($mptk_reorderCount - 1));
               textField -e -tx $mptk_projPathFrom ($projectionTab+"_mptk_projPath"+($mptk_reorderCount - 1));
                
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount - 1));
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_projPath"+($mptk_reorderCount - 1));
               button -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_loadDialogBtn"+($mptk_reorderCount - 1));
               //button -e -c $mptk_buttonCmdFrom ($projectionTab+"_mptk_projAttrsBtn"+($mptk_reorderCount - 1));
                
                
                
           }else if ($mptk_reorderCount == $indexTo){
           // move last index, preserved from first loop
               $gs_reorder_indexPairs[$mptk_reorderCount] = ($mptk_reorderCount - 1); // used for graph connections
                
               textField -e -tx ($mptk_projNameTo) ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount - 1));
               swatchDisplayPort -e -sn $mptk_swatchTo ($projectionTab+"_mptk_swatchDisplay"+($mptk_reorderCount - 1));
               textField -e -tx $mptk_projPathTo ($projectionTab+"_mptk_projPath"+($mptk_reorderCount - 1));
                
               textField -e -en $mptk_enableStateTo ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount - 1));
               textField -e -en $mptk_enableStateTo ($projectionTab+"_mptk_projPath"+($mptk_reorderCount - 1));
               button -e -en $mptk_enableStateTo ($projectionTab+"_mptk_loadDialogBtn"+($mptk_reorderCount - 1));
               //button -e -c $mptk_buttonCmdTo ($projectionTab+"_mptk_projAttrsBtn"+($mptk_reorderCount - 1));
                
           }
       }
    } else { // for reordering in a negative index direction
       for ($mptk_reorderCount = $indexFrom; $mptk_reorderCount >= ($indexFrom - `abs ($indexFrom - $indexTo)`); $mptk_reorderCount --){
            
           //disable button highlighting, but preserve active button
           vector $mptk_projHighlight = `formLayout -q -bgc ($projectionTab+"_mptk_projAttrsBkgnd"+$mptk_reorderCount)`;
           if ($mptk_projHighlight.x != .2) $mptk_projHighlightActive = $mptk_reorderCount;
           formLayout -e -bgc .2 .2 .2 ($projectionTab+"_mptk_projAttrsBkgnd"+$mptk_reorderCount);
            
           // for the first index, move to drop site
           if ($mptk_reorderCount == $indexFrom){
               $gs_reorder_indexPairs[$mptk_reorderCount] = $indexTo; // used for graph connections
               //preserve last index for final loop
               $mptk_projNameTo = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
               $mptk_swatchTo = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexTo)`;
               $mptk_projPathTo = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexTo)`;
               $mptk_enableStateTo = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexTo)`;
               //now replace last index
               $mptk_projNameFrom = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexFrom)`;
               $mptk_swatchFrom = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$indexFrom)`;
               $mptk_projPathFrom = `textField -q -tx ($projectionTab+"_mptk_projPath"+$indexFrom)`;
               $mptk_enableStateFrom = `textField -q -en ($projectionTab+"_mptk_projPath"+$indexFrom)`;
                
               textField -e -tx ($mptk_projNameFrom) ($projectionTab+"_mptk_UI_projName"+$indexTo);
               swatchDisplayPort -e -sn $mptk_swatchFrom ($projectionTab+"_mptk_swatchDisplay"+$indexTo);
               textField -e -tx $mptk_projPathFrom ($projectionTab+"_mptk_projPath"+$indexTo);
                
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_UI_projName"+$indexTo);
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_projPath"+$indexTo);
               button -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_loadDialogBtn"+$indexTo);
               //button -e -c $mptk_buttonCmdFrom ($projectionTab+"_mptk_projAttrsBtn"+$indexTo);
                
           }else if ($mptk_reorderCount > $indexTo){
           // for remaining indexes, reorder
               $gs_reorder_indexPairs[$mptk_reorderCount] = ($mptk_reorderCount + 1); // used for graph connections
               $mptk_projNameFrom = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$mptk_reorderCount)`;
               $mptk_swatchFrom = `swatchDisplayPort -q -sn ($projectionTab+"_mptk_swatchDisplay"+$mptk_reorderCount)`;
               $mptk_projPathFrom = `textField -q -tx ($projectionTab+"_mptk_projPath"+$mptk_reorderCount)`;
               $mptk_enableStateFrom = `textField -q -en ($projectionTab+"_mptk_projPath"+$mptk_reorderCount)`;
                
               textField -e -tx ($mptk_projNameFrom) ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount + 1));
               swatchDisplayPort -e -sn $mptk_swatchFrom ($projectionTab+"_mptk_swatchDisplay"+($mptk_reorderCount + 1));
               textField -e -tx $mptk_projPathFrom ($projectionTab+"_mptk_projPath"+($mptk_reorderCount + 1));
                
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount + 1));
               textField -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_projPath"+($mptk_reorderCount + 1));
               button -e -en $mptk_enableStateFrom ($projectionTab+"_mptk_loadDialogBtn"+($mptk_reorderCount + 1));
               //button -e -c $mptk_buttonCmdFrom ($projectionTab+"_mptk_projAttrsBtn"+($mptk_reorderCount + 1));
                 
                 
           }else if ($mptk_reorderCount == $indexTo){
           // move last index, preserved from first loop
               $gs_reorder_indexPairs[$mptk_reorderCount] = ($mptk_reorderCount + 1); // used for graph connections
               textField -e -tx ($mptk_projNameTo) ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount + 1));
               swatchDisplayPort -e -sn $mptk_swatchTo ($projectionTab+"_mptk_swatchDisplay"+($mptk_reorderCount + 1));
               textField -e -tx $mptk_projPathTo ($projectionTab+"_mptk_projPath"+($mptk_reorderCount + 1));
                
               textField -e -en $mptk_enableStateTo ($projectionTab+"_mptk_UI_projName"+($mptk_reorderCount + 1));
               textField -e -en $mptk_enableStateTo ($projectionTab+"_mptk_projPath"+($mptk_reorderCount + 1));
               button -e -en $mptk_enableStateTo ($projectionTab+"_mptk_loadDialogBtn"+($mptk_reorderCount + 1));
               //button -e -c $mptk_buttonCmdTo ($projectionTab+"_mptk_projAttrsBtn"+($mptk_reorderCount + 1));
           }
        
       }
    }
     
    // preserve active button highlight
     
    if ($mptk_projHighlightActive != -1) {
           string $mptk_projCamMixNum = substituteAllString($projectionTab, "mptk_UI_tabs_child_", "");
       if ($mptk_projHighlightActive == $indexFrom) {
           string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+$indexTo)`;
           gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum $indexTo;
           //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+$indexTo);
       }
       else if ($indexFrom < $indexTo && $mptk_projHighlightActive != $indexFrom ) {
           string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+($mptk_projHighlightActive - 1))`;
           gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum ($mptk_projHighlightActive - 1);
          //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+($mptk_projHighlightActive - 1));
       }  
       else if ($indexFrom > $indexTo && $mptk_projHighlightActive != $indexFrom ) {
           string $mptk_projNode = `textField -q -tx ($projectionTab+"_mptk_UI_projName"+($mptk_projHighlightActive + 1))`;
           gs_mptk_loadProjAttrs $gs_projCamMixNode $mptk_projNode $mptk_numProjs $mptk_projCamMixNum ($mptk_projHighlightActive + 1);
           //formLayout -e -bgc .5 .5 .5 ($projectionTab+"_mptk_projAttrsBkgnd"+($mptk_projHighlightActive + 1));
       }
     
    }
       gs_reorder_connections ($gs_projCamMixNode, $gs_reorder_indexPairs);
     
   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_reorder_connections(string $gs_projCamMixNode, int $gs_reorder_indexPairs[]){
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_reorder_connections\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // vars
     
    string $gs_color_source[];
    float $gs_color_sourceAttr[];
    string $gs_mask_source[];
    float $gs_mask_sourceAttr;
    string $gs_colorOffset_source[];
    float $gs_colorOffset_sourceAttr[];
    string $gs_matrix_source[];
    float $gs_matrix_sourceAttr[];
    int $gs_passThrough_source;
    string $gs_distanceThreshold_source[];
    float $gs_distanceThreshold_sourceAttr;
    int $gs_useShadowOcclusion_source;
    string $gs_dilate_source[];
    float $gs_dilate_sourceAttr;
    string $gs_samples_source[];
    float $gs_samples_sourceAttr;
    string $gs_softEdge_source[];
    float $gs_softEdge_sourceAttr;
    string $gs_power_source[];
    float $gs_power_sourceAttr;
    int $gs_useFacingRatio_source;
    string $gs_angleThreshold_source[];
    float $gs_angleThreshold_sourceAttr;
    string $gs_labelExclude_source[];
    float $gs_labelExclude_sourceAttr;
    int $gs_premult_source;
     
    string $gs_color_source_array[];
    string $gs_color_sourceAttr_array[];
    string $gs_mask_source_array[];
    string $gs_mask_sourceAttr_array[];
    string $gs_colorOffset_source_array[];
    string $gs_colorOffset_sourceAttr_array[];
    string $gs_matrix_source_array[];
    string $gs_matrix_sourceAttr_array[];
    string $matrixIndex[];
    string $gs_passThrough_source_array[];
    string $gs_distanceThreshold_source_array[];
    string $gs_distanceThreshold_sourceAttr_array[];
    string $gs_useShadowOcclusion_source_array[];
    string $gs_dilate_source_array[];
    string $gs_dilate_sourceAttr_array[];
    string $gs_samples_source_array[];
    string $gs_samples_sourceAttr_array[];
    string $gs_softEdge_source_array[];
    string $gs_softEdge_sourceAttr_array[];
    string $gs_power_source_array[];
    string $gs_power_sourceAttr_array[];
    string $gs_useFacingRatio_source_array[];
    string $gs_angleThreshold_source_array[];
    string $gs_angleThreshold_sourceAttr_array[];
    string $gs_labelExclude_source_array[];
    string $gs_labelExclude_sourceAttr_array[];
    string $gs_premult_source_array[];
            
    int $gs_color_dest[];
    int $gs_mask_dest[];
    int $gs_colorOffset_dest[];
    int $gs_matrix_dest[];
    int $gs_passThrough_dest[];
    int $gs_distanceThreshold_dest[];
    int $gs_useShadowOcclusion_dest[];
    int $gs_dilate_dest[];
    int $gs_samples_dest[];
    int $gs_softEdge_dest[];
    int $gs_power_dest[];
    int $gs_useFacingRatio_dest[];
    int $gs_angleThreshold_dest[];
    int $gs_labelExclude_dest[];
    int $gs_premult_dest[];
     
    //clear  $gs_color_dest;
    //clear  $gs_color_destAttr;
     
    // get size of gs_projCamMix array
     
    int $arraySize = gs_projCamMix_query_num($gs_projCamMixNode);
     
    int $y = 0;
    int $dest = 0;
     
    for ($x=0; $x<$arraySize; $x++){

           // get source index connections and set up attr var declarations
            
           int $z = gs_indexToNameMapping($gs_projCamMixNode, $x);
        
           $gs_color_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].color")`;
           $gs_color_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].color")`;
            
           $gs_mask_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].mask")`;
           $gs_mask_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].mask")`;
            
           $gs_colorOffset_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].colorOffset")`;
           $gs_colorOffset_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].colorOffset")`;
            
           $gs_matrix_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].placementMatrix")`;
           $gs_matrix_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].placementMatrix")`;
            
           $gs_passThrough_source = `getAttr ($gs_projCamMixNode+".images["+$z+"].passThrough")`;
            
           $gs_distanceThreshold_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].distanceThreshold")`;
           $gs_distanceThreshold_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].distanceThreshold")`;
            
           $gs_useShadowOcclusion_source = `getAttr ($gs_projCamMixNode+".images["+$z+"].useShadowOcclusion")`;
            
           $gs_dilate_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].dilate")`;
           $gs_dilate_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].dilate")`;
            
           $gs_samples_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].samples")`;
           $gs_samples_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].samples")`;
            
           $gs_softEdge_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].softEdge")`;
           $gs_softEdge_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].softEdge")`;
            
           $gs_power_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].power")`;
           $gs_power_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].power")`;
            
           $gs_useFacingRatio_source = `getAttr ($gs_projCamMixNode+".images["+$z+"].useFacingRatio")`;
            
           $gs_angleThreshold_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].angleThreshold")`;
           $gs_angleThreshold_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].angleThreshold")`;
            
           $gs_labelExclude_source = `listConnections -p 1 ($gs_projCamMixNode+".images["+$z+"].labelExclude")`;
           $gs_labelExclude_sourceAttr = `getAttr ($gs_projCamMixNode+".images["+$z+"].labelExclude")`;

           $gs_premult_source = `getAttr ($gs_projCamMixNode+".images["+$z+"].premult")`;

           // add to the array
           $gs_color_source_array[$x] = $gs_color_source[0];
           $gs_color_sourceAttr_array[$x] = ($gs_color_sourceAttr[0] + " " + $gs_color_sourceAttr[1] + " " + $gs_color_sourceAttr[2]);
            
           $gs_mask_source_array[$x] = $gs_mask_source[0];
           $gs_mask_sourceAttr_array[$x] = ($gs_mask_sourceAttr);
            
           $gs_colorOffset_source_array[$x] = $gs_colorOffset_source[0];
           $gs_colorOffset_sourceAttr_array[$x] = ($gs_colorOffset_sourceAttr[0] + " " + $gs_colorOffset_sourceAttr[1] + " " + $gs_colorOffset_sourceAttr[2]);
            
           $gs_matrix_source_array[$x] = $gs_matrix_source[0];
           $gs_matrix_sourceAttr_array[$x] = ($gs_matrix_sourceAttr[0] + " " + $gs_matrix_sourceAttr[1] + " " + $gs_matrix_sourceAttr[2] + " " + $gs_matrix_sourceAttr[3] + " " + $gs_matrix_sourceAttr[4] + " " + $gs_matrix_sourceAttr[5] + " " + $gs_matrix_sourceAttr[6] + " " + $gs_matrix_sourceAttr[7] + " " + $gs_matrix_sourceAttr[8] + " " + $gs_matrix_sourceAttr[9] + " " + $gs_matrix_sourceAttr[10] + " " + $gs_matrix_sourceAttr[11] + " " + $gs_matrix_sourceAttr[12] + " " + $gs_matrix_sourceAttr[13] + " " + $gs_matrix_sourceAttr[14] + " " + $gs_matrix_sourceAttr[15]);
            
           $gs_passThrough_source_array[$x] = $gs_passThrough_source;
            
           $gs_distanceThreshold_source_array[$x] = $gs_distanceThreshold_source[0];
           $gs_distanceThreshold_sourceAttr_array[$x] = ($gs_distanceThreshold_sourceAttr);
            
           $gs_useShadowOcclusion_source_array[$x] = $gs_useShadowOcclusion_source;
            
           $gs_dilate_source_array[$x] = $gs_dilate_source[0];
           $gs_dilate_sourceAttr_array[$x] = ($gs_dilate_sourceAttr);
            
           $gs_samples_source_array[$x] = $gs_samples_source[0];
           $gs_samples_sourceAttr_array[$x] = ($gs_samples_sourceAttr);
            
           $gs_softEdge_source_array[$x] = $gs_softEdge_source[0];
           $gs_softEdge_sourceAttr_array[$x] = ($gs_softEdge_sourceAttr);
            
           $gs_power_source_array[$x] = $gs_power_source[0];
           $gs_power_sourceAttr_array[$x] = ($gs_power_sourceAttr);
            
           $gs_useFacingRatio_source_array[$x] = $gs_useFacingRatio_source;
            
           $gs_angleThreshold_source_array[$x] = $gs_angleThreshold_source[0];
           $gs_angleThreshold_sourceAttr_array[$x] = ($gs_angleThreshold_sourceAttr);
            
           $gs_labelExclude_source_array[$x] = $gs_labelExclude_source[0];
           $gs_labelExclude_sourceAttr_array[$x] = ($gs_labelExclude_sourceAttr);
            
           $gs_premult_source_array[$x] = $gs_premult_source;
            
           // find which destination to send it to
           if ($gs_reorder_indexPairs[$x] == "-1"){ // if indexes have not been filled with value from UI reorder, do not modify destination connection
               $gs_color_dest[$x] = $x;
               $gs_mask_dest[$x] = $x;
               $gs_colorOffset_dest[$x] = $x;
               $gs_matrix_dest[$x] = $x;
               $gs_passThrough_dest[$x] = $x;
               $gs_distanceThreshold_dest[$x] = $x;
               $gs_useShadowOcclusion_dest[$x] = $x;
               $gs_dilate_dest[$x] = $x;
               $gs_samples_dest[$x] = $x;
               $gs_softEdge_dest[$x] = $x;
               $gs_power_dest[$x] = $x;
               $gs_useFacingRatio_dest[$x] = $x;
               $gs_angleThreshold_dest[$x] = $x;
               $gs_labelExclude_dest[$x] = $x;
               $gs_premult_dest[$x] = $x;
           }else{
               $gs_color_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_mask_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_colorOffset_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_matrix_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_passThrough_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_distanceThreshold_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_useShadowOcclusion_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_dilate_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_samples_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_softEdge_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_power_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_useFacingRatio_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_angleThreshold_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_labelExclude_dest[$x] = $gs_reorder_indexPairs[$x];
               $gs_premult_dest[$x] = $gs_reorder_indexPairs[$x];
           }
            
    }

    // now reorder
     
    for ($x=0; $x<$arraySize; $x++){
        
       int $y = $gs_color_dest[$x];
       int $w = gs_indexToNameMapping($gs_projCamMixNode, $y);
        
       //////////////////////////////////////////////////////
       //////////// set source to destination ///////////////
       //////////////////////////////////////////////////////
        
      // color
       if ($gs_color_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].color")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].color");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].color") $gs_color_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_color_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].color")`) connectAttr -f $gs_color_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].color");
       }
        
       // mask
       if ($gs_mask_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].mask")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].mask");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].mask") $gs_mask_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_mask_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].mask")`) connectAttr -f $gs_mask_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].mask");
       }
        
       // colorOffset
       if ($gs_colorOffset_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].colorOffset")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].colorOffset");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].colorOffset") $gs_colorOffset_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_colorOffset_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].colorOffset")`) connectAttr -f $gs_colorOffset_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].colorOffset");
       }
        
       // placement matrix
       if ($gs_matrix_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].placementMatrix")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].placementMatrix");
           //for ($i=0; $i<16; $i++){
               tokenizeList ($gs_matrix_sourceAttr_array[$x], $matrixIndex);
               float $matrixValue[];
               for ($i=0; $i<16; $i++){
                   $matrixValue[$i] = $matrixIndex[$i];
               }
               setAttr ($gs_projCamMixNode+".images["+$w+"].placementMatrix") -type "matrix" $matrixValue[0] $matrixValue[1] $matrixValue[2] $matrixValue[3] $matrixValue[4] $matrixValue[5] $matrixValue[6] $matrixValue[7] $matrixValue[8] $matrixValue[9] $matrixValue[10] $matrixValue[11] $matrixValue[12] $matrixValue[13] $matrixValue[14] $matrixValue[15];
           //}
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_matrix_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].placementMatrix")`) connectAttr -f $gs_matrix_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].placementMatrix");
       }
        
       // passThrough
       eval setAttr ($gs_projCamMixNode+".images["+$w+"].passThrough") $gs_passThrough_source_array[$x];
        
       // distanceThreshold
       if ($gs_distanceThreshold_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].distanceThreshold")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].distanceThreshold");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].distanceThreshold") $gs_distanceThreshold_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_distanceThreshold_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].distanceThreshold")`) connectAttr -f $gs_distanceThreshold_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].distanceThreshold");
       }
        
       // useShadowOcclusion
       eval setAttr ($gs_projCamMixNode+".images["+$w+"].useShadowOcclusion") $gs_useShadowOcclusion_source_array[$x];
        
       // dilate
       if ($gs_dilate_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].dilate")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].dilate");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].dilate") $gs_dilate_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_dilate_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].dilate")`) connectAttr -f $gs_dilate_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].dilate");
       }
        
       // samples
       if ($gs_samples_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].samples")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].samples");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].samples") $gs_samples_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_samples_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].samples")`) connectAttr -f $gs_samples_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].samples");
       }
        
       // softEdge
       if ($gs_softEdge_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].softEdge")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].softEdge");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].softEdge") $gs_softEdge_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_softEdge_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].softEdge")`) connectAttr -f $gs_softEdge_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].softEdge");
       }
        
       // power
       if ($gs_power_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].power")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].power");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].power") $gs_power_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_power_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].power")`) connectAttr -f $gs_power_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].power");
       }
        
       // useFacingRatio
       eval setAttr ($gs_projCamMixNode+".images["+$w+"].useFacingRatio") $gs_useFacingRatio_source_array[$x];
        
        
       // angleThreshold
       if ($gs_angleThreshold_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].angleThreshold")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].angleThreshold");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].angleThreshold") $gs_angleThreshold_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_angleThreshold_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].angleThreshold")`) connectAttr -f $gs_angleThreshold_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].angleThreshold");
       }
        
       // labelExclude
       if ($gs_labelExclude_source_array[$x] == ""){
           string $breakConnection[] = `listConnections -s on -d off -p 1 ($gs_projCamMixNode+".images["+$w+"].labelExclude")`;
           if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($gs_projCamMixNode+".images["+$w+"].labelExclude");
           eval setAttr ($gs_projCamMixNode+".images["+$w+"].labelExclude") $gs_labelExclude_sourceAttr_array[$x];
       }else{
           // connect plug to destination index
           if (!`isConnected $gs_labelExclude_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].labelExclude")`) connectAttr -f $gs_labelExclude_source_array[$x] ($gs_projCamMixNode+".images["+$w+"].labelExclude");
       }

       // premult
       eval setAttr ($gs_projCamMixNode+".images["+$w+"].premult") $gs_premult_source_array[$x];
        
    }
   
   //finally, load the matte attrs associated with the projection group    
   string $mptk_projName = gs_mptk_getActiveProjNode();
   int $numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
   int $activeMixNodeIndex = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
   
   deleteUI ("gs_mptk_additionalMattesLayout"+$activeMixNodeIndex);
    string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$activeMixNodeIndex) ("gs_mptk_additionalMattesLayout"+$activeMixNodeIndex)`;
    gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$activeMixNodeIndex), $activeMixNodeIndex);
    //gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $numProjections, $activeMixNodeIndex, 0 );
   

}


global proc int gs_indexToNameMapping (string $gs_projCamMixNode, int $index) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_indexToNameMapping\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // get compound attrs
    string $gs_projCamMixNode = $gs_projCamMixNode;
    string $allAttrs[], $outputAttrs[], $placeMatAttrs[];
    $allAttrs = `listAttr -k -m ($gs_projCamMixNode+".images")`;
    $outputAttrs = `listAttr -o -m ($gs_projCamMixNode+".images")`;
    $placeMatAttrs = `listAttr -m -st "placementMatrix" ($gs_projCamMixNode+".images")`;
    $allAttrs = stringArrayRemove($outputAttrs, $allAttrs);
    $allAttrs = stringArrayRemove($placeMatAttrs, $allAttrs);
    string $indexNames[];
    int $indexNameMapping[];
    // get indexNameMapping
    for ($x = 0; $x < `size $allAttrs`; $x++){
       $z = $x;     
       $numTokens = `tokenize $allAttrs[$x] "[" $indexNames`;
       $numTokens = `tokenize $indexNames[1] "]" $indexNames`;
       $indexNameMapping[$x] = $indexNames[0];
    }

    return $indexNameMapping[$index];

}

global proc gs_mptk_filePathUpdated(string $type, int $index){

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_filePathUpdated\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

       string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
       int $activeMixNodeIndex = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
       
       
   if ($type == "proj") {
       string $path = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_projPath"+$index)`;
       string $mptk_projName = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_UI_projName"+$index)`;
       string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_projName+".image")`;
       setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $path;
       updateFileNodeSwatch $mptk_fileNode[0];
   }
   
   if ($type == "file") {
       string $path = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_projPath"+$index)`;
       string $mptk_fileNode = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_UI_projName"+$index)`;
       setAttr ($mptk_fileNode+".fileTextureName") -type "string" $path;
       updateFileNodeSwatch $mptk_fileNode;
   }
   
   if ($type == "matte"){ // not sure whether proj or file node, due to mult/div input, so need to figure it out
       string $mptk_matteName = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_UI_matteName"+$index)`;
       if (`nodeType $mptk_matteName` == "projection") $type = "matteProj";
       if (`nodeType $mptk_matteName` == "file") $type = "matteFile";
   }
       
   if ($type == "matteProj") {
       string $path = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_mattePath"+$index)`;
       string $mptk_matteName = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_UI_matteName"+$index)`;
       string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_matteName+".image")`;
       if ($mptk_fileNode[0] == "") $mptk_fileNode = `listConnections -s on -d off ($mptk_matteName+".imageR")`;
       if ($mptk_fileNode[0] == "") $mptk_fileNode = `listConnections -s on -d off ($mptk_matteName+".imageG")`;
       if ($mptk_fileNode[0] == "") $mptk_fileNode = `listConnections -s on -d off ($mptk_matteName+".imageB")`;
       if ($mptk_fileNode[0] == "") $mptk_fileNode = `listConnections -s on -d off ($mptk_matteName+".imageA")`;
       if (`nodeType $mptk_fileNode[0]` == "ramp") error "Can not update ramp matte with file name.  Use add/remove buttons instead.";
       setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $path;
       updateFileNodeSwatch $mptk_fileNode[0];
   }
   
   if ($type == "matteFile") {
       string $path = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_mattePath"+$index)`;
       string $mptk_matteName = `textField -q -tx (("mptk_UI_tabs_child_" + $activeMixNodeIndex)+"_mptk_UI_matteName"+$index)`;
       setAttr ($mptk_matteName+".fileTextureName") -type "string" $path;
       updateFileNodeSwatch $mptk_matteName;
   }

   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}
global proc mptk_imageSequencePrompt(int $sequenceStart, int $sequenceEnd, string $fileNode, string $UIField, string $filenames[], int $isMatte) {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_imageSequencePrompt\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    string $form = `setParent -q`;
    formLayout -e -width 150 $form;

    string $t = `text -l "Image sequence detected. Set sequence start frame in timeline:"`;
    int $playbackStart = `playbackOptions -q -min`;
    string $field = `intFieldGrp -v1 $playbackStart startFrame`;
    string $dialogBtns = `rowColumnLayout -numberOfColumns 2 -cat 1 "both" 0`;
      //string $assignShader = `textScrollList -q -si shaderList`;

    string $stringResult = "{";
    for ($n=0; $n<`size $filenames`; $n++){
        $stringResult = ($stringResult + " \"" +  $filenames[$n]);
        if ($n != (`size $filenames` - 1)) $stringResult = $stringResult + "\", ";
    }
    $stringResult = $stringResult + "\"}";


      string $mptkSequenceExpressionCmd = "mptk_sequenceExpression `intFieldGrp -q -v1 startFrame`" + " " + $sequenceStart + " " + $sequenceEnd + " " + $fileNode + " " + $UIField + " " + $stringResult + " " + $isMatte + "; layoutDialog -dismiss \"\"";
      string $b1 = `button -l "Assign" -c $mptkSequenceExpressionCmd`;
      string $b2 = `button -l "Cancel" -c "layoutDialog -dismiss \"\""`;
    setParent ..;

    formLayout -edit
       -attachForm            $t   "top"    5
       -attachForm            $t   "left"   5
       -attachForm            $t   "right"   5

       -attachControl         $field  "top"    5 $t
       -attachForm            $field  "right"  5 
       
       -attachControl         $dialogBtns  "top" 5 $field
       -attachForm            $dialogBtns  "right" 5
       -attachForm            $dialogBtns  "bottom" 5
    $form;
    
}

global proc mptk_sequenceExpression(int $startFrame, int $sequenceStart, int $sequenceEnd, string $fileNode, string $UIField, string $filenames[], int $isMatte){

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_sequenceExpression\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    int $pad;
    string $padding;
    string $UIframe = `getAttr ($fileNode+".fileTextureName")`;

    string $ext = fileExtension($UIframe);
    $ext = "." + $ext;

    // get only the frame numbers
    string $framesOnly[];

    string $sequence;

    for ($y=0; $y<`size $filenames`; $y++) {

      
      // now do all this work to get the frame numbers and padding from the path
      string $fileOnly = match( "[^/\\]*$", $filenames[$y] );
      string $pathOnly = substituteAllString($UIframe, $fileOnly, "");
      //print `size $fileOnly`;
      string $buffer = $fileOnly;
      int $capture = 0;
      int $capturePad = 0;
      int $padSize = 0;
      string $frameNums = "";
      for ($x=0; $x<`size $fileOnly`; $x++){
          string $char = startString ($buffer, 1);
          //if ( `gmatch $name "\."` )
          if ($capture && $char != "." && $char != "_") {
              $frameNums = $frameNums + $char;
              if ($char == "0" && $capturePad != 2) {
                  $padSize++;
                  $capturePad = 1;
              }
              if ($char != "0" && $capturePad == 1) {
                  $capturePad = 2;
              }
          }
          
          if (($char == "." || $char == "_")){
              if ($capture == 0) {
                  $capture = 1;
              } else {
                  $capture = 0;
              }
          }
          $buffer = endString ($buffer, (`size $buffer` - 1));
          //print ($frameNums+"\n");
      }
      $framesOnly[$y] = $frameNums;
      if ($y==0) $sequence = "\""+$framesOnly[0]+"\"";
      if ($y>0) $sequence = ($sequence + ", " + "\""+ $framesOnly[$y] +"\"");
    }

    $UIframe = substring($UIframe, 1, size($UIframe) - size($ext));
    string $frameNums = match("[0-9]+$", $UIframe);
    $UIframe = substring($UIframe, 1, size($UIframe) - size($frameNums));


    setAttr ($fileNode+".useFrameExtension") 1;
    string $currentExpression[] = `listConnections -s on -d off -t expression ($fileNode+".frameExtension")`;
    if (`size $currentExpression`) delete $currentExpression;

    string $expressionCmd = "string $frame[] = {" + $sequence + "};\nint $currentFrame = frame;\nint $startFrame = " + $startFrame + ";\nif (($currentFrame - $startFrame) >= 0) " + $fileNode + ".frameExtension=$frame[$currentFrame - $startFrame];\nstring $UIframe = \"" + $UIframe + "\";\nif (($currentFrame - $startFrame) >= 0) {\n\t$UIframe = ($UIframe + $frame[$currentFrame - $startFrame] + \"" + $ext + "\");\n\tcatchQuiet (`textField -e -tx $UIframe (gs_mptk_getProjSequencePathField(\"" + $fileNode + "\"))`);\n}\nsetAttr -type \"string\" " + $fileNode + ".fileTextureName $UIframe;";
    
    if ($isMatte == 1) {
      $expressionCmd = "string $frame[] = {" + $sequence + "};\nint $currentFrame = frame;\nint $startFrame = " + $startFrame + ";\nif (($currentFrame - $startFrame) >= 0) " + $fileNode + ".frameExtension=$frame[$currentFrame - $startFrame];\nstring $UIframe = \"" + $UIframe + "\";\nif (($currentFrame - $startFrame) >= 0) {\n\t$UIframe = ($UIframe + $frame[$currentFrame - $startFrame] + \"" + $ext + "\");\n\tcatchQuiet (`textField -e -tx $UIframe (gs_mptk_getMatteSequencePathField(\"" + $fileNode + "\"))`);\n}\nsetAttr -type \"string\" " + $fileNode + ".fileTextureName $UIframe;";
    }

    expression -n ("mptk_seq_"+$fileNode) -s $expressionCmd -o $fileNode -ae 1 -uc all ;
}

global proc gs_mptk_loadImage(string $mptk_projName, string $mptk_imageFilePath, string $mptk_UI_pathField, string $type, int $indexNameMapping, string $gs_projCamMixNode, int $x, int $mptk_numProj) {
   
   if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_loadImage\n";
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
   string $nodeType = `textField -q -tx (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$mptk_numProj)`;
   if (`objectType $nodeType` == "ramp") error "Node type is ramp; can not add file path.";
   
   string $multipleFilters = "Adobe Illustrator (*.ai);;Autodesk PIX (*.pix);;Cineon (*.cin);;Encapsulated PostScript (*.eps);;GIF (*.gif);;HDR (*.HDR);;JPEG (*.jpg *.jpeg);;Maya IFF (*.iff);;OpenEXR (*.exr);;PNG (*.png);;RLA (*.rla);;SGI (*.sgi);;PIC (*.PIC);;Targa (*.tga);;Tif (*.tif *.tiff);;Windows Bitmap (*.bmp);;All Files (*.*)";
   string $result[] = `fileDialog2 -dir $mptk_imageFilePath -fm 4 -okc "Open" -cc "Cancel" -fileFilter $multipleFilters -selectFileFilter "All Files" -dialogStyle 2`;
   
   int $sequence = 0;
   int $startFrame = 0;
   int $endFrame = 0;
   if (`size $result` > 1) {
      // get just the frame in the sequence
      string $firstImage = $result[0];
      string $lastImage = $result[(`size $result` - 1)];
      string $ext1 = `fileExtension($firstImage)`;
      string $ext2 = `fileExtension($lastImage)`;

      if ((`size $ext1` > 0) && (`size $ext2` > 0)) {
        $ext1 = "." + $ext1;
        $ext2 = "." + $ext2;
        string $deleteExt1 = substring($firstImage, 1, size($firstImage) - size($ext1));
        string $deleteExt2 = substring($lastImage, 1, size($lastImage) - size($ext2));
        string $number1 = match("[0-9]+$", $deleteExt1);
        string $number2 = match("[0-9]+$", $deleteExt2);
        if ((`size $number1` > 0) && (`size $number2` > 0)){
          $sequence = 1;
          $startFrame = $number1;
          $endFrame = $number2;
          if ($startFrame > $endFrame) {
              $startFrame = $number2;
              $endFrame = $number1;
          }
        }else{
          warning "Image sequence suspected, but could not determine format.  First image selected will be used instead.";
        }
      } 
   } else {
      // delete any expressions that already exist for this projection
      string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_projName+".image")`;
      string $expression[] = `listConnections -s on -d off ($mptk_fileNode[0]+".frameExtension")`;
      if (`size $expression`) delete $expression;
      string $UI_PathField = gs_mptk_getMatteSequencePathField($mptk_fileNode[0]);
      if (endString($UI_PathField, 7) != "9999999") textField -e -tx $result[0] $UI_PathField;
   }
    
   if ($result[0] != "") {
       // set text field
       textField -e -tx $result[0] $mptk_UI_pathField;

       if ($type == "projection") {
           // update file node with new path
           string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_projName+".image")`;
           int $alphaTest = 0;
           if (`nodeType $mptk_fileNode[0]` == "file") {
               setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $result[0];
               // force refresh
               updateFileNodeSwatch $mptk_fileNode[0];
               $alphaTest = `getAttr ($mptk_fileNode[0]+".fileHasAlpha")`;
              if ($sequence > 0){
                 //mptk_imageSequencePrompt($result[0], $mptk_fileNode[0]);
                 string $stringResult = "{";
                 for ($n=0; $n<`size $result`; $n++){
                    $stringResult = ($stringResult + " \"" +  $result[$n]);
                    if ($n != (`size $result` - 1)) $stringResult = $stringResult + "\", ";
                 }
                 $stringResult = $stringResult + "\"}";
                 //print $stringResult;
                 string $layoutDialogCmd = "mptk_imageSequencePrompt  " + $startFrame + " " + $endFrame + " \"" + $mptk_fileNode[0] + "\" " + $mptk_UI_pathField + " " + $stringResult + " 0;";
                 
                 layoutDialog -t "Set image sequence" -ui $layoutDialogCmd;
              }
           }else if (`nodeType $mptk_fileNode[0]` == "ramp") {
               $mptk_fileNode = `listConnections -s on -d off -p 1 ($mptk_projName+".image")`;
               disconnectAttr $mptk_fileNode[0] ($mptk_projName+".image");
               // create file node
               string $file = `shadingNode -asTexture file`;
               setAttr ($file+".defaultColor") -type double3 0 0 0 ;
               setAttr ($file+".filterType") 2;
               // connect to projection
               connectAttr -f ($file+".outColor") ($mptk_projName+".image");
               //update UI
               swatchDisplayPort -e -sn $file (("mptk_UI_tabs_child_" + $x)+"_mptk_swatchDisplay"+$mptk_numProj);
               setAttr ($file+".fileTextureName") -type "string" $result[0];
               // force refresh
               updateFileNodeSwatch $file;
           }
           if ($alphaTest == 1) {
              string $connectChannel = `confirmDialog -message "Alpha channel detected.  Use as matte?" -button "Yes" -button "No" -dismissString "No"`;

              if ($connectChannel == "Yes") {
                string $matteProj[] = `listConnections -s on -d off -t "projection" ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask")`;
                string $matteRamp[];
                if (`size $matteProj`) $matteRamp = `listConnections -s on -d off -t "ramp" ($matteProj[0]+".image")`;
                if (`size $matteRamp`) {
                    string $uvCoord[0] = `listConnections -s on -d off ($matteRamp[0]+".uvCoord")`;
                    string $matteFile = $mptk_fileNode[0];
                    string $place2dTex[] = `listConnections -s on -d off -t "place2dTexture" $matteFile`;
                    if (`size $place2dTex`) delete $place2dTex;
                    connectAttr -force ($uvCoord[0]+".outUV") ($matteFile+".uvCoord"); 
                    connectAttr -force ($uvCoord[0]+".outUvFilterSize") ($matteFile+".uvFilterSize"); 
                    connectAttr -force ($uvCoord[0]+".translateFrame") ($matteFile+".translateFrame"); 
                    connectAttr -force ($uvCoord[0]+".rotateFrame") ($matteFile+".rotateFrame"); 
                    connectAttr -force ($uvCoord[0]+".mirrorU") ($matteFile+".mirrorU"); 
                    connectAttr -force ($uvCoord[0]+".mirrorV") ($matteFile+".mirrorV"); 
                    connectAttr -force ($uvCoord[0]+".stagger") ($matteFile+".stagger"); 
                    connectAttr -force ($uvCoord[0]+".wrapU") ($matteFile+".wrapU"); 
                    connectAttr -force ($uvCoord[0]+".wrapV") ($matteFile+".wrapV"); 
                    connectAttr -force ($uvCoord[0]+".repeatUV") ($matteFile+".repeatUV"); 
                    connectAttr -force ($uvCoord[0]+".vertexUvOne") ($matteFile+".vertexUvOne"); 
                    connectAttr -force ($uvCoord[0]+".vertexUvTwo") ($matteFile+".vertexUvTwo"); 
                    connectAttr -force ($uvCoord[0]+".vertexUvThree") ($matteFile+".vertexUvThree"); 
                    connectAttr -force ($uvCoord[0]+".vertexCameraOne") ($matteFile+".vertexCameraOne"); 
                    connectAttr -force ($uvCoord[0]+".noiseUV") ($matteFile+".noiseUV"); 
                    connectAttr -force ($uvCoord[0]+".offset") ($matteFile+".offset"); 
                    connectAttr -force ($uvCoord[0]+".rotateUV") ($matteFile+".rotateUV");
                    connectAttr -force ($uvCoord[0]+".coverage") ($matteFile+".coverage");
                    connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageR");
                    connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageG");
                    connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageB");
                    setAttr ($matteFile+".fileTextureName") -type "string" $result[0];
                    setAttr ($matteFile+".defaultColor") -type double3 0 0 0 ;
                    delete $matteRamp[0];

                    // update the sequence expression if it exists to include the UI text field for the matte
                    if ($sequence > 0) {
                      string $exp = `expression -q -s ("mptk_seq_"+$matteFile)`;
                      string $expStringArray[] = stringToStringArray($exp, ";");
                      string $alphaLine = ("\n\tcatchQuiet (`textField -e -tx $UIframe (gs_mptk_getMatteSequencePathField(\""+$mptk_fileNode[0]+"\"))`)");
                      stringArrayInsertAtIndex(7, $expStringArray, ("\t"+$alphaLine));
                      $exp = stringArrayToString($expStringArray, ";");
                      expression -e -s $exp ("mptk_seq_"+$matteFile);
                    }

                    // refresh additional mattes UI
                    deleteUI ("gs_mptk_additionalMattesLayout"+$x);
                    string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$x) ("gs_mptk_additionalMattesLayout"+$x)`;
                    gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$x), $x);
                    int $mptk_numProjections = gs_projCamMix_query_numMattes($gs_projCamMixNode);
                    gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $mptk_numProjections, $x, 0 );


                } else {  // if there's no ramp in the additional mattes list

                    // check to see if the file's alpha is already connected in the additional mattes list
                    int $alphaAlreadyConnected = 0;
                    string $outAlphaConnections[] = `listConnections -s off -d on ($mptk_fileNode[0]+".outAlpha")`;
                    if (`size $outAlphaConnections`) {
                      /*
                      for ($t=0; $t<`size $outAlphaConnections`; $t++){
                        string $projectionConnectedTest[] = `listConnections -s off -d on -type "gs_projCamMix" $outAlphaConnections[$t]`;
                        if (`size $projectionConnectedTest`) {
                            $alphaAlreadyConnected = 1;
                            break;
                        }
                        string $projectionConnectedMultDivTest[] = `listConnections -s off -d on -type "multiplyDivide1" $outAlphaConnections[$t]`;
                        if (`size $projectionConnectedMultDivTest`) {
                            $alphaAlreadyConnected = 1;
                            break;
                        }
                      }
                      */
                      $alphaAlreadyConnected = 1;
                    }
                    
                    // previous method just called this to add a projection on top of the ramp
                    
                    if ($alphaAlreadyConnected == 0) {
                      gs_mptk_loadMatteImage($mptk_projName, $result[0], "", "alpha", $indexNameMapping, $gs_projCamMixNode, $x, $mptk_numProj);
                      // substitute newly created projection mask file with our ProjList file and connect .outAlpha
                      string $newProjectionNode[] = `listConnections -s on -d off -type projection ($gs_projCamMixNode+".images["+$x+"].mask")`;
                      if (!`size $newProjectionNode`) {
                        // substitute newly created projection mask file with our ProjList file and connect .outAlpha if there's more than one matte in the additinoal mattes list
                        string $newProjectionNode[] = `listConnections -s on -d off -type "multiplyDivide" ($gs_projCamMixNode+".images["+$x+"].mask")`;
                        if (`size $newProjectionNode` > 0) {
                          // new projection will always be on the top of the stack, so grab its name from the UI
                          int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
                          $mptk_tabIndex -= 1;
                          $newProjectionNode[0] = `textField -q -tx ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_UI_matteName0")`;
                          string $newFileNode[] = `listConnections -s on -d off -type file $newProjectionNode`;
                          string $anyIncomingNewFileNode[] = `listConnections -s on -d off $newFileNode`;
                          delete $newFileNode;
                          delete $anyIncomingNewFileNode;
                          connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageR");
                          connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageG");
                          connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageB");
                          // refresh additional mattes UI
                          deleteUI ("gs_mptk_additionalMattesLayout"+$x);
                          string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$x) ("gs_mptk_additionalMattesLayout"+$x)`;
                          gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$x), $x);
                          int $mptk_numProjections = gs_projCamMix_query_numMattes($gs_projCamMixNode);
                          gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $mptk_numProjections, $x, 0 );
                        }
                      }
                      if (`size $newProjectionNode`) {
                        string $newFileNode[] = `listConnections -s on -d off -type file $newProjectionNode`;
                        string $anyIncomingNewFileNode[] = `listConnections -s on -d off $newFileNode`;
                        delete $newFileNode;
                        delete $anyIncomingNewFileNode;
                        connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageR");
                        connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageG");
                        connectAttr ($mptk_fileNode[0]+".outAlpha") ($newProjectionNode[0]+".image.imageB");
                        // refresh additional mattes UI
                        deleteUI ("gs_mptk_additionalMattesLayout"+$x);
                        string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$x) ("gs_mptk_additionalMattesLayout"+$x)`;
                        gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$x), $x);
                        int $mptk_numProjections = gs_projCamMix_query_numMattes($gs_projCamMixNode);
                        gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $mptk_numProjections, $x, 0 );
                      }
                    }

                    // update the sequence expression if it exists to include the UI text field for the matte
                    if ($sequence > 0) {
                      string $exp = `expression -q -s ("mptk_seq_"+$mptk_fileNode[0])`;
                      string $expStringArray[] = stringToStringArray($exp, ";");
                      string $alphaLine = ("\n\tcatchQuiet (`textField -e -tx $UIframe (gs_mptk_getMatteSequencePathField(\""+$mptk_fileNode[0]+"\"))`)");
                      stringArrayInsertAtIndex(7, $expStringArray, ("\t"+$alphaLine));
                      $exp = stringArrayToString($expStringArray, ";");
                      expression -e -s $exp ("mptk_seq_"+$mptk_fileNode[0]);

                    }
                }

              } else {  // if choosing not to use alpha, make sure one isn't already connected.  If it is, delete it.
                    
                int $alphaAlreadyConnected = 0;
                string $outAlphaConnections[] = `listConnections -s off -d on ($mptk_fileNode[0]+".outAlpha")`;
                if (`size $outAlphaConnections`) {
                  delete $outAlphaConnections;
                  // refresh additional mattes UI
                  deleteUI ("gs_mptk_additionalMattesLayout"+$x);
                  string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$x) ("gs_mptk_additionalMattesLayout"+$x)`;
                  gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$x), $x);
                  //int $mptk_numProjections = gs_projCamMix_query_numMattes($gs_projCamMixNode);
                  //gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $mptk_numProjections, $x, 0 );
                }
              }
           }

           
       }
       if ($type == "file"){
           setAttr ($mptk_projName+".fileTextureName") -type "string" $result[0];
       }
       
       if ($type == "color") {
            
           string $currentMatteIncoming[] = `listConnections -s on -d off ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask")`;
            
           // create projection node
           string $newProjection = `shadingNode -asUtility projection`;
           setAttr ($newProjection+".projType") 8;
           setAttr ($newProjection+".defaultColor") -type double3 0 0 0;
           connectAttr -f ($newProjection+".outColor") ($gs_projCamMixNode+".images["+$indexNameMapping+"].color");
            
            
           // create mask projection node
           string $maskProjNode = `shadingNode -asUtility projection`;
           setAttr ($maskProjNode+".projType") 8;
           setAttr ($maskProjNode+".defaultColor") -type double3 0 0 0;
            
           // create ramp
           string $ramp = `shadingNode -asTexture ramp`;
           removeMultiInstance -break true ($ramp + ".colorEntryList[1]");
           removeMultiInstance -break true ($ramp + ".colorEntryList[2]");
           setAttr ($ramp + ".colorEntryList[0].color") -type double3 1 1 1 ;
           setAttr ($ramp + ".defaultColor")  -type double3 0 0 0 ;
            
           // create mult/div
           string $multDivMask = `shadingNode -asUtility multiplyDivide`;
           setAttr ($multDivMask+".input1X") 1;
           setAttr ($multDivMask+".input1Y") 1;
           setAttr ($multDivMask+".input1Z") 1;
           setAttr ($multDivMask+".input2X") 1;
           setAttr ($multDivMask+".input2Y") 1;
           setAttr ($multDivMask+".input2Z") 1;
            
           // create file texture or use existing file
           string $file;
           if ($type == "color"){
               $file = `shadingNode -asTexture file`;
               setAttr ($file+".defaultColor") -type double3 0 0 0 ;
               setAttr ($file+".filterType") 2;
           } else if ($type == "file") {
               $file = $mptk_projName;
               //disconnectAttr ($file+".outColor") ($gs_projCamMixNode+".images["+$indexNameMapping+"].color");
               setAttr ($file+".defaultColor") -type double3 0 0 0 ;
               setAttr ($file+".filterType") 2;
           }
            
           // create place2dTexture
           string $place2d = `shadingNode -asUtility place2dTexture`;
           setAttr ($place2d+".wrapU") 0;
           setAttr ($place2d+".wrapV") 0;
            
           // connect attributes
           connectAttr -f ($place2d+".coverage") ($file+".coverage");
           connectAttr -f ($place2d+".translateFrame") ($file+".translateFrame");
           connectAttr -f ($place2d+".rotateFrame") ($file+".rotateFrame");
           connectAttr -f ($place2d+".mirrorU") ($file+".mirrorU");
           connectAttr -f ($place2d+".mirrorV") ($file+".mirrorV");
           connectAttr -f ($place2d+".stagger") ($file+".stagger");
           connectAttr -f ($place2d+".wrapU") ($file+".wrapU");
           connectAttr -f ($place2d+".wrapV") ($file+".wrapV");
           connectAttr -f ($place2d+".repeatUV") ($file+".repeatUV");
           connectAttr -f ($place2d+".offset") ($file+".offset");
           connectAttr -f ($place2d+".rotateUV") ($file+".rotateUV");
           connectAttr -f ($place2d+".noiseUV") ($file+".noiseUV");
           connectAttr -f ($place2d+".vertexUvOne") ($file+".vertexUvOne");
           connectAttr -f ($place2d+".vertexUvTwo") ($file+".vertexUvTwo");
           connectAttr -f ($place2d+".vertexUvThree") ($file+".vertexUvThree");
           connectAttr -f ($place2d+".vertexCameraOne") ($file+".vertexCameraOne");
           connectAttr -f ($place2d+".outUV") ($file+".uv");
           connectAttr -f ($place2d+".outUvFilterSize") ($file+".uvFilterSize");
        
           // connect ramp to mask projection
           connectAttr -f ($place2d+".outUV") ($ramp+".uvCoord");  
           connectAttr -f ($place2d+".outUvFilterSize") ($ramp+".uvFilterSize");
           connectAttr -f ($ramp+".outColor") ($maskProjNode+".image");
            
           // connect mask projection to mult/div, and mult/div to gs_projCamMix
           connectAttr -force ($maskProjNode+".outColor") ($multDivMask+".input1");
           connectAttr -f ($multDivMask+".outputX") ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask");
            
           // add existing mattes into input2 of mult/div
           if ($currentMatteIncoming[0] != ""){
               connectAttr -f ($currentMatteIncoming[0]+".output") ($multDivMask+".input2");
           }
            
           // connect camera
           string $camera = `button -q -l (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsCameraBtn")`;
           if (`objExists $camera`) {
               string $camShape[] = `listRelatives -s $camera`;
               catchQuiet (`connectAttr -f ($camShape[0]+".message") ($maskProjNode+".linkedCamera")`);
           }
            
           // connect file to new projection
           connectAttr -f ($file+".outColor") ($newProjection+".image");
            
           // update file node with new path
           string $mptk_fileNode[] = `listConnections -t file $newProjection`;
           setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $result[0];
            
           // update UI
           textField -e -tx $newProjection (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_projName"+$mptk_numProj);
           swatchDisplayPort -e -sn $file (("mptk_UI_tabs_child_" + $x)+"_mptk_swatchDisplay"+$mptk_numProj);
            
           int $numProjections = gs_projCamMix_query_num($gs_projCamMixNode);
           gs_mptk_loadProjAttrs $gs_projCamMixNode $newProjection $numProjections $x $mptk_numProj;
           
           if (`getAttr ($file+".fileHasAlpha")` == 1) {
              string $connectChannel = `confirmDialog -message "Alpha channel detected.  Use as matte?" -button "Yes" -button "No" -dismissString "No"`;

              if ($connectChannel == "Yes") {
                      gs_mptk_loadMatteImage($mptk_projName, $result[0], "", "alpha", $indexNameMapping, $gs_projCamMixNode, $x, $mptk_numProj);
              }
           }
        }
   }
}



global proc gs_mptk_loadMatteImage(string $mptk_projName, string $mptk_imageFilePath, string $mptk_UI_pathField, string $type, int $indexNameMapping, string $gs_projCamMixNode, int $x, int $mptk_numProj) {
     
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_loadMatteImage\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    string $multipleFilters = "Adobe Illustrator (*.ai);;Autodesk PIX (*.pix);;Cineon (*.cin);;Encapsulated PostScript (*.eps);;GIF (*.gif);;HDR (*.HDR);;JPEG (*.jpg *.jpeg);;Maya IFF (*.iff);;OpenEXR (*.exr);;PNG (*.png);;RLA (*.rla);;SGI (*.sgi);;PIC (*.PIC);;Targa (*.tga);;Tif (*.tif *.tiff);;Windows Bitmap (*.bmp);;All Files (*.*)";
    string $result[];
    if ($type != "new_matte" && $type != "alpha"){
       string $nodeType = `textField -q -tx (("mptk_UI_tabs_child_" + $x)+"_mptk_UI_matteName"+$mptk_numProj)`;
       if (`objectType $nodeType` == "ramp") error "Node type is ramp; can not add file path.";
       $result = `fileDialog2 -dir $mptk_imageFilePath -fm 4 -fileFilter $multipleFilters -selectFileFilter "All Files" -dialogStyle 2`;
    }
     
   // create file texture or use existing file
   string $file;
   if ($type == "color" || $type == "new_matte"){
       $file = `shadingNode -asTexture file`;
       setAttr ($file+".defaultColor") -type double3 0 0 0 ;
       setAttr ($file+".filterType") 2;
       setAttr ($file+".fileTextureName") -type "string" $result[0];
   } else if ($type == "alpha") {
       $file = `shadingNode -asTexture file`;
       setAttr ($file+".defaultColor") -type double3 0 0 0 ;
       setAttr ($file+".filterType") 2;
       setAttr ($file+".fileTextureName") -type "string" $mptk_imageFilePath;
   } else if ($type == "file") {
       $file = $mptk_projName;
       setAttr ($file+".defaultColor") -type double3 0 0 0 ;
       setAttr ($file+".filterType") 2;
       setAttr ($file+".fileTextureName") -type "string" $result[0];
   } else if ($type == "projection" && $result[0] != "") {
       string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_projName+".imageR")`;
       if (!`size $mptk_fileNode`) $mptk_fileNode = `listConnections -s on -d off ($mptk_projName+".image")`;
       $file = $mptk_fileNode[0];
       if (`nodeType $file` == "ramp") {
           $file = `shadingNode -asTexture file`;
           setAttr ($file+".defaultColor") -type double3 0 0 0 ;
           setAttr ($file+".filterType") 2;
           setAttr ($file+".fileTextureName") -type "string" $result[0];
       } else if (`nodeType $file` == "file") {
           setAttr ($file+".fileTextureName") -type "string" $result[0];
       }
   }
 
   string $connectionType = ".outColorR";

   int $sequence = 0; 
    int $startFrame = 0;
    int $endFrame = 0;
    if (`size $result` > 1) {
      // get just the frame in the sequence
      string $firstImage = $result[0];
      string $lastImage = $result[(`size $result` - 1)];
      string $ext1 = `fileExtension($firstImage)`;
      string $ext2 = `fileExtension($lastImage)`;

      if ((`size $ext1` > 0) && (`size $ext2` > 0)) {
        $ext1 = "." + $ext1;
        $ext2 = "." + $ext2;
        string $deleteExt1 = substring($firstImage, 1, size($firstImage) - size($ext1));
        string $deleteExt2 = substring($lastImage, 1, size($lastImage) - size($ext2));
        string $number1 = match("[0-9]+$", $deleteExt1);
        string $number2 = match("[0-9]+$", $deleteExt2);
        if ((`size $number1` > 0) && (`size $number2` > 0)){
          $sequence = 1;
          $startFrame = $number1;
          $endFrame = $number2;
          if ($startFrame > $endFrame) {
              $startFrame = $number2;
              $endFrame = $number1;
          }
        }else{
          warning "Image sequence suspected, but could not determine format.  First image selected will be used instead.";
        }
      }
    } else {
      // delete any expressions that already exist for this projection
      string $expression[] = `listConnections -s on -d off ($file+".frameExtension")`;
      if (`size $expression`) delete $expression;
      string $UI_PathField = gs_mptk_getProjSequencePathField($file);
      if (endString($UI_PathField, 7) != "9999999") textField -e -tx $result[0] $UI_PathField;
    }

   if ($result[0] != "") {

      string $connectChannel = `confirmDialog -message "Use which channel for matte?" -button "R" -button "G" -button "B" -button "A" -dismissString "R"`;
      if ($connectChannel == "R") $connectionType = ".outColorR";
      if ($connectChannel == "G") $connectionType = ".outColorG";
      if ($connectChannel == "B") $connectionType = ".outColorB";
      if ($connectChannel == "A") $connectionType = ".outAlpha";
       
   }
   
   // for new projections that have an alpha used as a matte, set outAlpha as connection type
   if ($type == "alpha") $connectionType = ".outAlpha";

   // set text field
   if ($type == "projection" && $result[0] != "") {
       textField -e -tx $result[0] $mptk_UI_pathField;
       // update file node with new path
       string $mptk_fileNode[] = `listConnections -s on -d off ($mptk_projName+".imageR")`;
       if (!`size $mptk_fileNode`) $mptk_fileNode = `listConnections -s on -d off ($mptk_projName+".image")`;
       if (`nodeType $mptk_fileNode[0]` == "file") {
           setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $result[0];
            
           catchQuiet (`connectAttr -f ($file+$connectionType) ($mptk_projName+".imageR")`);
           catchQuiet (`connectAttr -f ($file+$connectionType) ($mptk_projName+".imageG")`);
           catchQuiet (`connectAttr -f ($file+$connectionType) ($mptk_projName+".imageB")`);
    
           // setup sequence expression
           if ($sequence > 0){
                 string $stringResult = "{";
                 for ($n=0; $n<`size $result`; $n++){
                    $stringResult = ($stringResult + " \"" +  $result[$n]);
                    if ($n != (`size $result` - 1)) $stringResult = $stringResult + "\", ";
                 }
                 $stringResult = $stringResult + "\"}";
                 string $layoutDialogCmd = "mptk_imageSequencePrompt  " + $startFrame + " " + $endFrame + " \"" + $mptk_fileNode[0] + "\" " + $mptk_UI_pathField + " " + $stringResult + " 1;";
                 
                 layoutDialog -t "Set image sequence" -ui $layoutDialogCmd;
           }

           // force refresh
           updateFileNodeSwatch $mptk_fileNode[0];
       }else if (`nodeType $mptk_fileNode[0]` == "ramp") {
           // connect to projection
           connectAttr -f ($file+$connectionType) ($mptk_projName+".imageR");
           connectAttr -f ($file+$connectionType) ($mptk_projName+".imageG");
           connectAttr -f ($file+$connectionType) ($mptk_projName+".imageB");
            
           // get place 2d input
           string $place2d[] = `listConnections -s on -d off -p 1 -t place2dTexture $mptk_fileNode[0]`;
           connectAttr -f $place2d[0] ($file+".uvCoord");
           connectAttr -f $place2d[1] ($file+".uvFilterSize");
           // delete ramp
           delete $mptk_fileNode[0];

           // setup sequence expression
           if ($sequence > 0){
                 string $stringResult = "{";
                 for ($n=0; $n<`size $result`; $n++){
                    $stringResult = ($stringResult + " \"" +  $result[$n]);
                    if ($n != (`size $result` - 1)) $stringResult = $stringResult + "\", ";
                 }
                 $stringResult = $stringResult + "\"}";
                 string $layoutDialogCmd = "mptk_imageSequencePrompt  " + $startFrame + " " + $endFrame + " \"" + $file + "\" " + $mptk_UI_pathField + " " + $stringResult +" 1;";
                 
                 layoutDialog -t "Set image sequence" -ui $layoutDialogCmd;
           }
            
           //update UI
           swatchDisplayPort -e -sn ($file+$connectionType) (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numProj);
           // force refresh
           updateFileNodeSwatch $file;
       }
        
   }
   if (($type == "color" && $result[0] != "") || ($type == "file" && $result[0] != "") || $type == "new_matte" || $type == "alpha") {
       if ($type != "new_matte" && $type != "alpha") textField -e -tx $result[0] $mptk_UI_pathField;
       // for new mattes, find any exisiting inputs
       string $currentMatteIncoming[] = `listConnections -s on -d off ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask")`;
        
       // create mask projection node
       string $maskProjNode = `shadingNode -asUtility projection`;
       setAttr ($maskProjNode+".projType") 8;
       setAttr ($maskProjNode+".defaultColor") -type double3 0 0 0;
        
       // create mult/div
       string $multDivMask;
       
       if (`size $currentMatteIncoming`){  
           $multDivMask = `shadingNode -asUtility multiplyDivide`;
           setAttr ($multDivMask+".input1X") 1;
           setAttr ($multDivMask+".input1Y") 1;
           setAttr ($multDivMask+".input1Z") 1;
           setAttr ($multDivMask+".input2X") 1;
           setAttr ($multDivMask+".input2Y") 1;
           setAttr ($multDivMask+".input2Z") 1;
       }
        
       // create place2dTexture
       string $place2d = `shadingNode -asUtility place2dTexture`;
       setAttr ($place2d+".wrapU") 0;
       setAttr ($place2d+".wrapV") 0;
        
       // connect attributes
       connectAttr -f ($place2d+".coverage") ($file+".coverage");
       connectAttr -f ($place2d+".translateFrame") ($file+".translateFrame");
       connectAttr -f ($place2d+".rotateFrame") ($file+".rotateFrame");
       connectAttr -f ($place2d+".mirrorU") ($file+".mirrorU");
       connectAttr -f ($place2d+".mirrorV") ($file+".mirrorV");
       connectAttr -f ($place2d+".stagger") ($file+".stagger");
       connectAttr -f ($place2d+".wrapU") ($file+".wrapU");
       connectAttr -f ($place2d+".wrapV") ($file+".wrapV");
       connectAttr -f ($place2d+".repeatUV") ($file+".repeatUV");
       connectAttr -f ($place2d+".offset") ($file+".offset");
       connectAttr -f ($place2d+".rotateUV") ($file+".rotateUV");
       connectAttr -f ($place2d+".noiseUV") ($file+".noiseUV");
       connectAttr -f ($place2d+".vertexUvOne") ($file+".vertexUvOne");
       connectAttr -f ($place2d+".vertexUvTwo") ($file+".vertexUvTwo");
       connectAttr -f ($place2d+".vertexUvThree") ($file+".vertexUvThree");
       connectAttr -f ($place2d+".vertexCameraOne") ($file+".vertexCameraOne");
       connectAttr -f ($place2d+".outUV") ($file+".uv");
       connectAttr -f ($place2d+".outUvFilterSize") ($file+".uvFilterSize");
        
       // connect mask projection to mult/div
       if ($multDivMask != "") connectAttr -f ($maskProjNode+".outColor") ($multDivMask+".input1");
        
       // connect file to mask projection
       connectAttr -f ($file+$connectionType) ($maskProjNode+".imageR");
       connectAttr -f ($file+$connectionType) ($maskProjNode+".imageG");
       connectAttr -f ($file+$connectionType) ($maskProjNode+".imageB");
        
       // connect mult/div or projection node to projCamMix  
       if ($multDivMask != "") {
           connectAttr -f ($multDivMask+".outputX") ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask");
       } else {
           connectAttr -f ($maskProjNode+".outAlpha") ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask");
       }
       
       // add existing mattes into input2 of mult/div
       if ($multDivMask != "") {
           if (`objectType $currentMatteIncoming` == "multiplyDivide") {
                   connectAttr -f ($currentMatteIncoming[0]+".output") ($multDivMask+".input2");
           } else if (`attributeExists outColor $currentMatteIncoming[0]`) {
                   connectAttr -f ($currentMatteIncoming[0]+".outColor") ($multDivMask+".input2");
           } else if (`attributeExists outValue $currentMatteIncoming[0]`) {
                   connectAttr -f ($currentMatteIncoming[0]+".outValue") ($multDivMask+".input2");
           } else {
                   warning "Unknown existing matte output connection type.  Connect manually.";
           }
       }
        
       // connect camera
       string $camera = `button -q -l (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsCameraBtn")`;
       if (`objExists $camera`) {
           string $camShape[] = `listRelatives -s $camera`;
           catchQuiet (`connectAttr -f ($camShape[0]+".message") ($maskProjNode+".linkedCamera")`);
       }
    
       // update file node with new path
       //string $mptk_fileNode[] = `listConnections -t file $maskProjNode`;
       //setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $result[0];
       //connectAttr -f ($file+$connectionType) ($mptk_projName+".imageR");
       //connectAttr -f ($file+$connectionType) ($mptk_projName+".imageG");
       //connectAttr -f ($file+$connectionType) ($mptk_projName+".imageB");
        
       // update UI
       if ($type != "new_matte" && $type != "alpha") {
           textField -e -tx $maskProjNode $mptk_UI_pathField;
           swatchDisplayPort -e -sn ($file+$connectionType) (("mptk_UI_tabs_child_" + $x)+"_mptk_matteSwatchDisplay"+$mptk_numProj);

           

           // force refresh
           updateFileNodeSwatch $file;
       } else {
           
           deleteUI ("gs_mptk_additionalMattesLayout"+$x);
           string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$x) ("gs_mptk_additionalMattesLayout"+$x)`;
           
           gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$x), $x);

           int $mptk_numProjections = gs_projCamMix_query_numMattes($gs_projCamMixNode);
           gs_mptk_loadMatteAttrs ( $gs_projCamMixNode, $mptk_projName, $mptk_numProjections, $x, 0 );
            
       }
        
       if ($sequence > 0){
             string $stringResult = "{";
             for ($n=0; $n<`size $result`; $n++){
                $stringResult = ($stringResult + " \"" +  $result[$n]);
                if ($n != (`size $result` - 1)) $stringResult = $stringResult + "\", ";
             }
             $stringResult = $stringResult + "\"}";
             string $layoutDialogCmd = "mptk_imageSequencePrompt  " + $startFrame + " " + $endFrame + " \"" + $file + "\" " + $mptk_UI_pathField + " " + $stringResult +" 1;";
             
             layoutDialog -t "Set image sequence" -ui $layoutDialogCmd;
       }
    
   }
     
}


global proc gs_mptk_renameProjNode (string $mptk_projNodeNewName, string $mptk_projFileNode, string $mptk_projTextField, string $type) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_renameProjNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
   // get current projection (or other node type)
    string $mptk_currentProjNode[];
   if ($type == "projection") { // if there's an input, not just a color
      $mptk_currentProjNode = `listConnections -t $type $mptk_projFileNode`;
      string $updateNodeName = `rename $mptk_currentProjNode[0] $mptk_projNodeNewName`;
      // update textField in case of duplicate node naming override
      textField -e -tx $updateNodeName $mptk_projTextField;
    }
    if ($type == "file") {
       string $updateNodeName = `rename $mptk_projFileNode $mptk_projNodeNewName`;
      // update textField in case of duplicate node naming override
      textField -e -tx $updateNodeName $mptk_projTextField;
    }

   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}


global proc gs_mptk_renameMatteNode (string $mptk_matteNodeNewName, string $mptk_matteFileNode, string $mptk_matteTextField, string $type) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_renameMatteNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
   // get current projection (or other node type)
    string $mptk_currentMatteNode[];
   if ($type == "projection") { // if there's an input, not just a color
      $mptk_currentMatteNode = `listConnections -t $type $mptk_matteFileNode`;
      string $updateNodeName = `rename $mptk_currentMatteNode[0] $mptk_matteNodeNewName`;
      // update textField in case of duplicate node naming override
      textField -e -tx $updateNodeName $mptk_matteTextField;
    }
    if ($type == "file") {
       string $updateNodeName = `rename $mptk_matteFileNode $mptk_matteNodeNewName`;
      // update textField in case of duplicate node naming override
      textField -e -tx $updateNodeName $mptk_matteTextField;
    }

   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_enterOnProjText (string $mptk_projNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_enterOnProjText\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    select $mptk_projNode;
}

global proc gs_mptk_solidColorPicker(string $mptk_projCamMix, string $mptk_solidColorBtn, int $mptk_indexToNameMapping) {
     
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_solidColorPicker\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    // open color picker
    string $result, $buffer[];
    $result = `colorEditor`;
    tokenize($result, $buffer);
    if ("1" == $buffer[3]) { // if color was chosen, update
       float $colorR = $buffer[0];
       float $colorG = $buffer[1];
       float $colorB = $buffer[2];
       // update index
       setAttr ($mptk_projCamMix+".images["+$mptk_indexToNameMapping+"].colorR") $colorR;
       setAttr ($mptk_projCamMix+".images["+$mptk_indexToNameMapping+"].colorG") $colorG;
       setAttr ($mptk_projCamMix+".images["+$mptk_indexToNameMapping+"].colorB") $colorB;
       // update UI
       button -e -bgc $colorR $colorG $colorB -ebg 1 $mptk_solidColorBtn;
     
    }  

}

////////////////////////////////////////////////////////////////////////  PROJ ATTR PROCS  ////////////////////////////////////////////////////////////////////////////////////

global proc gs_mptk_selectCamera (string $mptk_camName) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_selectCamera\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    if ($mptk_camName != "None") select $mptk_camName;
}

global proc gs_mptk_assignCamera (int $mptk_numProjections, int $mptk_projCamMixNum) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_assignCamera\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
    int $currentProjIndex = gs_mptk_getActiveProjIndex($gs_projCamMixNode);

    // get selected camera
    string $selectedCam[] = `ls -sl`;
    string $selectedCamShape[];
     
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    if (!`objectType -isType "camera" $selectedCam[0]`){
    // check shape to see if selection is a transform
       $selectedCamShape = `listRelatives -s $selectedCam[0]`;
       if (`objectType $selectedCamShape[0]` != "camera") error "Select a camera to assign to the active projection.";
    }else{
       $selectedCamShape[0] = $selectedCam[0];
       $selectedCam = `listRelatives -p $selectedCam[0]`;
    }

   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    // get name of selected color projection
    string $mptk_currentProjection = `textField -q -tx (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_UI_projName"+$currentProjIndex)`;
   
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    // make connection and update UI
    if (!`objExists $mptk_currentProjection`) error "No projection node connected; unable to connect camera.";
    if (`nodeType $mptk_currentProjection` == "file") error "Input is node type file, not node type projection; unable to connect camera.";
    // connect color
    catchQuiet (`connectAttr -f ($selectedCamShape[0]+".message") ($mptk_currentProjection+".linkedCamera")`);
     
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    //connect mask
     
    int $indexNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $currentProjIndex);
     
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    string $allIncoming[], $projections[];
    string $oldList[];
    clear $allIncoming;
    clear $projections;
    clear $oldList;
    $allIncoming[0] = ($gs_projCamMixNode+".images["+$indexNameMapping+"].mask");
    $allIncoming = `listConnections -s on -d off $allIncoming`;
    while (`size $allIncoming`){
       // preserve cameras
       for ($n=0; $n<`size $allIncoming`; $n++){
           if (`nodeType $allIncoming[$n]` == "projection") {
               $projections[`size $projections`] = $allIncoming[$n];
           }
       }
       appendStringArray($oldList, $allIncoming, `size $allIncoming`);
       $oldList = stringArrayRemoveDuplicates($oldList);
       $allIncoming = `listConnections -s on -d off $allIncoming`;
       $allIncoming = stringArrayRemoveDuplicates($allIncoming);
       $allIncoming = stringArrayRemove($oldList, $allIncoming);
      
       if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
    }
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";


    //add worldMatrix to gs_projCamMix projection matrix
    catchQuiet (`connectAttr -f ($selectedCamShape[0]+".worldMatrix[0]") ($gs_projCamMixNode+".images["+$indexNameMapping+"].placementMatrix")`);
     
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    $projections = stringArrayRemoveDuplicates($projections);  
    $mptk_numMattes = `size $projections`;
     
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    if (`size $projections`) {
       for ($z=0; $z<`size $projections`; $z++){
           catchQuiet (`connectAttr -f ($selectedCamShape[0]+".message") ($projections[$z]+".linkedCamera")`);
       }
    }else{
       warning "Unable to find mask projection node; camera not assigned to mask projection.";
    }
     
    button -e -l $selectedCam[0] (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
    
    //add worldInverseMatrix to gs_viewportProj
    gs_mptk_viewportSetup ($gs_projCamMixNode, $mptk_currentProjection);
   
     
}


////////////////////////////////////////////////////////////////////////  OBJ LIST PROCS  ////////////////////////////////////////////////////////////////////////////////////



global proc mptk_addGeo (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_addGeo\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $selections[] = `ls -sl`;
   
   // see if gs_projCamMix has outgoing connections
   string $outConnection[] = `listConnections -s off -d on ($gs_projCamMixNode+".outColor")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outColorR")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outColorG")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outColorB")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outAlpha")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte0")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte1")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte2")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte3")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte4")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte5")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte6")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte7")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte8")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte9")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte10")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte11")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte12")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte13")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte14")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte15")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte16")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte17")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte18")`;
   if (!`size $outConnection`) $outConnection = `listConnections -s off -d on ($gs_projCamMixNode+".outMatte19")`;  
   
   if (!`size $outConnection`) {
       /*print ("No known output from " + $gs_projCamMixNode + " found.  Creating surfaceShader and connecting " + $gs_projCamMixNode + ".");
       string $surfShad = `shadingNode -asShader surfaceShader`;
       connectAttr -f ($gs_projCamMixNode+".outColor") ($surfShad+".outColor");
       sets -renderable true -noSurfaceShader true -empty -name ($surfShad+"SG");
       connectAttr -f ($surfShad+".message") ($surfShad+"SG.miMaterialShader");*/
       string $activeProjNode = gs_mptk_getActiveProjNode();
       gs_mptk_viewportSetup ($gs_projCamMixNode, $activeProjNode);
   }
   
   string $shadingEngines[] = `mptk_allShadingEngines $gs_projCamMixNode`;
   string $chosenShader;
   
   if (`size $shadingEngines` > 1) {
        // build a dialog and get the selection
        string $layoutDialogCmd = "mptk_assignShaderLayoutDialogUI " + $gs_projCamMixNode;
        $chosenShader = `layoutDialog -t "gs_mptk" -ui $layoutDialogCmd`;
   }else{
  $chosenShader = $shadingEngines[0];   
   }
   
    // assign shader based on user choice
    if ($chosenShader != ""){
       for ($selection in $selections) {
           sets -e -forceElement $chosenShader $selection;
           gs_mptk_rebuildObjUI;
       }
    }
}


global proc mptk_removeGeo (string $mptk_geo[]) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_removeGeo\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $shapes[] = `listRelatives -s $mptk_geo`;
    for ($shape in $shapes) {
       string $shadingEngine[] = `listConnections -destination true -source false -plugs false -type "shadingEngine" $shape`;
       sets -e -rm $shadingEngine $shape;
    }
    gs_mptk_rebuildObjUI;
}

global proc mptk_assignShaderLayoutDialogUI (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_assignShaderLayoutDialogUI\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    string $form = `setParent -q`;
    formLayout -e -width 300 $form;

    string $t = `text -l "Assign geometry to shader:"`;
    string $field = `textScrollList shaderList`;
    string $dialogBtns = `rowColumnLayout -numberOfColumns 2 -cat 1 "both" 0`;
       string $assignShader = `textScrollList -q -si shaderList`;
       string $b1 = `button -l "Assign" -c "layoutDialog -dismiss `textScrollList -q -si shaderList`"`;
       string $b2 = `button -l "Cancel" -c "layoutDialog -dismiss \"\""`;
    setParent ..;

    formLayout -edit
       -attachForm            $t   "top"    5
       -attachForm            $t   "left"   5

       -attachControl         $field  "top"    5 $t
       -attachForm            $field  "left"   5
       -attachForm            $field  "right"  5  
        
       -attachControl         $dialogBtns  "top"    5 $field
       -attachForm            $dialogBtns  "right"   5
       -attachForm            $dialogBtns  "bottom" 5
        

    $form;
     
    string $SGListItems[] = `mptk_allShadingEngines $gs_projCamMixNode`;
    for ($SGListItem in $SGListItems){
       textScrollList -e -append $SGListItem shaderList;
    }
     
}


/////////////////////////////////////////////////////////////////////////////////////// MENU ITEM PROCS //////////////////////////////////////////////////////////////////////////////////////////


global proc gs_mptk_tabChanged(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_tabChanged\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  string $gs_projCamMix = gs_mptk_getActiveMixNode();

   // set file filtering for UI
   menuItem -e -cb 0 gs_mptk_fileFiltering_Off;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Mipmap;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Box;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Quadratic;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Quartic;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Gaussian;
   //menuItem -e -cb 0 gs_mptk_fileFiltering_Elliptical;
   
   if ($gs_projCamMix != "") {
       // find first file
       string $allIncoming[], $files[];
       string $oldList[];
       clear $allIncoming;
       clear $files;
       clear $oldList;
       $allIncoming[0] = $gs_projCamMix;
       $allIncoming = `listConnections -s on -d off $allIncoming`;
       while (`size $allIncoming`){
           for ($n=0; $n<`size $allIncoming`; $n++){
               if (`nodeType $allIncoming[$n]` == "file") {
                   $files[`size $files`] = $allIncoming[$n];
                   break;
               }
           }
           appendStringArray($oldList, $allIncoming, `size $allIncoming`);
           $oldList = stringArrayRemoveDuplicates($oldList);
           $allIncoming = `listConnections -s on -d off $allIncoming`;
           $allIncoming = stringArrayRemoveDuplicates($allIncoming);
           $allIncoming = stringArrayRemove($oldList, $allIncoming);
       }
       if ($files[0] != "") {
           int $filterTypeIndex = `getAttr ($files[0]+".filterType")`;
           string $chosen;
           //int $elliptical;
           if ($filterTypeIndex == 0) $chosen = "Off";
           if ($filterTypeIndex == 1) $chosen = "Mipmap";
           if ($filterTypeIndex == 2) $chosen = "Box";
           if ($filterTypeIndex == 3) $chosen = "Quadratic";
           if ($filterTypeIndex == 4) $chosen = "Quartic";
           if ($filterTypeIndex == 5) $chosen = "Gaussian";
           /*if ($filterTypeIndex == 1) {
               if (`getAttr ($files[0]+".miUseEllipticalFilter")` == 1) $chosen = "Elliptical";
           }*/
           menuItem -e -cb 1 ("gs_mptk_fileFiltering_"+$chosen);
       }
   }


   // The following is deprecated since gs_mptk_viewportSetup now handles the creation of gs_const and shading engine
   /*
   /////////////////////////////  SET OPTIONS MENU ////////////////////////////////////////////////////////////////////////////////////////////////////////

    // viewport proj attrs
    if ($gs_projCamMix != "") {
       int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMix);
       string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
       string $shadingEngine, $surfaceShader, $src[];
       if ($allObjs[0] != "") {
         string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
         string $currentShaders[], $allShaders[];
         clear $allShaders;
         for ($x=0; $x<`size $allDescendents`; $x++){
           $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
           $allShaders = stringArrayCatenate($allShaders, $currentShaders);
           $allShaders = stringArrayRemoveDuplicates($allShaders);
         }
         $shadingEngine = $allShaders[0];
       }
       if ($shadingEngine == "") // if no geo or assigned shading engine
       {
         // find all shading engines assigned to gs_projCamMix
         string $shadEngine[];
         clear $src;
         $src[0] = $gs_projCamMix;
         while (`size $src`) {
            //step through chain
            $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
            if (`size $shadEngine`) break;
            $src = `listConnections -s off -d on -scn 1 $src`;
         }
         $shadingEngine = $shadEngine[0];
       }
       if ($shadingEngine == "") // if still no assigned shading engine, create one
       {
         $shadingEngine = `sets -renderable true -noSurfaceShader true -empty -name gs_mptkSG`;
       }
       // now get surfaceShader assigned to shading engine
       clear $src;
       $src = `listConnections -s on -d off -p 1 ($shadingEngine+".miMaterialShader")`;
       if (!`size $src`) // if no connection to .miMaterialShader, create gs_const and connect
       {
       print "No surface shader found. Creating gs_const and connecting.\n";
             $surfaceShader = `shadingNode -asShader gs_const`;
       //connectAttr -f ($surfaceShader+".outValue") ($shadingEngine+".miMaterialShader");
       connectAttr -f ($gs_projCamMix+".outColor") ($surfaceShader+".color");
       if (`nodeType $surfaceShader` == "gs_const") connectAttr -f ($gs_projCamMix+".outAlpha") ($surfaceShader+".opacity");
       //if (`nodeType $surfaceShader` == "gs_const") setAttr ($surfaceShader+".custom_alpha") 1;
       $surfaceShader = ($surfaceShader+".outValue"); // include plug
         
       }else{
          $surfaceShader = $src[0];
       }
       // now work on viewport shader
       string $viewportProj[] = `listConnections -s on -d off -t gs_viewportProj $shadingEngine`;
       if (`size $viewportProj`) {
         int $doLayering = `getAttr ($viewportProj[0]+".layeredTexture")`;
         int $cc = `getAttr ($viewportProj[0]+".viewportLinToVid")`;
         menuItem -e -cb $cc gs_mptk_viewport;
         menuItem -e -cb $doLayering gs_mptk_layered;
       }
    }
    */

   // enable/disable controls
   gs_mptk_enableShadowOcclusion();
   gs_mptk_enableFacingRatio();

   // set camera button
   string $mptk_projNode = gs_mptk_getActiveProjNode();
   string $mptk_currentProjCamera[] = `listConnections -type camera -s on -d off $mptk_projNode`;
   int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMix);
   
   if ($mptk_currentProjCamera[0] != "") {
       button -e -l $mptk_currentProjCamera[0] (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }else{
       button -e -l "None" (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }

   // vray rebuild
   if (`menuItem -q -cb gs_mptk_vrayRender` == 1) gs_mptk_vrayRebuild();
}

global proc gs_mptk_fileFiltering(string $chosen){

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_fileFiltering\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

   // set all UI checkboxes to off
   menuItem -e -cb 0 gs_mptk_fileFiltering_Off;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Mipmap;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Box;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Quadratic;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Quartic;
   menuItem -e -cb 0 gs_mptk_fileFiltering_Gaussian;
   //menuItem -e -cb 0 gs_mptk_fileFiltering_Elliptical;
   
   // get current gs_projCamMix
    string $gs_projCamMix = gs_mptk_getActiveMixNode();
   
   if ($gs_projCamMix == "") error "Can not set filtering because no gs_projCamMix node found.";
   
   // find all files
    string $allIncoming[], $files[];
    string $oldList[];
    clear $allIncoming;
    clear $files;
    clear $oldList;
    $allIncoming[0] = $gs_projCamMix;
    $allIncoming = `listConnections -s on -d off $allIncoming`;
    while (`size $allIncoming`){
       for ($n=0; $n<`size $allIncoming`; $n++){
           if (`nodeType $allIncoming[$n]` == "file") {
               $files[`size $files`] = $allIncoming[$n];
           }
       }
       appendStringArray($oldList, $allIncoming, `size $allIncoming`);
       $oldList = stringArrayRemoveDuplicates($oldList);
       $allIncoming = `listConnections -s on -d off $allIncoming`;
       $allIncoming = stringArrayRemoveDuplicates($allIncoming);
       $allIncoming = stringArrayRemove($oldList, $allIncoming);
    }
   int $filterTypeIndex = 0;
   if ($chosen == "Mipmap") $filterTypeIndex = 1;
   if ($chosen == "Box") $filterTypeIndex = 2;
   if ($chosen == "Quadratic") $filterTypeIndex = 3;
   if ($chosen == "Quartic") $filterTypeIndex = 4;
   if ($chosen == "Gaussian") $filterTypeIndex = 5;
   //if ($chosen == "Elliptical") $filterTypeIndex = 1;
   
    $files = stringArrayRemoveDuplicates($files);
   for ($file in $files){
       setAttr ($file+".filterType") $filterTypeIndex;
       /*if ($chosen == "Elliptical") {
           setAttr ($file+".miUseEllipticalFilter") 1;
       } else {
           setAttr ($file+".miUseEllipticalFilter") 0;
       }*/
   }
   
   // set chosen UI checkbox to on
   menuItem -e -cb 1 ("gs_mptk_fileFiltering_"+$chosen);

}


/////////////////////////////////////////////////////////////////////////////////////// HELPER PROCS //////////////////////////////////////////////////////////////////////////////////////////

global proc string[] mptk_allShadingEngines (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_allShadingEngines\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $projCamMixDest[];
    clear $projCamMixDest;
    $projCamMixDest = `listConnections -s off -d on ($gs_projCamMixNode+".outColor") ($gs_projCamMixNode+".outColorR") ($gs_projCamMixNode+".outColorG") ($gs_projCamMixNode+".outColorB") ($gs_projCamMixNode+".outAlpha") ($gs_projCamMixNode+".outMatte0") ($gs_projCamMixNode+".outMatte1") ($gs_projCamMixNode+".outMatte2") ($gs_projCamMixNode+".outMatte3") ($gs_projCamMixNode+".outMatte4") ($gs_projCamMixNode+".outMatte5") ($gs_projCamMixNode+".outMatte6") ($gs_projCamMixNode+".outMatte7") ($gs_projCamMixNode+".outMatte8") ($gs_projCamMixNode+".outMatte9") ($gs_projCamMixNode+".outMatte10") ($gs_projCamMixNode+".outMatte11") ($gs_projCamMixNode+".outMatte12") ($gs_projCamMixNode+".outMatte13") ($gs_projCamMixNode+".outMatte14") ($gs_projCamMixNode+".outMatte15") ($gs_projCamMixNode+".outMatte16") ($gs_projCamMixNode+".outMatte17") ($gs_projCamMixNode+".outMatte18") ($gs_projCamMixNode+".outMatte19")`;
    string $mptk_shadingEngines[];
    string $oldList[];
    clear $oldList;
    clear $mptk_shadingEngines;
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
    if (`size $projCamMixDest`){ // if gs_projCamMix has outbound connection
       for ($x=0; $x<`size $projCamMixDest`; $x++){ // iterate for all destinations
           string $rootNode = mptk_rootNode ($projCamMixDest[$x]);
           string $testForSG[] = `listConnections -d on -s off $rootNode`;
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
           for ($y=0; $y<`size $testForSG`; $y++){
               if (`nodeType $testForSG[$y]` == "shadingEngine"){
                   $mptk_shadingEngines[`size $mptk_shadingEngines`] = $testForSG[$y];
               }
           }     
           appendStringArray($oldList, $testForSG, `size $testForSG`);
           $testForSG = stringArrayRemoveDuplicates($testForSG);
           $testForSG = stringArrayRemove($oldList, $testForSG);
       }
    }
   if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   $mptk_shadingEngines = stringArrayRemoveDuplicates($mptk_shadingEngines);
     
   return $mptk_shadingEngines;
}

global proc string[] mptk_assignedGeo (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_assignedGeo\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // get all objects
    string $mptk_geo[] = `ls -g`;
    // test for connection to shading node
    string $mptk_shadingEngines[] = `mptk_allShadingEngines $gs_projCamMixNode`;
    string $mptk_geoAssigned[];
    for ($mptk_shadingEngine in $mptk_shadingEngines){
       for ($z=0; $z<`size $mptk_geo`; $z++){
           if (`sets -isMember $mptk_shadingEngine $mptk_geo[$z]`){
               string $parentTransform[] = `listRelatives -p $mptk_geo[$z]`;
               $mptk_geoAssigned[`size $mptk_geoAssigned`] = $parentTransform[0];
           }
       }
    }

    return $mptk_geoAssigned;
}


global proc string mptk_rootNode( string $in )
{
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_rootNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $buffer[];
    tokenize $in "." $buffer;
     
    return $buffer[0];
}

global proc int gs_mptk_getActiveProjIndex (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getActiveProjIndex\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    int $numProjs = gs_projCamMix_query_num($gs_projCamMixNode);
     
    int $mptk_projHighlightActive;
    int $projectionTabNum = `gs_mptk_getUITabNumFromMixNode $gs_projCamMixNode`;
     
    for ($n=0; $n<$numProjs; $n++) {
       vector $mptk_projHighlight = `formLayout -q -bgc ("mptk_UI_tabs_child_" + $projectionTabNum +"_mptk_projAttrsBkgnd"+$n)`;
       if ($mptk_projHighlight.x != .2) $mptk_projHighlightActive = $n;
    }
     
    return $mptk_projHighlightActive;
   
}

global proc int gs_mptk_getActiveMatteIndex (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getActiveMatteIndex\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    int $numProjs = gs_projCamMix_query_numMattes($gs_projCamMixNode);
     
    int $mptk_matteHighlightActive = "-1";
    int $projectionTabNum = `gs_mptk_getUITabNumFromMixNode $gs_projCamMixNode`;

    for ($n=0; $n<$numProjs; $n++) {
       vector $mptk_matteHighlight = `formLayout -q -bgc ("mptk_UI_tabs_child_" + $projectionTabNum +"_mptk_matteAttrsBkgnd"+$n)`;
       if ($mptk_matteHighlight.x != .2) $mptk_matteHighlightActive = $n;
    }
     
    return $mptk_matteHighlightActive;
   
}



/////////////////////////////////////////////////////////  REFRESH PROCS //////////////////////////////////////////////////////////////////////////


global proc int gs_mptk_getUITabNumFromMixNode (string $gs_projCamMixNode) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_getUITabNumFromMixNode\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // get the UI tab child number given a gs_projCamMixNode name as input
    int $tabNum = 0;
    string $UITabs[] = `tabLayout -q -tabLabel mptk_UI_tabs`;
    for ($x=0; $x<`size $UITabs`; $x++){
       if ($UITabs[$x] == $gs_projCamMixNode) {
           $tabNum = $x;
           break;
       }
    }
     
    return $tabNum;
}

global proc gs_mptk_rebuildObjUI () {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_rebuildObjUI\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    string $mptk_allProjCamMixs[] = `ls -type gs_projCamMix`;
     
    for ($mptk_allProjCamMix in $mptk_allProjCamMixs) {
       int $tabNum = `gs_mptk_getUITabNumFromMixNode $mptk_allProjCamMix`;
        
       string $geoListItems[] = `mptk_assignedGeo $mptk_allProjCamMix`;
       textScrollList -e -ra (("mptk_UI_tabs_child_" + $tabNum)+"_mptk_objList");
        
       for ($geoListItem in $geoListItems){
           textScrollList -e -append $geoListItem (("mptk_UI_tabs_child_" + $tabNum)+"_mptk_objList");
       }
    }
}


global proc gs_mptk_loadProjAttrs (string $gs_projCamMixNode, string $mptk_projNode, int $mptk_numProjections, int $mptk_projCamMixNum, int $mptk_numProj) {
   
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_loadProjAttrs\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // restore all bgkgnd to default (no highlight)
    for ($n=0; $n<$mptk_numProjections; $n++){
       formLayout -e -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsBkgnd"+$n);
    }
     
    // set highlight
    formLayout -e -bgc .5 .5 .5 -ebg 1 (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsBkgnd"+$mptk_numProj);
     
    int $indexNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $mptk_numProj);
     
     
    // colorOffset
    attrColorSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].colorOffset") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsColorOffset");
    // passThrough
    attrControlGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].passThrough") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsPassThrough");
    // distanceThreshold
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].distanceThreshold") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsDistanceThreshold");
    // useShadowOcclusion
    attrControlGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].useShadowOcclusion") -cc gs_mptk_enableShadowOcclusion (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsUseShadowOcclusion");
    // dilate
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].dilate") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsDilate");
    // samples
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].samples") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsSamples");
    // softEdge
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].softEdge") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsSoftEdge");
    // power
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].power") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsPower");
    // useFacingRatio
    attrControlGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].useFacingRatio") -cc gs_mptk_enableFacingRatio (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsUseFacingRatio");
    // angleThreshold
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].angleThreshold") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsAngleThreshold");
    // labelExclude
    attrFieldSliderGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].labelExclude") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsLabelExclude");
     // premult
    attrControlGrp -e -attribute ($gs_projCamMixNode+".images["+$indexNameMapping+"].premult") (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsPremult");
    
    //refresh UI
     
    deleteUI ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixNum);
     
    string $gs_mptk_additionalMattesLayout = `columnLayout -adj 1 -p ("gs_mptk_scrollProjAttrsLayout"+$mptk_projCamMixNum) ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixNum)`;
    gs_mptk_build_additionalMattes($gs_projCamMixNode, ("gs_mptk_additionalMattesLayout"+$mptk_projCamMixNum), $mptk_projCamMixNum);
     
   // enable/disable controls
   gs_mptk_enableFacingRatio();
   gs_mptk_enableShadowOcclusion();

   // name button depending on connection
   if ($mptk_projNode == "No Projection") error "No projection group found.  Add a new projection group to the projection list, then remove this entry.";  
    string $mptk_currentProjCamera[] = `listConnections -type camera -s on -d off $mptk_projNode`;
   if ($mptk_currentProjCamera[0] != "") {
       button -e -l $mptk_currentProjCamera[0] (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }else{
       button -e -l "None" (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn");
   }
   
   // connect file to gs_viewportProj
   gs_mptk_viewportSetup($gs_projCamMixNode, $mptk_projNode);

}

global proc gs_mptk_viewportSetup (string $gs_projCamMix, string $mptk_projNode) 
{
   
  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_viewportSetup\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

   // first, fix bug that sets the wrong $mptk_projNode when loading the UI with multiple gs_projCamMix nodes in the scene
   // we do this by validating whether $mptk_projNode is actually connected to $gs_projCamMix
   // and if not, we for $mptk_projNode to the first input of $gs_projCamMix
   int $validateProj = 0;
   string $allProjections[];
   $allProjections = `listConnections -s on -d off -type "projection" $gs_projCamMix`;
   for ($n=0; $n<`size $allProjections`; $n++) {
      if ($allProjections[$n] == $mptk_projNode) $validateProj = 1;
   }
   string $testConnection[] = `listConnections -s on -d off ($gs_projCamMix+".images[0].color")`;
   if (`size $testConnection` && ($validateProj == 0) ) {
      $mptk_projNode = $testConnection[0];
   }

   // now check to see if geo assigned, and get the shading engine

   int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMix);
   string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
   string $shadingEngine, $surfaceShader, $src[];
   if ($allObjs[0] != "") {
     string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
     string $currentShaders[], $allShaders[];
     clear $allShaders;
     for ($x=0; $x<`size $allDescendents`; $x++){
       $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
       $allShaders = stringArrayCatenate($allShaders, $currentShaders);
       $allShaders = stringArrayRemoveDuplicates($allShaders);
     }
     $shadingEngine = $allShaders[0];
   }
   if ($shadingEngine == "") // if no geo or assigned shading engine
   {
     // find all shading engines assigned to gs_projCamMix
     string $shadEngine[];
     clear $src;
     $src[0] = $gs_projCamMix;
     while (`size $src`) {
        //step through chain
        $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
        if (`size $shadEngine`) break;
        $src = `listConnections -s off -d on -scn 1 $src`;
     }
     $shadingEngine = $shadEngine[0];
   }
   if ($shadingEngine == "") // if still no assigned shading engine, create one
   {
     $shadingEngine = `sets -renderable true -noSurfaceShader true -empty -name gs_mptkSG`;
   }
   // now get surfaceShader assigned to shading engine
   clear $src;
   $src = `listConnections -s on -d off -p 1 ($shadingEngine+".miMaterialShader")`;
   if (!`size $src`) // if no connection to .miMaterialShader, create gs_const and connect
   {
   print "No surface shader found. Creating gs_const and connecting.\n";
         $surfaceShader = `shadingNode -asShader gs_const`;
   //connectAttr -f ($surfaceShader+".outValue") ($shadingEngine+".miMaterialShader");
   connectAttr -f ($gs_projCamMix+".outColor") ($surfaceShader+".color");
   if (`nodeType $surfaceShader` == "gs_const") connectAttr -f ($gs_projCamMix+".outAlpha") ($surfaceShader+".opacity");
   //if (`nodeType $surfaceShader` == "gs_const") setAttr ($surfaceShader+".custom_alpha") 1;
   $surfaceShader = ($surfaceShader+".outValue"); // include plug
     
   }else{
  $surfaceShader = $src[0];
   }
   
   // now work on viewport shader
   string $viewportProj[] = `listConnections -s on -d off -t gs_viewportProj $shadingEngine`;
   if (!`size $viewportProj`) { // if no viewportProj shader, create one
      $viewportProj[0] = `shadingNode -asShader gs_viewportProj`;
   } else { // clear all connections
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".color6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".color6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".camInverseMatrix6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".camInverseMatrix6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".focalLength6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".focalLength6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vOffset6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vOffset6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hOffset6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hOffset6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".vAperture6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".vAperture6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".hAperture6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".hAperture6");

     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit0")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit0");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit1")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit1");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit2")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit2");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit3")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit3");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit4")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit4");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit5")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit5");
     string $breakConnection[] = `listConnections -s on -d off -p 1 ($viewportProj[0]+".filmFit6")`;
     if (`size $breakConnection`) disconnectAttr $breakConnection[0] ($viewportProj[0]+".filmFit6");
  }
   
   // first connect viewport shader, then connect gs_projCamMix
   if (! `isConnected ($viewportProj[0]+".outColor") ($shadingEngine+".surfaceShader")`) connectAttr -f ($viewportProj[0]+".outColor") ($shadingEngine+".surfaceShader");
   if (! `isConnected $surfaceShader ($shadingEngine+".miMaterialShader")`) connectAttr -f $surfaceShader ($shadingEngine+".miMaterialShader");
    
   
  // now connect file to viewport projection
  int $doMultiTexture = `getAttr ($viewportProj[0]+".layeredTexture")`;
  if (!$doMultiTexture) {
     string $file[] = `listConnections -s on -d off -t file $mptk_projNode`; // the file connected to the active projection
     if (`size $file`) {
        if (!`isConnected ($file[0]+".outColor") ($viewportProj[0]+".color0")`) connectAttr -force ($file[0]+".outColor") ($viewportProj[0]+".color0");
     }
     string $mptk_currentProjCamera = `button -q -l (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_projAttrsCameraBtn")`;
     string $mptk_currentProjCameraList[] = `listConnections -s on -d off ($mptk_projNode+".linkedCamera")`;
     if (`size $mptk_currentProjCameraList`){
        // if there's a camera connected to the projection node, use it.  We do this to fix a bug when loading the UI with multiple gs_projCamMix nodes in the scene.
        $mptk_currentProjCamera = $mptk_currentProjCameraList[0];
     }
     if ($mptk_currentProjCamera != "None") {
        if (!`isConnected ($mptk_currentProjCamera+".worldInverseMatrix[0]") ($viewportProj[0]+".camInverseMatrix0")`) connectAttr -force ($mptk_currentProjCamera+".worldInverseMatrix[0]") ($viewportProj[0]+".camInverseMatrix0");
        if (!`isConnected ($mptk_currentProjCamera+".focalLength") ($viewportProj[0]+".focalLength0")`) connectAttr -force ($mptk_currentProjCamera+".focalLength") ($viewportProj[0]+".focalLength0");
        if (!`isConnected ($mptk_currentProjCamera+".verticalFilmOffset") ($viewportProj[0]+".vOffset0")`) connectAttr -force ($mptk_currentProjCamera+".verticalFilmOffset") ($viewportProj[0]+".vOffset0");
        if (!`isConnected ($mptk_currentProjCamera+".horizontalFilmOffset") ($viewportProj[0]+".hOffset0")`) connectAttr -force ($mptk_currentProjCamera+".horizontalFilmOffset") ($viewportProj[0]+".hOffset0");
        if (!`isConnected ($mptk_currentProjCamera+".verticalFilmAperture") ($viewportProj[0]+".vAperture0")`) connectAttr -force ($mptk_currentProjCamera+".verticalFilmAperture") ($viewportProj[0]+".vAperture0");
        if (!`isConnected ($mptk_currentProjCamera+".horizontalFilmAperture") ($viewportProj[0]+".hAperture0")`) connectAttr -force ($mptk_currentProjCamera+".horizontalFilmAperture") ($viewportProj[0]+".hAperture0");
        if (!`isConnected ($mptk_currentProjCamera+".filmFit") ($viewportProj[0]+".filmFit0")`) connectAttr -force ($mptk_currentProjCamera+".filmFit") ($viewportProj[0]+".filmFit0"); 
     }
  } else { // do multitexturing
      int $activeProj = gs_mptk_getActiveProjIndex($gs_projCamMix);
      int $numProjections = gs_projCamMix_query_num($gs_projCamMix);
      $numProjections -= 1;
      int $endProjIndex = $numProjections;
      $numProjections -= $activeProj;
      if ($numProjections >= 7) $numProjections = 6;
      //string $mptk_activeTabLabel = gs_mptk_getActiveMixNode();
      int $tabNum = gs_mptk_getUITabNumFromMixNode($gs_projCamMix);
      int $count = 0;
      for ($i=$numProjections; $i>=0; $i--){
         
          // reverse inputs because gs_viewportProj works in opposite order
         if ($activeProj > $endProjIndex) break; //escape if we're beyond the last projection in the list
         $mptk_projNode = `textField -q -tx (("mptk_UI_tabs_child_" + $tabNum)+"_mptk_UI_projName"+$activeProj)`;

         string $file[] = `listConnections -s on -d off -t file $mptk_projNode`; // the file connected to the active projection
         if (`size $file`) {
            if (!`isConnected ($file[0]+".outColor") ($viewportProj[0]+".color"+$i)`) connectAttr -force ($file[0]+".outColor") ($viewportProj[0]+".color"+$i);
         }
         string $mptk_currentProjCamera[] = `listConnections -s on -d off -type "camera" $mptk_projNode`;
         if ($mptk_currentProjCamera[0] != "") {
            if (!`isConnected ($mptk_currentProjCamera[0]+".worldInverseMatrix[0]") ($viewportProj[0]+".camInverseMatrix"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".worldInverseMatrix[0]") ($viewportProj[0]+".camInverseMatrix"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".focalLength") ($viewportProj[0]+".focalLength"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".focalLength") ($viewportProj[0]+".focalLength"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".verticalFilmOffset") ($viewportProj[0]+".vOffset"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".verticalFilmOffset") ($viewportProj[0]+".vOffset"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".horizontalFilmOffset") ($viewportProj[0]+".hOffset"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".horizontalFilmOffset") ($viewportProj[0]+".hOffset"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".verticalFilmAperture") ($viewportProj[0]+".vAperture"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".verticalFilmAperture") ($viewportProj[0]+".vAperture"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".horizontalFilmAperture") ($viewportProj[0]+".hAperture"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".horizontalFilmAperture") ($viewportProj[0]+".hAperture"+$i);
            if (!`isConnected ($mptk_currentProjCamera[0]+".filmFit") ($viewportProj[0]+".filmFit"+$i)`) connectAttr -force ($mptk_currentProjCamera[0]+".filmFit") ($viewportProj[0]+".filmFit"+$i);
         }
         $activeProj ++;
      }
  }   
};


global proc gs_mptk_loadMatteAttrs (string $gs_projCamMixNode, string $mptk_projNode, int $mptk_numProjections, int $mptk_projCamMixNum, int $mptk_numProj) {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_loadMatteAttrs\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
    // restore all bgkgnd to default (no highlight)
   
   
    for ($n=0; $n<$mptk_numProjections; $n++){
       formLayout -e -bgc .2 .2 .2 -ebg 1 (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_matteAttrsBkgnd"+$n);
    }
     
    formLayout -e -bgc .5 .5 .5 -ebg 1 (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_matteAttrsBkgnd"+$mptk_numProj);
     
    if (`objExists $mptk_projNode`) select $mptk_projNode;

}

global proc gs_mptk_addProjNetwork( string $gs_projCamMixNode, string $mptk_projNode, int $mptk_numProjections, int $mptk_projCamMixNum, int $mptk_numProj ){
   
  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_addProjNetwork\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
     
   string $selection[] = `ls -sl`;

   // commented due to new add proj code that finds the first empty index, then reorders accordingly, instead of using sloppy AEnewNonNumeric command
   //string $indexToNameMapping = gs_indexToNameMapping($gs_projCamMixNode, $mptk_numProj);    

   // create projection node
   $projNode = `shadingNode -asUtility projection`;
   setAttr ($projNode+".projType") 8;
   setAttr ($projNode+".fitType") 1;
   setAttr ($projNode+".defaultColor") -type double3 0 0 0;
   
   // create mask projection node
   $maskProjNode = `shadingNode -asUtility projection`;
   setAttr ($maskProjNode+".projType") 8;
   setAttr ($maskProjNode+".fitType") 1;
   setAttr ($maskProjNode+".defaultColor") -type double3 0 0 0;
   
   // create ramp
   $ramp = `shadingNode -asTexture ramp`;

   setAttr ($ramp +".colorEntryList[0].color") -type double3 1 1 1 ;
   setAttr ($ramp +".colorEntryList[1].color") -type double3 1 1 1 ;
   setAttr ($ramp +".colorEntryList[2].color") -type double3 1 1 1 ;
   setAttr ($ramp +".defaultColor")  -type double3 0 0 0 ;
   
   // create file texture
   string $file = `shadingNode -asTexture file`;
   setAttr ($file+".defaultColor") -type double3 0 0 0 ;
   setAttr ($file+".filterType") 0;
   //setAttr ($file+".miUseEllipticalFilter") 1;
   
   // create place2dTextures
   string $place2d = `shadingNode -asUtility place2dTexture`;
   setAttr ($place2d+".wrapU") 0;
   setAttr ($place2d+".wrapV") 0;
   string $place2dramp = `shadingNode -asUtility place2dTexture`;
   setAttr ($place2dramp+".wrapU") 0;
   setAttr ($place2dramp+".wrapV") 0;
   
   // connect attributes
   connectAttr -f ($place2d+".coverage") ($file+".coverage");
   connectAttr -f ($place2d+".translateFrame") ($file+".translateFrame");
   connectAttr -f ($place2d+".rotateFrame") ($file+".rotateFrame");
   connectAttr -f ($place2d+".mirrorU") ($file+".mirrorU");
   connectAttr -f ($place2d+".mirrorV") ($file+".mirrorV");
   connectAttr -f ($place2d+".stagger") ($file+".stagger");
   connectAttr -f ($place2d+".wrapU") ($file+".wrapU");
   connectAttr -f ($place2d+".wrapV") ($file+".wrapV");
   connectAttr -f ($place2d+".repeatUV") ($file+".repeatUV");
   connectAttr -f ($place2d+".offset") ($file+".offset");
   connectAttr -f ($place2d+".rotateUV") ($file+".rotateUV");
   connectAttr -f ($place2d+".noiseUV") ($file+".noiseUV");
   connectAttr -f ($place2d+".vertexUvOne") ($file+".vertexUvOne");
   connectAttr -f ($place2d+".vertexUvTwo") ($file+".vertexUvTwo");
   connectAttr -f ($place2d+".vertexUvThree") ($file+".vertexUvThree");
   connectAttr -f ($place2d+".vertexCameraOne") ($file+".vertexCameraOne");
   connectAttr ($place2d+".outUV") ($file+".uv");
   connectAttr ($place2d+".outUvFilterSize") ($file+".uvFilterSize");
   
   // connect ramp
   connectAttr -f ($place2dramp+".outUV") ($ramp+".uvCoord");  
   connectAttr -f ($place2dramp+".outUvFilterSize") ($ramp+".uvFilterSize");
   connectAttr -force ($ramp+".outColor") ($maskProjNode+".image");

   connectAttr -force ($file+".outColor") ($projNode+".image");
   
   // connect image projection and ramp to gs_projCamMix
   connectAttr -f ($projNode+".outColor") ($gs_projCamMixNode+".images["+$mptk_numProj+"].color");
   connectAttr -f ($maskProjNode+".outAlpha") ($gs_projCamMixNode+".images["+$mptk_numProj+"].mask");
   
   

}


global proc gs_createCoverageMap () {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_createCoverageMap\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
       
   // vars
   string $dupCams[];
   string $camShape[];
   string $allDupCams[];
   string $allProjNodes[];
   
   // get camera to duplicate and error check selection
   
   string $sel[] = `ls -sl`;
   if (`size $sel` <= 1) error "Select first one animated camera, then the geometry to receive the coverage map.";
   
   if (`objectType -i transform $sel[0]`){
       $camShape = `listRelatives -s $sel[0]`;
       if (!`objectType -i camera $camShape[0]`) error "Select first one animated camera, then the geometry to receive the coverage map.";
   }else{
       error "Select first one animated camera, then the geometry to receive the coverage map.";
   }
   
   // get current time range
   int $timeStart = `playbackOptions -q -min`;
   int $timeEnd = `playbackOptions -q -max`;
   int $timeTotalFrames = $timeEnd - $timeStart + 1;
   int $currentTime = `currentTime -q`;
   
   
   // start at first frame of time range
   currentTime -e $timeStart;
   
   // store assigned materials for later
   /*
   string $curFaces[];
   string $assignCmd[];
   clear $curFaces;
   clear $assignCmd;
   
   
   for ($n=1; $n<`size $sel`; $n++){
       string $assignedShaders[] = `listSets -ets -t 1 -o $sel[$n]`;
       
       for ($x=0; $x<`size $assignedShaders`; $x++){
           $curFaces = `sets -q $assignedShaders[$x] $sel[$n]`;
           int $num = `size $curFaces`;
       
           for ($y=0; $y<`size $curFaces`; $y++){
               $curFaces[$y] = ("sets -edit -forceElement " + $assignedShaders[$x] + " " + $curFaces[$y]);
               //$assignCommand[$y] = ("sets -edit -forceElement " + $curFaces[$y]);
           }
           appendStringArray ($assignCmd, $curFaces, $num);
       }
   }*/
   
   
   string $allDescendents[] = `listRelatives -ad $sel`;
   string $currentShaders[], $allShaders[];
   clear $allShaders;
   for ($x=0; $x<`size $allDescendents`; $x++){
       $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
       $allShaders = stringArrayCatenate($allShaders, $currentShaders);
       $allShaders = stringArrayRemoveDuplicates($allShaders);
   }
   string $assignCmd[], $assignedGeo[];
   for ($x=0; $x<`size $allShaders`; $x++){
       $assignedGeo = `sets -q $allShaders[$x]`;
       string $printGeo = stringArrayToString ($assignedGeo, " ");
       $assignCmd[$x] = ("sets -e -forceElement " + $allShaders[$x] + " " + $printGeo);
   }
   
   
   // create Average Node
   string $avgNode = `shadingNode -asUtility plusMinusAverage`;
   setAttr ($avgNode+".operation") 3;
   
   // create ramp
   string $ramp = `shadingNode -asTexture ramp`;
   string $place2d = `shadingNode -asUtility place2dTexture`;
   
   setAttr ($ramp +".colorEntryList[0].color") -type double3 1 1 1 ;
   setAttr ($ramp +".colorEntryList[1].color") -type double3 1 1 1 ;
   setAttr ($ramp +".colorEntryList[2].color") -type double3 1 1 1 ;
   setAttr ($ramp +".defaultColor")  -type double3 0 0 0 ;
   
   connectAttr ($place2d+".outUV") ($ramp+".uv");
   connectAttr ($place2d+".outUvFilterSize") ($ramp+".uvFilterSize");
   setAttr ($place2d+".wrapU") 0;
   setAttr ($place2d+".wrapV") 0;
   
   // create surface shader
   string $surfaceShader = `shadingNode -asShader surfaceShader`;
   
   // loop over time range
   for ($x=0; $x<$timeTotalFrames; $x++){
       $dupCams = `duplicate $sel[0]`;
       $camShape = `listRelatives -s $dupCams[0]`;
       // create projection node
       string $projNode = `shadingNode -asUtility projection`;
       setAttr ($projNode+".projType") 8;
       setAttr ($projNode+".fitType") 2;
       setAttr ($projNode+".defaultColor") -type double3 0 0 0;
       // link duped camera
       connectAttr -force ($camShape[0]+".message") ($projNode+".linkedCamera");
       //linkProjToCamera ($projNode+".linkedCamera");
       // connect ramp to projNode
       connectAttr -force ($ramp+".outColor") ($projNode+".image");
       // add projNode to avgNode
       connectAttr -force ($projNode+".outColor") ($avgNode+".input3D["+$x+"]");
       
       $allDupCams[$x] = $dupCams[0];
       $allProjNodes[$x] = $projNode;
   currentTime -e (`currentTime -q` + 1);
   }
   
   // connect avgNode to surfaceShader
   connectAttr -force ($avgNode+".output3D") ($surfaceShader+".outColor");
   
   // assign surface shader to geometry
   string $shadGroup = `sets -renderable true -noSurfaceShader true -empty -name ($surfaceShader+"SG")`;
   connectAttr -f ($surfaceShader+".message") ($shadGroup+".surfaceShader");
   
   for ($y=1; $y<`size $sel`; $y++){
       sets -edit -forceElement $shadGroup $sel[$y];
   }
   
   // render with current settings
   RenderIntoNewWindow;
   
   // clean up
   delete $allDupCams;
   delete $avgNode;
   delete $ramp;
   delete $place2d;
   delete $allProjNodes;
   delete $surfaceShader;
   
   // assign original shaders
   for ($x=0; $x<`size $assignCmd`; $x++){
       eval $assignCmd[$x];
   }
   
   currentTime -e $currentTime;

}

global proc gs_mptk_enableFacingRatio() {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_enableFacingRatio\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

   string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
   if ($gs_projCamMixNode != "") {
       int $x = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
       string $facingAttr = `attrControlGrp -q -a (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsUseFacingRatio")`;

       if ( `getAttr $facingAttr` ) {
           attrFieldSliderGrp -e -en 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsAngleThreshold");
       }else{
           attrFieldSliderGrp -e -en 0 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsAngleThreshold");
       }
   }
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        int $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].useFacingRatio")`;
        setAttr ($occlusionMatte[0]+".useFacingRatio") $value;
      }
  }
}
       
global proc gs_mptk_enableShadowOcclusion() {

    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_enableShadowOcclusion\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

   string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
   if ($gs_projCamMixNode != "") {
       int $x = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
       string $shadowOcclusionAttr = `attrControlGrp -q -a (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsUseShadowOcclusion")`;
       if ( `getAttr $shadowOcclusionAttr` ) {
           attrFieldSliderGrp -e -en 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsDilate");
           attrFieldSliderGrp -e -en 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSamples");
           attrFieldSliderGrp -e -en 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSoftEdge");
           attrFieldSliderGrp -e -en 1 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsPower");
           // force gs_const opacity to 1 due to Maya/MR bug with multiple outputs causing invalid data be passed to RGB, alpha
           string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
           string $gs_constNode[] = `listConnections -s off -d on -t gs_const ($gs_projCamMixNode+".outAlpha")`;
           for ($x=0; $x<`size $gs_constNode`; $x++){
               disconnectAttr ($gs_projCamMixNode+".outAlpha") ($gs_constNode[$x]+".opacity");
               setAttr ($gs_constNode[$x]+".opacity") 1;
           }
       }else{
           attrFieldSliderGrp -e -en 0 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsDilate");
           attrFieldSliderGrp -e -en 0 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSamples");
           attrFieldSliderGrp -e -en 0 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsSoftEdge");
           attrFieldSliderGrp -e -en 0 (("mptk_UI_tabs_child_" + $x)+"_mptk_projAttrsPower");
           // set gs_const opacity back to gs_projCamMix.outAlpha output
           string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
           string $gs_constNode[] = `listConnections -s off -d on -t gs_const ($gs_projCamMixNode+".outColor")`;
           for ($x=0; $x<`size $gs_constNode`; $x++){
               catchQuiet (`connectAttr -f ($gs_projCamMixNode+".outAlpha") ($gs_constNode[$x]+".opacity")`);
           }
       }
   }
   // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        int $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].useShadowOcclusion")`;
        setAttr ($occlusionMatte[0]+".useShadowOcclusion") $value;
      }
  }
}           

global proc gs_mptk_changeDistanceThreshold(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeDistanceThreshold\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        float $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].distanceThreshold")`;
        setAttr ($occlusionMatte[0]+".distanceThreshold") $value;
      }
  }
}

global proc gs_mptk_changeDilate(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeDilate\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        float $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].dilate")`;
        setAttr ($occlusionMatte[0]+".dilate") $value;
      }
  }
}

global proc gs_mptk_changeSamples(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeSamples\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        int $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].samples")`;
        setAttr ($occlusionMatte[0]+".samples") $value;
      }
  }
}

global proc gs_mptk_changeSoftEdge(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeSoftEdge\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        float $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].softEdge")`;
        setAttr ($occlusionMatte[0]+".softEdge") $value;
      }
  }
}

global proc gs_mptk_changePower(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changePower\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        float $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].power")`;
        setAttr ($occlusionMatte[0]+".power") $value;
      }
  }
}

global proc gs_mptk_changeAngleThreshold(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeAngleThreshold\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        float $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].angleThreshold")`;
        setAttr ($occlusionMatte[0]+".angleThreshold") $value;
      }
  }
}

global proc gs_mptk_changeLabelExclude(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changeLabelExclude\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        int $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].labelExclude")`;
        setAttr ($occlusionMatte[0]+".labelExclude") $value;
      }
  }
}
global proc gs_mptk_changePremult(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_changePremult\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
  // update VRay occlusion Shader
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
      string $activeProjNode = gs_mptk_getActiveProjNode();
      string $activeMixNode = gs_mptk_getActiveMixNode();
      int $activeIndex = gs_mptk_getActiveProjIndex($activeMixNode);
      int $indexNameMapping = gs_indexToNameMapping($activeMixNode, $activeIndex);

      string $occlusionMatte[] = `listConnections -s off -d on -t gs_occlusionMatteVRay $activeProjNode`;
      if (`size $occlusionMatte`) {
        // if we've found the occlusionMatte node, get gs_projCamMix value and set 
        //print("occlusionMatte: "+$occlusionMatte[0]+"\n");
        int $value = `getAttr ($activeMixNode+".images["+$indexNameMapping+"].premult")`;
        setAttr ($occlusionMatte[0]+".premult") $value;
      }
  }
}



global proc gs_mptk_sRGBtoggle() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_sRGBToggle\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

   string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
   if ($gs_projCamMixNode != "") {
     
       int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
       
       string $viewportProj[];
       
       // get viewport shader
       
     string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
     string $shadingEngine, $surfaceShader, $src[];
     if ($allObjs[0] != "") {
       string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
       string $currentShaders[], $allShaders[];
       clear $allShaders;
       for ($x=0; $x<`size $allDescendents`; $x++){
         $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
         $allShaders = stringArrayCatenate($allShaders, $currentShaders);
         $allShaders = stringArrayRemoveDuplicates($allShaders);
       }
       $shadingEngine = $allShaders[0];
     }
     if ($shadingEngine == "") // if no geo or assigned shading engine
     {
       // find all shading engines assigned to gs_projCamMix
       string $shadEngine[];
       clear $src;
       $src[0] = $gs_projCamMixNode;
       while (`size $src`) {
          //step through chain
          $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
          if (`size $shadEngine`) break;
          $src = `listConnections -s off -d on -scn 1 $src`;
       }
       $shadingEngine = $shadEngine[0];
     }
     if ($shadingEngine != "")
     {
       $viewportProj = `listConnections -s on -d off ($shadingEngine+".surfaceShader")`;
     }
       
       int $toggleOn = `menuItem -q -cb gs_mptk_viewport`;
       if ($toggleOn) {
        if ($viewportProj[0] != "" && (`nodeType $viewportProj` == "gs_viewportProj") ) setAttr ($viewportProj[0]+".viewportLinToVid") 1;
       } else {
        if ($viewportProj[0] != "" && (`nodeType $viewportProj` == "gs_viewportProj") ) setAttr ($viewportProj[0]+".viewportLinToVid") 0;
       }
     
   }
    
}

global proc gs_mptk_layeredProjToggle() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_layeredProjToggle\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
   if ($gs_projCamMixNode != "") {
     
       int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode($gs_projCamMixNode);
       
       string $viewportProj[];
       
       // get viewport shader
       
     string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
     string $shadingEngine, $surfaceShader, $src[];
     if ($allObjs[0] != "") {
       string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
       string $currentShaders[], $allShaders[];
       clear $allShaders;
       for ($x=0; $x<`size $allDescendents`; $x++){
         $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
         $allShaders = stringArrayCatenate($allShaders, $currentShaders);
         $allShaders = stringArrayRemoveDuplicates($allShaders);
       }
       $shadingEngine = $allShaders[0];
     }
     if ($shadingEngine == "") // if no geo or assigned shading engine
     {
       // find all shading engines assigned to gs_projCamMix
       string $shadEngine[];
       clear $src;
       $src[0] = $gs_projCamMixNode;
       while (`size $src`) {
          //step through chain
          $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
          if (`size $shadEngine`) break;
          $src = `listConnections -s off -d on -scn 1 $src`;
       }
       $shadingEngine = $shadEngine[0];
     }
     if ($shadingEngine != "")
     {
       $viewportProj = `listConnections -s on -d off ($shadingEngine+".surfaceShader")`;
     }
       
       int $toggleOn = `menuItem -q -cb gs_mptk_layered`;
       if ($toggleOn) {
        if ($viewportProj[0] != "" && (`nodeType $viewportProj` == "gs_viewportProj") ) setAttr ($viewportProj[0]+".layeredTexture") 1;
       } else {
        if ($viewportProj[0] != "" && (`nodeType $viewportProj` == "gs_viewportProj") ) setAttr ($viewportProj[0]+".layeredTexture") 0;
       }
       string $activeProjNode = gs_mptk_getActiveProjNode();
       gs_mptk_viewportSetup($gs_projCamMixNode, $activeProjNode);
   }
}


global proc int importFile( string $filename, string $fileType, int $imageSize, float $sensorSizeW, float $sensorSizeH, int $stepSize, int $locators, int $doAutoImport, int $autoAlphaVal, int $useShadowOcclVal, int $useFacingRatioVal )
{
 
  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc importFile\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  if ($fileType == "Bundler Files") {

    string $contentsArray[];

    int $x=0;

    $fileId=`fopen $filename "r"`;
    string $nextLine = `fgetline $fileId`;
    clear $contentsArray;
    while ( size( $nextLine ) > 0 ) {

      $contentsArray[$x] = $nextLine; // first we fill the array with all lines
        $nextLine = `fgetline $fileId`;

      //print ($contentsArray[$x]+"\n");
      $x++;
    }
    fclose $fileId;
    
    string $importImages[];
    if ($doAutoImport) {
      string $singleFilter = "All Files (*.*)";
      $importImages = `fileDialog2 -fm 4 -ff $singleFilter -okc "Import" -cap "Select all images to auto assign to projection cameras."`;
    }

    importBundle($contentsArray, $imageSize, $sensorSizeW, $sensorSizeH, $doAutoImport, $autoAlphaVal, $useShadowOcclVal, $useFacingRatioVal, $importImages);
  
  }

  if ($fileType == "PLY") {

    string $contentsArray[];

    int $x=0;

    $fileId=`fopen $filename "r"`;
    string $nextLine = `fgetline $fileId`;
    clear $contentsArray;

    print ("Reading ply file...\n" );

    while ( size( $nextLine ) > 0 ) {

      $contentsArray[$x] = $nextLine; // first we fill the array with all lines
        $nextLine = `fgetline $fileId`;

      //print ($contentsArray[$x]+"\n");
      $x++;
    }
    fclose $fileId;

    print "Done reading ply file.\n";

      importPly($contentsArray, $locators, $stepSize);

  }


  return 1;

}



global proc importPly( string $contentsArray[], int $locators, int $stepSize ) {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc importPly\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  string $currentLine;  
  string $parseLine[];

  $currentLine = $contentsArray[0];
  $parseLine = stringToStringArray($currentLine, " ");
  
  int $totalLines = (`size $contentsArray` + "\n");

  int $beginPointRead = -1;

  for ($z = 0; $z < $totalLines; $z++) {
    $currentLine = $contentsArray[$z];
    if ($currentLine == "end_header\n" || $currentLine == "end_header") {
      $beginPointRead = $z;
      break;
    }
      
  }



  if ($beginPointRead < 0) {
    error "Could not determine ply format.\n";
  } else{
    
    int $numPoints = $totalLines - $beginPointRead;
    $beginPointRead++;
    int $x = 0;
    float $colorR[], $colorG[], $colorB[];
    

      print ("Creating point cloud with step size " + $stepSize + "...\n");
      $stepSize -= 1;
      
      string $createParticle = "particle -n \"plyPointCloud\"";
      
      timer -s;
      float $lastTime = 0.0;
      int $percent, $lastPercent;
      float $count = 0;
      float $pointsFloat = $numPoints;

      for ($z=$beginPointRead; $z < $totalLines; $z++) {
        $count += 1;
        $count += $stepSize;
        $percent = ($count/$pointsFloat) * 100;
        if ((`timer -lap` > ($lastTime + 2)) && ($percent != $lastPercent)) {
          print ($percent+"%\n");
          $lastTime = `timer -lap`;
          $lastPercent = $percent;
        }


        $currentLine = $contentsArray[$z];
        $parseLine = stringToStringArray($currentLine, " ");
        $transX = $parseLine[0];
        $transY = $parseLine[1];
        $transZ = $parseLine[2];
        
        // get color
        $currentLine = $contentsArray[$z];
        $parseLine = stringToStringArray($currentLine, " ");
        $colorR[$x] = $parseLine[6];
        $colorG[$x] = $parseLine[7];
        $colorB[$x] = $parseLine[8];
        
        // create particle command
        $createParticle = ($createParticle + " -p " + $transX + " " + $transY + " " + $transZ);

        if ($locators) {
          //create locator
          spaceLocator;
          scale -r 0.01 0.01 0.01 ;
          move -a $transX $transY $transZ ;
        }
        
        $z += $stepSize;
        $x++;
        
      }

      timer -e;
      print "100%\n";
      print "Creating particle shape from point cloud...\n";


      // create particleShape
      string $partShape[] = `eval $createParticle`;

      $partShape = `listRelatives -s`;

      addAttr -ln "rgbPP" -dt vectorArray $partShape[0];
      addAttr -ln "rgbPP0" -dt vectorArray $partShape[0];

      for ($z=0; $z<`size $colorR`; $z++){
        select($partShape[0]+".pt["+$z+"]");
        setParticleAttr -vv ($colorR[$z]/255) ($colorG[$z]/255) ($colorB[$z]/255) -at rgbPP ;
        setParticleAttr -vv ($colorR[$z]/255) ($colorG[$z]/255) ($colorB[$z]/255) -at rgbPP0 ;
        
      }
      setAttr ($partShape[0]+".particleRenderType") 5;
      
      // optional set parameters for particle shape
      setPartiShapeParams ($partShape[0]);

      print ("Point cloud created successfully.\nImport complete.\n");


  
  }


}

global proc importBundle(string $contentsArray[], int $imageSize, float $sensorSizeW, float $sensorSizeH, int $doAutoImport, int $autoAlphaVal, int $useShadowOcclVal, int $useFacingRatioVal, string $importImages[]) {
 

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc importBundle\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  global string $gMainProgressBar;

    progressBar -edit
        -beginProgress
        -isInterruptable true
        -status "Importing Bundle..."
        -maxValue 5000
        $gMainProgressBar;



  string $currentLine;  
  string $parseLine[];

  $currentLine = $contentsArray[1];
  $parseLine = stringToStringArray($currentLine, " ");

  int $numCams = $parseLine[0];
  int $numPoints = $parseLine[1];
  
  print ("total cameras: " + $numCams +"\n");
  print ("total points: " + $numPoints +"\n");

  if (($doAutoImport) && ($numCams != `size $importImages`)) {
    string $continueAnyway = `confirmDialog -title "Confirm" -message "Number of cameras in dataset does not equal number of selected images. Continue anyway?" -button "Yes" -button "No" -defaultButton "No" -cancelButton "No" -dismissString "No"`;
    if ($continueAnyway == "No") error "Import aborted.";
  }
  
  float $focalLength, $distortionX, $distortionY, $rot0, $rot1, $rot2, $rot3, $rot4, $rot5, $rot6, $rot7, $rot8, $transX, $transY, $transZ;

  //convert CCD mm to in for maya cameras
  $sensorSizeW *= 0.0393700787;
  $sensorSizeH *= 0.0393700787;

  int $y=2;
  
  progressBar -edit -status "Getting camera info..." $gMainProgressBar;

  // use decompose matrix to figure out accurate rotations
  if (!`pluginInfo -q -l decomposeMatrix`) loadPlugin decomposeMatrix;
  string $decomp = `shadingNode -asUtility decomposeMatrix`;
    
  for ($x=0; $x < $numCams; $x++) {

    if(`progressBar -query -isCancelled $gMainProgressBar`)
              break;

    progressBar -edit
            -step 1 $gMainProgressBar; 
    // cam data - focal length, radial distortion
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    
    $focalLength = $parseLine[0];
    $distortionX = $parseLine[1];
    $distortionY = $parseLine[2];
    
    // rotation data
    $y++;
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $rot0 = $parseLine[0];
    $rot1 = $parseLine[1];
    $rot2 = $parseLine[2];
    $y++;
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $rot3 = $parseLine[0];
    $rot4 = $parseLine[1];
    $rot5 = $parseLine[2];
    $y++;
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $rot6 = $parseLine[0];
    $rot7 = $parseLine[1];
    $rot8 = $parseLine[2];
    
    // translation data
    $y++;
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $transX = $parseLine[0];
    $transY = $parseLine[1];
    $transZ = $parseLine[2];
    $y++;
    
    
    if ($focalLength == 0) {
      print ("Camera number "+($x+1)+" has focal length of zero, skipping.\n"); 
    }else{  
    
    
        $focalLength = $focalLength / $imageSize * ($sensorSizeW * 25.4);  // pixelFocal / imageWidth * CCDWidth = mmFocal

        string $cameraName[] = `camera`;
        rename $cameraName[0] ("cam"+($x+1));
        clear $cameraName;
        $cameraName = `ls -sl`;
        string $cameraShape[] = `listRelatives -s $cameraName`;

        print ("Creating "+$cameraName[0]+"\n");

        camera -e -centerOfInterest 5 -focalLength $focalLength -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture $sensorSizeW -horizontalFilmOffset 0 -verticalFilmAperture $sensorSizeH -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 180 -nearClipPlane .1 -farClipPlane 9999999 -orthographic 0 -orthographicWidth 30 $cameraName[0];
        //objectMoveCommand; 
        //cameraMakeNode 1 "";
        
      
        ////////// do rotation //////////
        
        float $m00 = $rot0;
        float $m01 = $rot1;
        float $m02 = $rot2;
        float $m03 = 0.0;
        float $m10 = $rot3;
        float $m11 = $rot4;
        float $m12 = $rot5;
        float $m13 = 0.0;
        float $m20 = $rot6;
        float $m21 = $rot7;
        float $m22 = $rot8;
        float $m23 = 0.0;
        float $m30 = $transX;
        float $m31 = $transY;
        float $m32 = $transZ;
        float $m33 = 1.0;     
        
        //  USE IF ROTATIONS HAVE XYZ MULTIPLICATION ORDER
        //float $angles[];
        //clear $angles;
        //$angles[0] = atan2(-$m21,$m22);
        //$angles[1] = asin($m20);
        //$angles[2] = atan2(-$m10,$m00);
        //$angles[0] = `rad_to_deg $angles[0]`;
        //$angles[1] = `rad_to_deg $angles[1]`;
        //$angles[2] = `rad_to_deg $angles[2]`;
        
        ///  USE FOR MAYA, SINCE MAYA HAS ZYX MULTIPLICATION ORDER  
        ///// Column Major considering Z, Y, X matrix (3x3) multiplication order (Without singularities treatment)
        
        float $sin_Y = -$m02;

        float $maya_angles[];
        if ($sin_Y > 1.0) $sin_Y = 1.0;
        $maya_angles[1] = asin($sin_Y);
        
        float $cos_Y = cos($maya_angles[1]);
        
        // 1st Quarter and 4th Quarter Mapped
        float $sin_X = $m12 / $cos_Y;
        float $cos_X = $m22 / $cos_Y;
        if ($sin_X > 1.0) $sin_X = 1.0;
        $maya_angles[0] = asin($sin_X);
        
        float $PI = 3.14159265358979323846264338327950288;
        
        if( $cos_X < 0.0 )
        {
          // 2nd Quarter
          if( $sin_X > 0.0 )
          {
            $maya_angles[0] = $maya_angles[0] + $PI / 2;
          }
          else // 3rd Quarter
          {
            $maya_angles[0] =  $PI + abs($maya_angles[0]);
          }
        }
        
        // 1st Quarter and 4th Quarter Mapped
        float $sin_Z = $m01 / $cos_Y;
        float $cos_Z = $m00 / $cos_Y;
        if ($sin_Z > 1.0) $sin_Z = 1.0;
        $maya_angles[2] = asin($sin_Z);
        
        if( $cos_Z < 0.0 )
        {
          // 2st Quarter
          if( $sin_Z > 0.0 )
          {
            $maya_angles[2] = $maya_angles[2] + $PI / 2;
          }
          else // 3rd Quarter
          {
            $maya_angles[2] =  $PI + abs($maya_angles[2]);
          }
        }
        
        // using threshold test //        
        float $test = ($sin_Z * $sin_X + $sin_Y * $cos_Z * $cos_X) - $m20;
        if( !(abs($test) < 0.00001) )
        {
        $cos_Y = -$cos_Y;
        
        if( $cos_Y < 0.0 )
        {
        // 2st Quarter
        if( $sin_Y > 0.0 )
        {
        $maya_angles[1] = $maya_angles[1] + $PI / 2;
        }
        else // 3rd Quarter
        {
        
        $maya_angles[1] =  $PI + abs($maya_angles[1]);
        
        }
        }
        
        // 1st Quarter and 4th Quarter Mapped
        $sin_X = $m12 / $cos_Y;
        $cos_X = $m22 / $cos_Y;
        if ($sin_X > 1.0) $sin_X = 1.0;
        $maya_angles[0] = asin($sin_X);
        
        if( $cos_X < 0.0 )
        {
        // 2st Quarter
        if( $sin_X > 0.0 )
        {
        $maya_angles[0] = $maya_angles[0] + $PI / 2;
        }
        else // 3rd Quarter
        {
        
        $maya_angles[0] =  $PI + abs($maya_angles[0]);
        
        }
        }
        
        // 1st Quarter and 4th Quarter Mapped
        $sin_Z = $m01 / $cos_Y;
        $cos_Z = $m00 / $cos_Y;
        if ($sin_Z > 1.0) $sin_Z = 1.0;
        $maya_angles[2] = asin($sin_Z);
        
        if( $cos_Z < 0.0 )
        {
        // 2st Quarter
        if( $sin_Z > 0.0 )
        {
        $maya_angles[2] = $maya_angles[2] + $PI / 2;
        }
        else // 3rd Quarter
        {
        $maya_angles[2] =  $PI + abs($maya_angles[2]);


        }
        }
        }


                      
        // deprecated--now using decompose matrix to figure out rotations
        //$maya_angles[0] = `rad_to_deg $maya_angles[0]`;
        //$maya_angles[1] = `rad_to_deg $maya_angles[1]`;
        //$maya_angles[2] = `rad_to_deg $maya_angles[2]`;
        //setAttr ("cam"+($x+1)+".rotateX") $maya_angles[0];
        //setAttr ("cam"+($x+1)+".rotateY") $maya_angles[1];
        //setAttr ("cam"+($x+1)+".rotateZ") $maya_angles[2];

        ////////// do translation //////////
        
        float $final_pos_x = -($m00 * $transX + $m10 * $transY + $m20 * $transZ);
        float $final_pos_y = -($m01 * $transX + $m11 * $transY + $m21 * $transZ);
        float $final_pos_z = -($m02 * $transX + $m12 * $transY + $m22 * $transZ);
        
        setAttr ($decomp+".inputMatrix") -type "matrix" $m00 $m01 $m02 $m03 $m10 $m11 $m12 $m13 $m20 $m21 $m22 $m23 $final_pos_x $final_pos_y $final_pos_z $m33;
        
        float $outRot[] = `getAttr ($decomp+".outputRotate")`;
        setAttr ($cameraName[0]+".rotateX") $outRot[0];
        setAttr ($cameraName[0]+".rotateY") $outRot[1];
        setAttr ($cameraName[0]+".rotateZ") $outRot[2];

        move -a $final_pos_x $final_pos_y $final_pos_z $cameraName[0];

        print ($cameraName[0]+" created successfully.\n");

        if ($doAutoImport){
          // ADD CAMERA TO PROJECTION LIST
          print ("Adding "+$cameraName[0]+" to projection list. (Press ESC to cancel)\n");

          // get the current mix node or create one if necessary
          string $gsProjCamMix = gs_mptk_getActiveMixNode();
          if ($gsProjCamMix == "") {
            gs_mptk_createMixNode;
            $gsProjCamMix = gs_mptk_getActiveMixNode();
          } else {            
            // add new projection to list
            gs_mptk_addProj($gsProjCamMix);
            flushUndo;
          }

          int $activeProjIndex = gs_mptk_getActiveProjIndex($gsProjCamMix);
          int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
          $mptk_tabIndex -= 1;
          
          string $projectionNode = gs_mptk_getActiveProjNode();
          //assign camera
          int $indexNameMapping = gs_indexToNameMapping($gsProjCamMix, $activeProjIndex);
          catchQuiet (`connectAttr -f ($cameraShape[0]+".worldMatrix[0]") ($gsProjCamMix+".images["+$indexNameMapping+"].placementMatrix")`);
          catchQuiet (`connectAttr -f ($cameraShape[0]+".message") ($projectionNode+".linkedCamera")`);
          //assign images
          if ($importImages[$x] == "") print ("Assigning NO IMAGE to "+$cameraName[0]+"\n");
          else print ("Assigning "+$importImages[$x]+" to "+$cameraName[0]+"\n");
          string $mptk_fileNode[] = `listConnections -s on -d off ($projectionNode+".image")`;
          setAttr ($mptk_fileNode[0]+".fileTextureName") -type "string" $importImages[$x];
          //set matte
          string $matteProj[] = `listConnections -s on -d off ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
          catchQuiet (`connectAttr -f ($cameraShape[0]+".message") ($matteProj[0]+".linkedCamera")`);
          string $matteRamp[] = `listConnections -s on -d off $matteProj[0]`;
          if ((`getAttr ($mptk_fileNode[0]+".fileHasAlpha")` == 1) && ($autoAlphaVal == 1)) {
            print "Assigning alpha channel as matte\n";
            //gs_mptk_loadMatteImage($projectionNode, $importImages[$x], "", "alpha", $indexNameMapping, $gsProjCamMix, $mptk_tabIndex, $activeProjIndex);
            if (`nodeType $matteRamp[0]` == "ramp") {
                string $uvCoord[0] = `listConnections -s on -d off ($matteRamp[0]+".uvCoord")`;
                string $matteFile = `shadingNode -asTexture file`;
                connectAttr -force ($uvCoord[0]+".outUV") ($matteFile+".uvCoord"); 
                connectAttr -force ($uvCoord[0]+".outUvFilterSize") ($matteFile+".uvFilterSize"); 
                connectAttr -force ($uvCoord[0]+".translateFrame") ($matteFile+".translateFrame"); 
                connectAttr -force ($uvCoord[0]+".rotateFrame") ($matteFile+".rotateFrame"); 
                connectAttr -force ($uvCoord[0]+".mirrorU") ($matteFile+".mirrorU"); 
                connectAttr -force ($uvCoord[0]+".mirrorV") ($matteFile+".mirrorV"); 
                connectAttr -force ($uvCoord[0]+".stagger") ($matteFile+".stagger"); 
                connectAttr -force ($uvCoord[0]+".wrapU") ($matteFile+".wrapU"); 
                connectAttr -force ($uvCoord[0]+".wrapV") ($matteFile+".wrapV"); 
                connectAttr -force ($uvCoord[0]+".repeatUV") ($matteFile+".repeatUV"); 
                connectAttr -force ($uvCoord[0]+".vertexUvOne") ($matteFile+".vertexUvOne"); 
                connectAttr -force ($uvCoord[0]+".vertexUvTwo") ($matteFile+".vertexUvTwo"); 
                connectAttr -force ($uvCoord[0]+".vertexUvThree") ($matteFile+".vertexUvThree"); 
                connectAttr -force ($uvCoord[0]+".vertexCameraOne") ($matteFile+".vertexCameraOne"); 
                connectAttr -force ($uvCoord[0]+".noiseUV") ($matteFile+".noiseUV"); 
                connectAttr -force ($uvCoord[0]+".offset") ($matteFile+".offset"); 
                connectAttr -force ($uvCoord[0]+".rotateUV") ($matteFile+".rotateUV");
                connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageR");
                connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageG");
                connectAttr -force ($matteFile+".outAlpha") ($matteProj[0]+".image.imageB");
                setAttr ($matteFile+".fileTextureName") -type "string" $importImages[$x];
                delete $matteRamp[0];
            }
          }  
          // set attributes
          setAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useShadowOcclusion") $useShadowOcclVal;
          setAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useFacingRatio") $useFacingRatioVal;

          rename $projectionNode ($cameraName[0]+"_projection");
          $projectionNode = ($cameraName[0]+"_projection");

          rename $matteProj[0] ($cameraName[0]+"_projectionMatte");
          $matteProj[0] = ($cameraName[0]+"_projectionMatte");
          
        }
        
      }

  }

  delete $decomp; // delete the decompose matrix after the work is done

  progressBar -edit
        -endProgress
        $gMainProgressBar;

  print ("Creating point cloud...\n");
  
  float $colorR[], $colorG[], $colorB[];
  string $createParticle = "particle -n \"bundlerPointCloud\"";
  
  timer -s;
  float $lastTime = 0.0;
  int $percent, $lastPercent;
  float $count = 0;
  float $pointsFloat = $numPoints;

  for ($x=0; $x < $numPoints; $x++) {
    $count += 1;
    $percent = ($count/$pointsFloat) * 100;
    if ((`timer -lap` > ($lastTime + 1)) && ($percent != $lastPercent)) {
      print ($percent+"%\n");
      $lastTime = `timer -lap`;
      $lastPercent = $percent;
    }


    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $transX = $parseLine[0];
    $transY = $parseLine[1];
    $transZ = $parseLine[2];
    
    // get color
    $y++;
    $currentLine = $contentsArray[$y];
    $parseLine = stringToStringArray($currentLine, " ");
    $colorR[$x] = $parseLine[0];
    $colorG[$x] = $parseLine[1];
    $colorB[$x] = $parseLine[2];
    
    // create particle command
    $createParticle = ($createParticle + " -p " + $transX + " " + $transY + " " + $transZ);

    // create locator
    spaceLocator;
    scale -r 0.01 0.01 0.01 ;
    move -a $transX $transY $transZ ;
    
    $y+=2;
    
  }

  timer -e;
  print "100%\n";

  // create particleShape
  string $partTransform[] = `eval $createParticle`;
  rename $partTransform[0] ($partTransform[0]+"1");
  $partTransform = `ls -sl`;
  string $partShape[] = `listRelatives -s $partTransform[0]`;

  addAttr -ln "rgbPP" -dt vectorArray $partShape[0];
  addAttr -ln "rgbPP0" -dt vectorArray $partShape[0];

  for ($x=0; $x<`size $colorR`; $x++){
    select($partShape[0]+".pt["+$x+"]");
    setParticleAttr -vv ($colorR[$x]/255) ($colorG[$x]/255) ($colorB[$x]/255) -at rgbPP ;
    setParticleAttr -vv ($colorR[$x]/255) ($colorG[$x]/255) ($colorB[$x]/255) -at rgbPP0 ;
    
  }
  setAttr ($partShape[0]+".particleRenderType") 5;
  
  // optional set parameters for particle shape
  setPartiShapeParams ($partShape[0]);

  print ("Point cloud created successfully.\nImport complete.\n");


}

global proc setPartiShapeParams ( string $partShape ) {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc setPartiShapeParams\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // add sprite scale
  addAttr -is true -ln "spriteScaleX" -dv 1.0 $partShape;
  addAttr -is true -ln "spriteScaleY" -dv 1.0 $partShape;
  setAttr ($partShape+".spriteScaleX") 0.1;
  setAttr ($partShape+".spriteScaleY") 0.1;
}




global proc gs_autoImportQuery(string $file, string $fileType) {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_autoImportQuery\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    string $autoImportQuery = `confirmDialog -message "Automatically create projections from dataset?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if ($autoImportQuery == "Yes") {
      
      string $window = `window -title "Auto Import Options" autoImportWindow`;
      columnLayout -columnAttach "both" 10 -cal "left" -columnWidth 400;
        string $autoText = `text -l "\nThe following settings will be applied to all projections:\n" autoText`;
        string $autoAlpha = `checkBox -label "Auto Detect Alpha" -value 1 autoAlpha`;
        string $useShadowOccl = `checkBox -label "Use Shadow Occlusion" -value 0 useShadowOccl`;
        string $useFacingRatio = `checkBox -label "Use Facing Ratio" -value 0 useFacingRatio`;
        string $nextBtn = `button -l "Continue" -c ("gs_bundler_getCamData(1, \""+$file+"\", \""+$fileType+"\")")`;
      showWindow;
    } else{
      gs_bundler_getCamData(0, $file, $fileType); // no auto import, but still want to continue
    }
}

global proc gs_bundler_getCamData(int $doAutoImport, string $file, string $fileType){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_bundler_getCamData\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

        int $autoAlphaVal;
        int $useShadowOcclVal;
        int $useFacingRatioVal;

  if ($doAutoImport) {
        $autoAlphaVal = `checkBox -q -v autoAlpha`;
        $useShadowOcclVal = `checkBox -q -v useShadowOccl`;
        $useFacingRatioVal = `checkBox -q -v useFacingRatio`;
        deleteUI -window autoImportWindow;
  }
  

  string $window = `window -title "Camera Data Required" camDataWindow`;
      columnLayout -columnAttach "both" 10 -cal "left" -columnWidth 400;

          string $t = `text -l "\nProvide camera info:\n"`;
          intFieldGrp -numberOfFields 1 -label "Image width"-extraLabel "pixels" -value1 640 imageSize;
          floatFieldGrp -numberOfFields 2 -pre 3 -label "Sensor size width/height" -extraLabel "mm" -value1 36.0 -value2 24.0 sensorSize;
          string $presetChange = "if (`optionMenu -q -v presets` == \"Canon 5d (full frame)\") { floatFieldGrp -e -v1 36.0 sensorSize; floatFieldGrp -e -v2 24.0 sensorSize; }  if (`optionMenu -q -v presets` == \"Nikon D200 (1.5x crop)\") { floatFieldGrp -e -v1 23.6 sensorSize; floatFieldGrp -e -v2 15.8 sensorSize; }  if (`optionMenu -q -v presets` == \"iPhone4 (1/3.2in)\") { floatFieldGrp -e -v1 4.536 sensorSize; floatFieldGrp -e -v2 3.39 sensorSize; }   if (`optionMenu -q -v presets` == \"Nokia n900 (1/2.5in)\") { floatFieldGrp -e -v1 5.76 sensorSize; floatFieldGrp -e -v2 4.29 sensorSize; }";
          optionMenu -label "Presets" -changeCommand $presetChange presets;
                  menuItem -label "Canon 5d (full frame)";
                  menuItem -label "Nikon D200 (1.5x crop)";
                  menuItem -label "iPhone4 (1/3.2in)";
                  menuItem -label "Nokia n900 (1/2.5in)";
          text "\n";
          int $imageSize;
          float $sensorSize;
          
          string $continueBtn = `button -l "Continue" -command ("mptk_getData_bundle(\""+$file+"\", \""+$fileType+"\", \""+$doAutoImport+"\", \""+$autoAlphaVal+"\", \""+$useShadowOcclVal+"\", \""+$useFacingRatioVal+"\")")`;

      showWindow;
}


global proc gs_mptk_import() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_import\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  //fileBrowserDialog -m 0 -fc "importFile" -an "Import_File" -om "Import";
  string $multipleFilters = "Bundler Files (*.out);;PLY (*.ply)";
  string $file[] = `fileDialog2 -sff "Bundler Files" -rf 1 -fm 1 -ff $multipleFilters -cap "Select a bundle.out or .ply file to import"`;
  string $fileType = $file[1];


  if (`size $file[0]`) {

    if ($fileType == "Bundler Files") { 

    // Automatically add to projections?
    gs_autoImportQuery($file[0], $fileType);
      
      } else {


        string $contentsArray[];

        int $x=0;

        int $stepSize = -1;
          int $locators = 0;
        string $window = `window -title "PLY import options" importPlyOptionsWindow`;
        columnLayout -columnAttach "both" 10 -cal "left" -columnWidth 400;

            intFieldGrp -numberOfFields 1 -label "Step size" -value1 1 stepSize;
            checkBox -label "Create locators" locatorsCheck;

            text "\n";

            string $continueBtn = `button -l "Continue" -command ("mptk_getData_ply(\""+$file[0]+"\", \""+$fileType+"\")")`;

        showWindow;

        
      }
  }

}

global proc mptk_getData_ply(string $file, string $fileType){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_getData_ply\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    int $stepSize = `intFieldGrp -q -v1 stepSize`; 
    int $locators = `checkBox -q -v locatorsCheck`; 
    deleteUI -window importPlyOptionsWindow; 
    importFile($file, $fileType, 0, 0, 0, $stepSize, $locators, 0, 0, 0, 0);

}


global proc mptk_getData_bundle(string $file, string $fileType, int $doAutoImport, int $autoAlphaVal, int $useShadowOcclVal, int $useFacingRatioVal){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc mptk_getData_bundle\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

    int $imageSize = `intFieldGrp -q -v1 imageSize`; 
    float $sensorSizeW = `floatFieldGrp -q -v1 sensorSize`; 
    float $sensorSizeH = `floatFieldGrp -q -v2 sensorSize`; 
    deleteUI -window camDataWindow; 
    
    importFile($file, $fileType, $imageSize, $sensorSizeW, $sensorSizeH, 0, 0, $doAutoImport, $autoAlphaVal, $useShadowOcclVal, $useFacingRatioVal);
}

global proc gs_mptk_vrayDeleteAll() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_vrayDeleteAll\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // clear existing network
  string $allOcclVRay[]; 
  string $allMixVRay[];
  $allOcclVRay = `lsType "gs_occlusionMatteVRay"`;
  $allMixVRay = `lsType "gs_projCamMixVRay"`;
    if ($allOcclVRay[`size $allOcclVRay` - 1] == "<done>") stringArrayRemoveAtIndex(`size $allOcclVRay` - 1, $allOcclVRay);
    if ($allMixVRay[`size $allMixVRay` - 1] == "<done>") stringArrayRemoveAtIndex(`size $allMixVRay` - 1, $allMixVRay);
  if (`size $allOcclVRay` || `size $allMixVRay`) {
    string $surfaceShader[] = `listConnections -s off -d on -type "surfaceShader" $allMixVRay`;
    string $mtlWrapper[] = `listConnections -s off -d on -type "VRayMtlWrapper" $surfaceShader`;
    delete $allMixVRay;
    delete $allOcclVRay;
    delete $surfaceShader;
    delete $mtlWrapper;
  }
  print "gs_mptk cleared VRay networks.\n";
}

global proc gs_mptk_vrayDeleteCurrent() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_vrayDeleteCurrent\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  string $gs_projCamMix = gs_mptk_getActiveMixNode();
  if ($gs_projCamMix != "") { 
    // get shading engine
    int $mptk_projCamMixNum = gs_mptk_getUITabNumFromMixNode ($gs_projCamMix);
     string $allObjs[] = `textScrollList -q -ai (("mptk_UI_tabs_child_" + $mptk_projCamMixNum)+"_mptk_objList")`;
     string $shadingEngine, $surfaceShader, $src[];
     if ($allObjs[0] != "") {
       string $allDescendents[] = `listRelatives -ad $allObjs[0]`;
       string $currentShaders[], $allShaders[];
       clear $allShaders;
       for ($x=0; $x<`size $allDescendents`; $x++){
         $currentShaders = `listSets -ets -t 1 -o $allDescendents[$x]`;
         $allShaders = stringArrayCatenate($allShaders, $currentShaders);
         $allShaders = stringArrayRemoveDuplicates($allShaders);
       }
       $shadingEngine = $allShaders[0];
     }
     if ($shadingEngine == "") // if no geo or assigned shading engine
     {
       // find all shading engines assigned to gs_projCamMix
       string $shadEngine[];
       clear $src;
       $src[0] = $gs_projCamMix;
       while (`size $src`) {
          //step through chain
          $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
          if (`size $shadEngine`) break;
          $src = `listConnections -s off -d on -scn 1 $src`;
       }
       $shadingEngine = $shadEngine[0];
     }
     // get mtl wrapper
     string $mtlWrapper[] = `listConnections -s on -d off -type VRayMtlWrapper $shadingEngine`;
    if (`size $mtlWrapper`) {
      string $surfaceShader[] = `listConnections -s on -d off -type "surfaceShader" $mtlWrapper`;
      string $currentMixVRay[] = `listConnections -s on -d off -type "gs_projCamMixVRay" $surfaceShader`;
      string $currentOcclVRay[];
      if (`size $currentMixVRay`) $currentOcclVRay = `listConnections -s on -d off -type "gs_occlusionMatteVRay" $currentMixVRay`;
      if (`size $currentMixVRay`) delete $currentMixVRay;
      if (`size $currentOcclVRay`) delete $currentOcclVRay;
      if (`size $surfaceShader`) delete $surfaceShader;
      delete $mtlWrapper;
    }
  }
}

global proc gs_mptk_vrayRebuild() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_vrayRebuild\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  // clear existing network
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
    gs_mptk_vrayDeleteCurrent();
  } else {
    gs_mptk_vrayDeleteAll();
  }
  // build network
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
    print "gs_mptk rebuilding V-Ray network...\n";
    string $gsProjCamMix = gs_mptk_getActiveMixNode();
    if ($gsProjCamMix != "") {
      int $numProjections = gs_projCamMix_query_num($gsProjCamMix);
      string $colorProjs[], $maskProjs[], $occlMatte[], $gsProjCamMixVRay[];
      clear $occlMatte;
      clear $gsProjCamMixVRay;
      for ($x=0; $x<$numProjections; $x++){
          int $indexNameMapping = gs_indexToNameMapping($gsProjCamMix, $x);
          // separate color proj from matte proj
          string $_colorProj[] = `listConnections -s on -d off -type "projection" ($gsProjCamMix+".images["+$indexNameMapping+"].color")`;
          string $_maskProj[] = `listConnections -s on -d off -type "projection" ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
          // if no mask connection, check for mult/div
          if ($_maskProj[0] == "") $_maskProj = `listConnections -s on -d off -type "multiplyDivide" ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
          string $_placementMatrix[] = `listConnections -s on -d off -type "camera" -sh 1 ($gsProjCamMix+".images["+$indexNameMapping+"].placementMatrix")`;

          $occlMatte[$x] = `shadingNode -asTexture gs_occlusionMatteVRay`;
          $gsProjCamMixVRay[$x] = `shadingNode -asTexture gs_projCamMixVRay`;
          // set attributes
          float $color[] = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].color")`;
          setAttr ($occlMatte[$x]+".color") $color[0] $color[1] $color[2];
          float $mask = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
          setAttr ($occlMatte[$x]+".mask") $mask;
          float $colorOffset[] = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].colorOffset")`;
          setAttr ($occlMatte[$x]+".colorOffset") $colorOffset[0] $colorOffset[1] $colorOffset[2];
          int $passThrough = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].passThrough")`;
          setAttr ($occlMatte[$x]+".passThrough") $passThrough;
          float $distT = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].distanceThreshold")`;
          setAttr ($occlMatte[$x]+".distanceThreshold") $distT;
          int $useOccl = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useShadowOcclusion")`;
          setAttr ($occlMatte[$x]+".useShadowOcclusion") $useOccl;
          float $dilate = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].dilate")`;
          setAttr ($occlMatte[$x]+".dilate") $dilate;
          int $samples = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].samples")`;
          setAttr ($occlMatte[$x]+".samples") $samples;
          float $softEdge = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].softEdge")`;
          setAttr ($occlMatte[$x]+".softEdge") $softEdge;
          int $power = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].power")`;
          setAttr ($occlMatte[$x]+".power") $power;
          int $useFacingRatio = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useFacingRatio")`;
          setAttr ($occlMatte[$x]+".useFacingRatio") $useFacingRatio;
          float $angleThreshold = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].angleThreshold")`;
          setAttr ($occlMatte[$x]+".angleThreshold") $angleThreshold;
          int $labelExclude = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].labelExclude")`;
          setAttr ($occlMatte[$x]+".labelExclude") $labelExclude;
          int $premult = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].premult")`;
          setAttr ($occlMatte[$x]+".premult") $premult;

          // make connections
          if ($_colorProj[0] != "") connectAttr -f ($_colorProj[0]+".outColor") ($occlMatte[$x]+".color");
          if ($_maskProj[0] != "") {
              if (`nodeType $_maskProj[0]` == "projection") connectAttr -f ($_maskProj[0]+".outColorR") ($occlMatte[$x]+".mask");
              if (`nodeType $_maskProj[0]` == "multiplyDivide") connectAttr -f ($_maskProj[0]+".outputX") ($occlMatte[$x]+".mask");
          }
          if ($_placementMatrix[0] != "") connectAttr -f ($_placementMatrix[0]+".worldMatrix[0]") ($occlMatte[$x]+".placementMatrix");


      }
      string $netInp[] = $occlMatte;
      string $gsProjCamMixVRayOut;

      for ($x=(`size $occlMatte` - 1); $x>=0; $x--){
          if ($x > 0) {
              connectAttr -f ($netInp[$x]+".outColor") ($gsProjCamMixVRay[$x]+".color_b");
              connectAttr -f ($netInp[$x]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_b");
              connectAttr -f ($netInp[$x-1]+".outColor") ($gsProjCamMixVRay[$x]+".color_a");
              connectAttr -f ($netInp[$x-1]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_a");
              $netInp[$x-1] = $gsProjCamMixVRay[$x];
              if ($x-1 == 0) {
                  $gsProjCamMixVRayOut = $gsProjCamMixVRay[$x];
                  break;
              }
          }else{ // if there's only 1 projection, put it in color_b
              connectAttr -f ($netInp[$x]+".outColor") ($gsProjCamMixVRay[$x]+".color_b");
              connectAttr -f ($netInp[$x]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_b");
              setAttr ($gsProjCamMixVRay[$x]+".color_a") -type double3 0 0 0 ;
              setAttr ($gsProjCamMixVRay[$x]+".matte_a") -type double3 0 0 0 ;
          }
          $gsProjCamMixVRayOut = $gsProjCamMixVRay[$x];
      }

      string $geoShaderVRay = `shadingNode -asShader surfaceShader`;
      connectAttr -f ($gsProjCamMixVRayOut+".outColor") ($geoShaderVRay+".outColor");
      connectAttr -f ($gsProjCamMixVRayOut+".outMatte") ($geoShaderVRay+".outMatteOpacity");
      connectAttr -f ($gsProjCamMixVRayOut+".outTransparency") ($geoShaderVRay+".outTransparency");
      string $mtlWrapperVRay = `shadingNode -asShader VRayMtlWrapper`;
      connectAttr -f ($geoShaderVRay+".outColor") ($mtlWrapperVRay+".baseMaterial");
      // find all shading engines assigned to gs_projCamMix
      string $shadEngine[], $src[];
      clear $src;
      clear $shadEngine;
      $src[0] = $gsProjCamMix;
      while (`size $src`) {
              //step through chain
              $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
              if (`size $shadEngine`) break;
              $src = `listConnections -s off -d on -scn 1 $src`;
      }
      if (!`size $shadEngine`) error ("No shading engine found for "+$gsProjCamMix+". Aborting.");
      // add vray specific attributes and connect
      vray addAttributesFromGroup $shadEngine[0] vray_specific_mtl 1;
      // these commands are needed so that the vraySpecificSurfaceShader connection is made the first time
      vrayAddAttr $shadEngine[0] vrayEnableAllOverrides;
      vrayAddAttr $shadEngine[0] vrayEnableSpecificSurfaceShader;
      vrayAddAttr $shadEngine[0] vraySpecificSurfaceShader;
      vrayAddAttr $shadEngine[0] vrayEnableGIMaterial;
      vrayAddAttr $shadEngine[0] vrayGIMaterial;
      vrayAddAttr $shadEngine[0] vrayEnableReflectMaterial;
      vrayAddAttr $shadEngine[0] vrayReflectMaterial;
      vrayAddAttr $shadEngine[0] vrayEnableRefractMaterial;
      vrayAddAttr $shadEngine[0] vrayRefractMaterial;
      vrayAddAttr $shadEngine[0] vrayEnableShadowMaterial;
      vrayAddAttr $shadEngine[0] vrayShadowMaterial;
      vrayAddAttr $shadEngine[0] vrayEnableEnvironmentOverride;
      vrayAddAttr $shadEngine[0] vrayMtlEnvironmentOverride;
      vrayAddAttr $shadEngine[0] vrayMtlEnvironmentPriority;
      connectAttr -force ($mtlWrapperVRay+".outColor") ($shadEngine[0]+".vraySpecificSurfaceShader");
    }
    print "gs_mptk V-Ray network rebuilt successfully.\n";
  }
}

global proc gs_mptk_vrayRebuildAll() {

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_vrayRebuildAll\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";

  gs_mptk_vrayDeleteAll();
  
  // build network
  if (`menuItem -q -cb gs_mptk_vrayRender` == 1) {
    print "gs_mptk rebuilding all V-Ray networks...\n";

    string $allProjCamMix[] = `lsType "gs_projCamMix"`;
    for ($i=0; $i<`size $allProjCamMix`; $i++) {
      if ($allProjCamMix[$i] == "<done>") break;
      string $gsProjCamMix = $allProjCamMix[$i];
      if ($gsProjCamMix != "") {
        int $numProjections = gs_projCamMix_query_num($gsProjCamMix);
        string $colorProjs[], $maskProjs[], $occlMatte[], $gsProjCamMixVRay[];
        clear $occlMatte;
        clear $gsProjCamMixVRay;
        for ($x=0; $x<$numProjections; $x++){
            int $indexNameMapping = gs_indexToNameMapping($gsProjCamMix, $x);
            // separate color proj from matte proj
            string $_colorProj[] = `listConnections -s on -d off -type "projection" ($gsProjCamMix+".images["+$indexNameMapping+"].color")`;
            string $_maskProj[] = `listConnections -s on -d off -type "projection" ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
            // if no mask connection, check for mult/div
            if ($_maskProj[0] == "") $_maskProj = `listConnections -s on -d off -type "multiplyDivide" ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
            string $_placementMatrix[] = `listConnections -s on -d off -type "camera" -sh 1 ($gsProjCamMix+".images["+$indexNameMapping+"].placementMatrix")`;

            $occlMatte[$x] = `shadingNode -asTexture gs_occlusionMatteVRay`;
            $gsProjCamMixVRay[$x] = `shadingNode -asTexture gs_projCamMixVRay`;
            // set attributes
            float $color[] = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].color")`;
            setAttr ($occlMatte[$x]+".color") $color[0] $color[1] $color[2];
            float $mask = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].mask")`;
            setAttr ($occlMatte[$x]+".mask") $mask;
            float $colorOffset[] = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].colorOffset")`;
            setAttr ($occlMatte[$x]+".colorOffset") $colorOffset[0] $colorOffset[1] $colorOffset[2];
            int $passThrough = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].passThrough")`;
            setAttr ($occlMatte[$x]+".passThrough") $passThrough;
            float $distT = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].distanceThreshold")`;
            setAttr ($occlMatte[$x]+".distanceThreshold") $distT;
            int $useOccl = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useShadowOcclusion")`;
            setAttr ($occlMatte[$x]+".useShadowOcclusion") $useOccl;
            float $dilate = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].dilate")`;
            setAttr ($occlMatte[$x]+".dilate") $dilate;
            int $samples = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].samples")`;
            setAttr ($occlMatte[$x]+".samples") $samples;
            float $softEdge = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].softEdge")`;
            setAttr ($occlMatte[$x]+".softEdge") $softEdge;
            int $power = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].power")`;
            setAttr ($occlMatte[$x]+".power") $power;
            int $useFacingRatio = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].useFacingRatio")`;
            setAttr ($occlMatte[$x]+".useFacingRatio") $useFacingRatio;
            float $angleThreshold = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].angleThreshold")`;
            setAttr ($occlMatte[$x]+".angleThreshold") $angleThreshold;
            int $labelExclude = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].labelExclude")`;
            setAttr ($occlMatte[$x]+".labelExclude") $labelExclude;
            int $premult = `getAttr ($gsProjCamMix+".images["+$indexNameMapping+"].premult")`;
            setAttr ($occlMatte[$x]+".premult") $premult;

            // make connections
            if ($_colorProj[0] != "") connectAttr -f ($_colorProj[0]+".outColor") ($occlMatte[$x]+".color");
            if ($_maskProj[0] != "") {
                if (`nodeType $_maskProj[0]` == "projection") connectAttr -f ($_maskProj[0]+".outColorR") ($occlMatte[$x]+".mask");
                if (`nodeType $_maskProj[0]` == "multiplyDivide") connectAttr -f ($_maskProj[0]+".outputX") ($occlMatte[$x]+".mask");
            }
            if ($_placementMatrix[0] != "") connectAttr -f ($_placementMatrix[0]+".worldMatrix[0]") ($occlMatte[$x]+".placementMatrix");


        }
        string $netInp[] = $occlMatte;
        string $gsProjCamMixVRayOut;

        for ($x=(`size $occlMatte` - 1); $x>=0; $x--){
            if ($x > 0) {
                connectAttr -f ($netInp[$x]+".outColor") ($gsProjCamMixVRay[$x]+".color_b");
                connectAttr -f ($netInp[$x]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_b");
                connectAttr -f ($netInp[$x-1]+".outColor") ($gsProjCamMixVRay[$x]+".color_a");
                connectAttr -f ($netInp[$x-1]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_a");
                $netInp[$x-1] = $gsProjCamMixVRay[$x];
                if ($x-1 == 0) {
                    $gsProjCamMixVRayOut = $gsProjCamMixVRay[$x];
                    break;
                }
            }else{ // if there's only 1 projection, put it in color_b
                connectAttr -f ($netInp[$x]+".outColor") ($gsProjCamMixVRay[$x]+".color_b");
                connectAttr -f ($netInp[$x]+".outMatte") ($gsProjCamMixVRay[$x]+".matte_b");
                setAttr ($gsProjCamMixVRay[$x]+".color_a") -type double3 0 0 0 ;
                setAttr ($gsProjCamMixVRay[$x]+".matte_a") -type double3 0 0 0 ;
            }
            $gsProjCamMixVRayOut = $gsProjCamMixVRay[$x];
        }

        string $geoShaderVRay = `shadingNode -asShader surfaceShader`;
        connectAttr -f ($gsProjCamMixVRayOut+".outColor") ($geoShaderVRay+".outColor");
        connectAttr -f ($gsProjCamMixVRayOut+".outMatte") ($geoShaderVRay+".outMatteOpacity");
        connectAttr -f ($gsProjCamMixVRayOut+".outTransparency") ($geoShaderVRay+".outTransparency");
        string $mtlWrapperVRay = `shadingNode -asShader VRayMtlWrapper`;
        connectAttr -f ($geoShaderVRay+".outColor") ($mtlWrapperVRay+".baseMaterial");
        // find all shading engines assigned to gs_projCamMix
        string $shadEngine[], $src[];
        clear $src;
        clear $shadEngine;
        $src[0] = $gsProjCamMix;
        while (`size $src`) {
                //step through chain
                $shadEngine = `listConnections -s off -d on -t shadingEngine -scn 1 $src`;
                if (`size $shadEngine`) break;
                $src = `listConnections -s off -d on -scn 1 $src`;
        }
        if (!`size $shadEngine`) error ("No shading engine found for "+$gsProjCamMix+". Aborting.");
        // add vray specific attributes and connect
        vray addAttributesFromGroup $shadEngine[0] vray_specific_mtl 1;
        // these commands are needed so that the vraySpecificSurfaceShader connection is made the first time
        vrayAddAttr $shadEngine[0] vrayEnableAllOverrides;
        vrayAddAttr $shadEngine[0] vrayEnableSpecificSurfaceShader;
        vrayAddAttr $shadEngine[0] vraySpecificSurfaceShader;
        vrayAddAttr $shadEngine[0] vrayEnableGIMaterial;
        vrayAddAttr $shadEngine[0] vrayGIMaterial;
        vrayAddAttr $shadEngine[0] vrayEnableReflectMaterial;
        vrayAddAttr $shadEngine[0] vrayReflectMaterial;
        vrayAddAttr $shadEngine[0] vrayEnableRefractMaterial;
        vrayAddAttr $shadEngine[0] vrayRefractMaterial;
        vrayAddAttr $shadEngine[0] vrayEnableShadowMaterial;
        vrayAddAttr $shadEngine[0] vrayShadowMaterial;
        vrayAddAttr $shadEngine[0] vrayEnableEnvironmentOverride;
        vrayAddAttr $shadEngine[0] vrayMtlEnvironmentOverride;
        vrayAddAttr $shadEngine[0] vrayMtlEnvironmentPriority;
        
        connectAttr -force ($mtlWrapperVRay+".outColor") ($shadEngine[0]+".vraySpecificSurfaceShader");
      }
    } // end for loop
    print "gs_mptk built all V-Ray networks successfully.\n";
  }
}

global proc string gs_mptk_getProjSequencePathField(string $file) {
    string $projName;
    string $fileNode[];
    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
    int $mptk_numProj = gs_projCamMix_query_num($gs_projCamMixNode);
    int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
    $mptk_tabIndex -= 1;
    for ($a=0; $a<$mptk_numProj; $a++){
        $projName = `textField -q -tx ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_UI_projName"+$a)`;
        $fileNode = `listConnections -s on -d off -type file $projName`;
        if ($fileNode[0] == $file) {
            return ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_projPath"+$a);
            break;
        }
    }
    // return invalid index if not found
    return ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_projPath9999999");
    
}

global proc string gs_mptk_getMatteSequencePathField(string $file) {
    string $projName;
    string $fileNode[];
    string $gs_projCamMixNode = gs_mptk_getActiveMixNode();
    int $mptk_numMattes = gs_projCamMix_query_numMattes($gs_projCamMixNode);
    int $mptk_tabIndex = `tabLayout -q -sti mptk_UI_tabs`;
    $mptk_tabIndex -= 1;
    for ($a=0; $a<$mptk_numMattes; $a++){
        $projName = `textField -q -tx ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_UI_matteName"+$a)`;
        $fileNode = `listConnections -s on -d off -type file $projName`;
        if ($fileNode[0] == $file) {
            return ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_mattePath"+$a);
            break;
        }
    }
    // return invalid index if not found
    return ("mptk_UI_tabs_child_"+$mptk_tabIndex+"_mptk_mattePath9999999");
}

global proc gs_mptk_docs(){

  if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_docs\n";
  if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   launch -web "http://www.glyphfx.com/docs/index.php";
}

global proc gs_mptk_aboutDialog(){
    
    if (`menuItem -q -cb gs_mptk_debugMode` == 1) print "running proc gs_mptk_aboutDialog\n";
    if (`menuItem -q -cb gs_mptk_debugStep` == 1) confirmDialog -message "debug step" -button "Ok";
   
    confirmDialog -message "Mattepainting Toolkit for Maya\n\nCopyright (c) Glyph Software, LLC\n\nwww.glyphfx.com\n\nversion: 23132291\nvray version: 1424" -button "Ok";

}


