//     AdvancedSkeleton
//     Version 4.140
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2015 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 13/02/2015

global proc AdvancedSkeleton4 ()
{
global int $asRebuilding;
global int $asFitModeScriptJob1Nr;
global int $asFitModeSkip;
global int $asFitSkeletonTriggerPrevious;
global int $asFitModeHierarchy;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global string $asDSAltPivot;
global int $asFitModeScriptJob3Nr;
global int $asSkipConfirm;
int $asDock=`optionVar -q asDock`;
$asRebuilding=0;
$asFitModeSkip=0;
$asFitSkeletonTriggerPrevious=0;
$asSkipConfirm=0;
$asDSAltPivot="";
int $csm=0;//CorrectiveShapeMode
string $geometry,$allFaceGeoString,$eyeL,$eyeR,$upperTeeth,$lowerTeeth,$tongue,
	$eyeBrowL,$eyeBrowR,$eyeLashL,$eyeLashR,$headJoint,$skinCluster;
if (`attributeExists geometry FaceFitSkeleton`)
	$geometry=`getAttr FaceFitSkeleton.geometry`;
if (`attributeExists AllFaceGeo FaceFitSkeleton`)
	$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;
if (`attributeExists Eye_L FaceFitSkeleton`)
	$eyeL=`getAttr FaceFitSkeleton.Eye_L`;
if (`attributeExists Eye_R FaceFitSkeleton`)
	$eyeR=`getAttr FaceFitSkeleton.Eye_R`;
if (`attributeExists UpperTeeth FaceFitSkeleton`)
	$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
if (`attributeExists LowerTeeth FaceFitSkeleton`)
	$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
if (`attributeExists Tongue FaceFitSkeleton`)
	$tongue=`getAttr FaceFitSkeleton.Tongue`;
if (`attributeExists HeadJoint FaceFitSkeleton`)
	$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
if (`attributeExists "SkinCluster" FaceFitSkeleton`)
	$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;

string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$csm=1;
int $dsm=0;//DrivingSystemMode
string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists sdkDriverValue $rootLevelObjects[$i]`)
		$dsm=1;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJob3Nr!=0)
	if (!`scriptJob -ex $asFitModeScriptJob3Nr`)
		$asFitModeScriptJob3Nr=0;
if ($asFitModeScriptJob3Nr==0)
	$asFitModeScriptJob3Nr=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;

if (!`optionVar -ex asSelectableGeo`)
	optionVar -iv asSelectableGeo 1;

if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
window -t AdvancedSkeleton4 AdvancedSkeletonWindow;
formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asBodyPrepFrameLayout;
		columnLayout -adj 0;
			text -l "Group your model so that you have 1 top node.";
			text -l "And save the model in a separate file.";
			text -l "Then Reference-in the model file:";
			button -l "Reference the model file" -c asReferenceModelBrowser;
			separator -st none -h 10;
			button -l "Create FitSkeleton Node" -c asCreateFitSkeleton;
			text -l "Then scale this,";
			text -l "so upper circle is just above the character`s head";
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -l "FitSkeletons:";
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				optionMenu asFitFiles;
//					menuItem -l "human";
				button -l "Import" -c asFitSkeletonImport;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Limb:";
				setParent..;
			rowLayout -nc 4 -cw4 60 60 38 100;
				separator;
				optionMenu -cc asFitChangeLimbType asLimbType;
					menuItem -l "Basic";
					menuItem -l "Spine";
					menuItem -l "Neck";
					menuItem -l "Arm";
					menuItem -l "Leg";
					menuItem -l "Tail";
				checkBox -l mid -v 1 asLimbMiddle;
				button -l Create -c asCreateLimb;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Mode:";
				setParent..;
			rowLayout -nc 6;
				separator -w 60 -st "none";
				button -l "Fit Mode" -c asToggleFitMode;
				separator -w 12 -st "none";
				button -en $asFitModeScriptJob1Nr -h 15 -l "hierarchy mode" -c asToggleFitModeHierarchy asHierarchyButton;
				separator -w 5 -st "none";
				setParent..;
			rowLayout -nc 4 -cw4 60 80 60 60;
				separator;
				checkBox -v `optionVar -q asSelectableGeo` -en $asFitModeScriptJob1Nr -l "geometry selectable"
					-onc "asSelectableGeo 1;optionVar -iv asSelectableGeo 1;"
					-ofc "asSelectableGeo 0;optionVar -iv asSelectableGeo 0;"
					asVisGeoSelectable;		
				setParent..;

			if (`asHaveMeshCenterSnap`)
				{
				separator;
				rowLayout -nc 1;
					text -l "Snap:";
				setParent..;
				rowLayout -nc 6;
					separator -w 65 -st "none";
					iconTextCheckBox -w 26 -h 26 -i "snapMeshCenter.png" -cc "asSnapMode #1" -annotation (uiRes("m_statusLine.kSnapeMeshCenterAnnot")) asMeshCenterSnapButton;//
					separator -w 20 -st "none";
//					iconTextButton -w 26 -h 26 -i1 "makeLiveIcon.png" -c makeLive -ann (uiRes("m_statusLine.kMakeLiveAnnot")) asMakeLiveButton;
					textField -w 100 -ed 0 -ann "Right click for list of geometry" asMakeLiveObjectText;
					popupMenu -pmc "asPopulateSnapToLivePopupMenu" asSnapToLivePopupMenu;
				setParent..;
				}

			separator;
			rowLayout -nc 1;
				text -l "Axis:";
				setParent..;
/*
			rowLayout -nc 5 -cw5 60 40 60 40 60;
				separator;
				optionMenu -cc asFitChangeAxis asAxisLenght;
					menuItem -l "x" -data 0;
					menuItem -l "y" -data 1;
					menuItem -l "z" -data 2;
					if (`optionVar -ex asLenghtAxis`)
						optionMenu -e -sl `optionVar -q asLenghtAxis` asAxisLenght;
				text -l "Lenght";
				optionMenu -cc asFitChangeAxis asAxisFront;
					menuItem -l "x" -data 0;
					menuItem -l "y" -data 1;
					menuItem -l "z" -data 2;
					if (`optionVar -ex asFrontAxis`)
						optionMenu -e -sl `optionVar -q asFrontAxis` asAxisFront;
					else
						optionMenu -e -v "y" asAxisFront;

				text -l "Front";
				setParent..;
*/
			rowLayout -nc 2 -cw2 60 40;
				separator;
				button -l "display LocalRotationAxis`s" -c asFitTglRLA;
				setParent..;

			separator;
			rowLayout -nc 1;
				text -l "Visualize:";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				checkBox -l locators asVisLocators;
				setParent..;
			rowLayout -nc 3 -cw3 60 80 60;
				separator;
				checkBox -l "geometry" asVisGeo;
				optionMenu asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
				setParent..;
			rowLayout -nc 4 -cw4 60 80 60 60;
				separator;
				checkBox -l directions asVisDirections;
				checkBox -l directionfront asVisDirectionFront;
				setParent..;
			floatSliderGrp -cw3 80 40 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 asVisGap;
			checkBox -l advanced -onc "columnLayout -e -m 1 asFitAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asFitAdvancedColumnLayout";
			columnLayout -m 0 asFitAdvancedColumnLayout;
				separator -h 15;
				button -l "Convert joint-chain to limb" -c asConvertJointChainToLimb;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4;
				separator -w 120 -st none;
				checkBox -l "ReBuild Connections" -v 1 asRebuildConnections;
				setParent..;
			rowLayout -nc 4;
				separator -w 15 -st none;
				button -w 60 -l FitMode -c asToggleFitMode asToggleFitSkeletonButton;
				separator -w 20 -st none;
				button -w 140 -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;
/*
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " ReBuild" asBodyReBuildFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2;
				separator -w 120 -st none;
//				checkBox -l "ReBuild Connections" -v 1 asRebuildConnections;
				setParent..;
			rowLayout -nc 4;
				separator -w 15 -st none;
				button -l "Toggle Fit/Advanced" -c asToggleFitMode;
				separator -w 5 -st none;
				button -l "ReBuild Skeleton" -c asReBuildAdvancedSkeleton;
				setParent..;
			setParent..;
		setParent..;
*/
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 0;
			text -l "Skinning:";
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				button -w 140 -l "Select DeformJoints" -c asSelectDeformJoints;
				setParent..;
			setParent..;
		text -l "Then select (add) the geometry, then";  
		columnLayout -adj 0;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 0;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Sliders:";
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				setParent..;
			separator -st "none";
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				setParent..;
			separator -h 5 -st "none";
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				setParent..;
			setParent..;
		separator;
		columnLayout -adj 0;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select mesh to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 2 -cw2 60 100;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					setParent..;
				setParent..;
			checkBox -l advanced -onc "columnLayout -e -m 1 asDeform2AdvancedColumnLayout" -ofc "columnLayout -e -m 0 asDeform2AdvancedColumnLayout";
			columnLayout -m 0 asDeform2AdvancedColumnLayout;
				separator -h 15;
				button -l "Move red SkinCurves to \"DeformationWidth\"" -c asSkinCurvesToWidth;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 0;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				setParent..;
			setParent..;
		separator;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				setParent..;
			setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 0;
			text -l "SkinLoops:";
			separator -st "none" -h 5;
			text -l "Select EdgeLoop + FK control, then";
			rowLayout -nc 3 -cw3 60 100 100;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				button -w 110 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 110 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				setParent..;
			separator -w 242 -h 5;
/*
			rowLayout -nc 3;
				text -l "Create extra joints at: ";
				checkBox -v 1 "50%";
				checkBox -v 1 "25%";
				setParent..;
*/
			text -l "Select mesh to deform, then:";
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 110 -l "Bind" -c "asBindSkinLoops 0";
				setParent..;
			separator -w 242 -h 5;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				setParent..;
			separator -w 242 -h 5;
			checkBox -l advanced -onc "columnLayout -e -m 1 asDeform4AdvancedColumnLayout" -ofc "columnLayout -e -m 0 asDeform4AdvancedColumnLayout";
			columnLayout -m 0 asDeform4AdvancedColumnLayout;
				separator -h 5;
				text -l "FitSkeleton can be placed from EdgeLoops:";
				separator -h 5;
				rowLayout -nc 3 -cw3 60 100 100;
					separator;
					button -w 100 -l "Open Selector" -c asOpenSelector;
					setParent..;
				rowLayout -nc 3 -cw3 60 100 100;
					separator;
					button -w 100 -l "Create Temp Nodes" -c asCreateTempNodes;
					setParent..;
				text -l "Now use button above to create the SkinLoops.";
				text -l "Once all SkinLoops are created, then:";
				text -l "Import FitSkeleton, then:";
				rowLayout -nc 3 -cw3 30 100 100;
					separator;
					button -w 160 -l "Place FitSkeleton Locators" -c asFitSkeletonFromEdgeLoops;
					setParent..;
				rowLayout -nc 3 -cw3 60 100 100;
					separator;
					button -w 100 -l "Delete Temp Nodes" -c "delete TempNodes";
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorPolyBoxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorPolyBoxes 0";
				setParent..;
			separator -h 10;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "First make the pose to be driven";
			text -l "(e.g. folded wings, hand guesture, etc.)";
			text -l "Then:";
			button -l "Create Driving System" -c asCreateDrivingSystem;
			separator -h 10;
			text -l "Or, Right Click on any of these buttons,\nto access existing Driving Systems.";
			rowLayout -nc 4 -cw4 55 55 55 55;
				button -w 50 -en (!$dsm) -l "Edit" -c asAutoFindAndEditDrivingSystem asEditDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Edit" asEditDrivingSystemsPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Delete" asDeleteDrivingSystemsPopupMenu;
				button -w 50 -en (!$dsm) -l "Graph" asGraphDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Graph" asGraphDrivingSystemsPopupMenu;
				setParent..;
			separator -st "none" -h 20;
			text -l "After editing pose, then:";
			rowLayout -en 0 -nc 3 -cw3 55 55 55 asDSEditChoicesRowLayout;
				button -w 50 -l "Apply" -c asDrivingSystemEditApply;
				checkBox -v 1 -l "mirror" asDrivingSystemMirrorCheckBox;
				button -w 50 -l "Cancel" -c asDrivingSystemEditCancel;
				setParent..;
			setParent..;
		setParent..;


	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				setParent..;
			separator -h 10;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
				text -l "First select Control(s) to replace,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then select (add) any custom curve,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then:";
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Motion Capture" asBodyMotionCaptureFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Skeleton:";
				button -w 60 -l "Create" -c asCreateMoCap;
				button -w 60 -l "Delete" -c asDeleteMocap;
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "FK/IK:";
				button -w 60 -l "Set All FK" -c asSetAllFK;
				button -w 60 -l "Default" -c "asGoToBuildPose bodySetup";
				setParent..;
			rowLayout -nc 4 -cw4 60 60 38 100;
				text -l "Bvh file:";
				button -w 60 -l "Read" -c asReadBVH;
				floatField -w 38 -v 120 -pre 1 -ann "set frames per second (in bvh file)" asBVHfps;
				button -w 60 -l "Delete" -c asDeleteBHV;
				setParent..;
			rowLayout -nc 3 -cw3 60 100 100;
				text -l "Mapping:";
				button -w 60 -l "Connect" -c asAutoMapMocap;
				button -w 60 -l "Disconnect" -c asDeleteMocapMap;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Partial Joints" asBodyPartialJointsFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Create" -c asCreatePartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveFrameLayout;
		columnLayout -adj 0;
			text -l "Go to pose to correct, then:";
			text -l "Select mesh to correct, then:";
			rowLayout -nc 2;
				button -en (!$csm) -l "Create Corrective Shape" -c asCreateCorrectiveShape asCreateCorrectiveButton;
				checkBox -v 1 -l "Angle Rotations" asCorrectiveAngleCheckBox;
				setParent..;
			text -l "Or, Right Click on any of these buttons,\nto access existing Corrective Shapes";
			rowLayout -nc 4 -cw4 55 55 55 55;
				button -w 50 -en (!$csm) -l "Edit" asEditCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Graph" asGraphCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
				setParent..;
			separator -st "none" -h 20;
			text -l "After sculpted shape, then:";
			rowLayout -en $csm -nc 3 -cw3 55 55 55 asCorrectiveEditChoicesRowLayout;
				button -l "Apply" -c asConnectCorrectiveShape;
				checkBox -v 1 -l "mirror" asCorrectiveMirrorCheckBox;
				button -l "Cancel" -c asCancelCorrectiveShape;
				setParent..;
			checkBox -l advanced -onc "columnLayout -e -m 1 asCorrectiveAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asCorrectiveAdvancedColumnLayout";
			columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
				separator -h 15 -st none;
				text -l "Bake Deformations to Corrective Shapes:";
				rowLayout -nc 2;
					button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
					textField -w 100 -ed 0 asBakeToCorrective1TextField;
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
					textField -w 100 -ed 0 asBakeToCorrective2TextField;
					setParent..;
				text -l "rotations:";
				rowLayout -nc 6;
					checkBox -l "+x" -v 1 asBakeX1CheckBox;
					checkBox -l "+y" -v 1 asBakeY1CheckBox;
					checkBox -l "+z" -v 1 asBakeZ1CheckBox;
					checkBox -l "-x" -v 1 asBakeX2CheckBox;
					checkBox -l "-y" -v 1 asBakeY2CheckBox;
					checkBox -l "-z" -v 1 asBakeZ2CheckBox;
					setParent..;
				text -l "Select FK controller, then:";
				button -w 120 -l "Bake" -c asBakeIntoCorrectiveShapes;
				setParent..;
			setParent..;
		setParent..;

	setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 0;
			button -l "Create Face FitSkeleton Node" -c asCreateFaceFitSkeleton;
			rowLayout -nc 2;
				text -l "Then move and scale this,";
				button -w 20 -l "?" -c "asFaceHelpImage faceFitSkeletonNode";
				setParent..;
			text -l "lower circle just under the character`s jaw";
			text -l "upper circle just above the character`s head";
			separator -h 10;

			text -l "Choose Geometry";
			text -l " * = Optional";
			rowLayout -nc 2;
				button -w 120 -l "Face" -c "asChooseInput asFaceGeometryTextField";
				textField -w 100 -ed 0 -tx $geometry asFaceGeometryTextField;
				setParent..;
			rowLayout -nc 2;
				button -w 120 -l "All Head" -c "asChooseInput asFaceAllFaceGeoTextField";
				textField -w 100 -ed 0 -tx $allFaceGeoString asFaceAllFaceGeoTextField;
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Left Eye" -c "asChooseInput asFaceEye_LTextField";
				textField -w 100 -ed 0 -tx $eyeL asFaceEye_LTextField;
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Right Eye" -c "asChooseInput asFaceEye_RTextField";
				textField -w 100 -ed 0 -tx $eyeR asFaceEye_RTextField;
				setParent..;
			separator -h 7;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Upper Teeth" -c "asChooseInput asFaceUpperTeethTextField";
				textField -w 100 -ed 0 -tx $upperTeeth asFaceUpperTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Lower Teeth" -c "asChooseInput asFaceLowerTeethTextField";
				textField -w 100 -ed 0 -tx $lowerTeeth asFaceLowerTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Tongue" -c "asChooseInput asFaceTongueTextField";
				textField -w 100 -ed 0 -tx $tongue asFaceTongueTextField;
				text -l "*";
				setParent..;
			separator -h 10;
			checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				separator -h 15;
				text -l "This section is for using FaceSetup with\nrigs not generated with AdvancedSkeleton.";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx $headJoint asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 -tx $skinCluster asFaceSkinClusterTextField;
				setParent..;
			checkBox -m 1 -l "symmetry test" -onc "columnLayout -e -m 1 asFaceTestinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceTestinputColumnLayout";
			columnLayout -m 0 asFaceTestinputColumnLayout;
				separator -h 15;
				text -l "FaceSetup required symmetrical geometry.";
				text -l "This section lets you test the symmetry.";
				button -l "Duplicate Face Geometry" -c asFaceCreateTestDuplicate;
				separator -h 10;
				text -l "The duplicate should match 100%\n with the slider at both ends";
				floatSlider -w 120 -min -1 -max 1 -value -1 -step 0.01 asFaceDuplicateSlider;
				separator -h 10;
				button -l "Delete Test Geometry" -c "delete FaceSymmetryTestGroup";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0;
		$checkValue=`objExists FaceFitEyeBall`;
		rowLayout -nc 4;
			button -w 100 -l EyeBall -c asBuildFitEyeBall;
			separator -w 5 -st none;
			checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox EyeBall" asFaceEyeBall;
			button -w 15 -l "?" -c ("asFaceHelpImage fitFaceEyeBall");
			setParent..;
		separator -h 18 -w 242;

		text -l "For the next steps:";
		text -l "Place the locators in 2D (Front View)";
		text -l "then \"project\"";
		text -l "Note: Some locators have \"fineCtrl\" attribute";
		text -l "which will display more locators.";
		text -l "*Optional:";
		text -l "  First select edge(loops) for automatic placement";
		separator -st none -h 10;

		string $sections[]={"EyeLid","EyeBrow","Lip","noseCorner","cheek","Jaw","Nose","Tongue"};
		string $parts[]={"Main","Outer"};
		int $upAndLo[]={1,0,1,0,0,0,0,0};
		int $mainAndOuter[]={1,1,0,0,0,1,0,0};
		float $radiuss[]={0.4,1.0,2.0,1.0,1.0,1.0,2.0,1.0};
		int $isSphere[]={0,0,0,1,1,0,0,0};
		int $place2D[]={1,1,1,1,1,0,0,0};
		for ($c=0;$c<size($sections);$c++)
			{
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Main","Outer"};
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;

				if ($c==5 && $a==0)
					{
					text -l "For the next steps:";
					text -l "Place the locators in 3D";
					}

				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 6;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$radiuss[$c]+" "+$isSphere[$c]);
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFace"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asFaceHelpImage fitFace"+$sections[$c]+$parts[$a]);
					separator -w 10 -st none;
					if ($place2D[$c])
						button -w 80 -l "project" -c ("asFaceFitProject "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]);
					if ($sections[$c]=="Tongue")
						text -l "*Optional";
					setParent..;
				}
			}
		separator -h 18 -w 242;

			rowLayout -nc 2;
				text -l "EyeBrows:";
				optionMenu asFaceEyeBrowsStyleOptionMenu;
					menuItem -l "realistic (sliding)";
					menuItem -l "cartoony(free)";
				setParent..;
			button -w 140 -l "Animate Fit" -c asAnimateFaceFit;
			rowLayout -nc 2 -cw2 115 150;
				text -l " Tweak locator animation";
				button -w 20 -l "?" -c "asFaceHelpImage fitFaceAnimate";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2 asFaceRebuildKeepBSRowLayout;
				separator -w 120 -st none;
				checkBox -l "Keep BlendShapes" -v 1 asFaceKeepBlendShapes;
				setParent..;
			rowLayout -nc 4;
				separator -w 15 -st none;
				button -w 60 -l FitMode -c asToggleFitModeFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -w 140 -l "Build AdvancedFace" -c asBuildAdvancedFace asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBrows" asFaceBrowsFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			text -l "Select EyeBrows, then:";
			separator -st "none" -h 10;
			button -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeLashes" asFaceLashesFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			text -l "Select EyeLashes, then:";
			separator -st "none" -h 10;
			button -l "SkinBind" -c "asFaceSkinEyeLashes";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			button -l "Create HeadSquash" -c "asAdvancedSquash";
			separator -st "none" -h 10;
			button -l "Optimize HeadSquash" -c "asOptimizeSquash";
			text -fn "smallBoldLabelFont" -l "To make sure only head";
			text -fn "smallBoldLabelFont" -l "and no other parts of body gets squashed";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EditBlendShapes" asFaceEditBlendShapesFrameLayout;
		columnLayout -adj 0;
			text -l "Set controls to the shape for adjustment, then";
			rowLayout -nc 3;
				button -l "create blendShape target" -c "asBSAdjustTarget";
				separator -w 70 -st none;
				button -h 15 -l "reset" -c "asBSResetTarget";
				setParent..;
			floatSlider -en 0 -w 120 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
			rowLayout -nc 3;
				text -l "Delete the targets when finished";
				separator -w 20 -st none;
				button -h 18 -l delete -c "delete deleteThis";
				setParent..;
			separator -h 20 -w 242;
			text -l "Or step through ALL the BlendShape targets,";
			text -l "with the blendShapes wizard:";
			rowLayout -nc 3 -cw3 150 30 50;
				button -l "start blendShapes wizard" -c "asBSWizard";
				button -en 0 -l "?" -c "asFaceHelpImage asBSWizardStep0" asBSWizardHelpButton;
				button -en 0 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
				setParent..;
			rowLayout -nc 3 -cw3 50 150 50;
				text -en 0 -l "0/37" asBSWizardStepText;
				text -en 0 -l "..." asBSWizardObjAttrText;
				text -en 0 -l "..." asBSWizardValueText;
				setParent..;
			button -l "stop blendShapes wizard" -c "asBSWizardStop";
			separator -h 20 -w 242;
			text -l "Or extract All targets:";
			button -l "extract All targets" -c "asBSExtractAll";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " TweakControllers" asFaceTweakControlsFrameLayout;
		columnLayout -adj 0;
			text -fn "smallBoldLabelFont" -l "*This is only for `Cluster-based` controllers\n (the cyan-colored spheres & lip spheres)";
			separator -h 15 -st none;
			text -l "Create:";
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Create a softmod, then";
					checkBox -l "Mid" asFaceIsMiddleControlCheckBox;
					button -l "Create new Control from selected SoftMod" -c "asFaceConvertSoftModToControl 0";
					setParent..;
				setParent..;
			text -l "Edit:";
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					button -l "Paint weights for selected Control" -c asFacePaintControllerWeights;
					button -l "Convert selected Control to SoftMod" -c asFaceConvertControlToSoftMod;
					button -l "Convert SoftMod Back to Control" -c "asFaceConvertSoftModToControl 1";
					button -l "Mirror weights for selected Control (R>L)" -c asFaceMirrorControllerWeights;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
		setParent..;
	setParent..;
/*
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Extra" asExtraFrameLayout;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Optimize" asBodyOptimizeFrameLayout;
		columnLayout -adj 0;
			button -l "Remove Unused influences" -c asRemoveUnusedInfluences;
			button -l "Prune clusters" -c asRemoveUnusedInfluences;
			button -l "Delete unused nodes" -c MLdeleteUnused;
			setParent..;
		setParent..;
	setParent..;
*/
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;

	columnLayout;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "PoserDesigner" -c asPoserDesigner;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "WalkDesigner" -c asWalkDesigner;
			setParent..;
		setParent..;

	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;
/*
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "setAttr Main.jointVis 0";
			button -w 60 -l "Show" -c "setAttr Main.jointVis 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointVis 0";
			button -w 60 -l "Show" -c "asJointVis 1";
			setParent..;
*/

		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;

		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;

		rowLayout -nc 3 -cw3 73 100 100;
			separator;
			button -w 150 -l "Select jointLayer" -c "select jointLayer;AttributeEditor";
			setParent..;

		setParent..;
	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\")";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Prune Clusters" -c asPrunAllClusters;
			setParent..;
		setParent..;
	setParent..;


frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Help" asHelpFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 6 -cw6 100 20 40 40 40 40;
			button -l "Open Help Files" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton4/help\"";
			separator;
			text -l "window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			setParent..;
	separator -h 5;
		rowLayout -nc 5;
			button -l "Check For Updates" -c asCheckForUpdates;
			text -l "  update found:";
			text -m 1 -l "x.xxx" asUpdateFoundVersion;
			button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;
	separator -h 5;
		rowLayout -nc 4;
			text -l "current version:";
			button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version\"";
			popupMenu asVersionsPopupMenu;
			setParent..;
		setParent..;
	setParent..;
setParent..;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;

formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;

if($asDock)
	{
	dockControl -l AdvancedSkeleton -w 296 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
	evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
	}
else
	showWindow;
asUpdateButtonEnables;
asFitSkeletonConnectControl;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}

if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
    if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
        if (`optionVar -ex $framLayouts[$i]`)
            frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//populate layoutFiles optionMenu
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton4Files/fitSkeletons/";
string $layoutFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($layoutFiles);$i++)
	{
	if (`gmatch $layoutFiles[$i] "[.]*"` || $layoutFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $layoutFiles[$i];
	}

//populate asVersionsPopupMenu
string $oldVersionsDir=`asGetScriptLocation`+"/AdvancedSkeleton4Files/oldVersions/";
int $latestLocal;
string $label;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}
//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no nCloth
	}
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton4.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton4.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton4.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton4Files/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton4.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton4;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton4")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asBuildDefaultBiped ()
{
file -f -new;
optionMenu -e -v "Spine" asLimbType;asFitChangeLimbType;
asCreateLimb;
optionMenu -e -v "Leg" asLimbType;asFitChangeLimbType;
asCreateLimb;
optionMenu -e -v "Arm" asLimbType;asFitChangeLimbType;
asCreateLimb;
optionMenu -e -v "Neck" asLimbType;asFitChangeLimbType;
asCreateLimb;

string $topNodesBefore[]=`ls -as`;
file -i (`asGetScriptLocation`+"/AdvancedSkeleton4Files/div/asDrivingSystemFingers.ma");
string $topNodesAfter[]=`ls -as`;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		parent $topNodesAfter[$i] Systems;

asToggleFitMode;
setAttr "Shoulder.Scapula" 1;
asToggleFitMode;
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeleton4File=`asGetScriptLocation`+"/AdvancedSkeleton4.mel";
string $fDet,$fDet2;
int $fileId=`fopen $AdvancedSkeleton4File "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeleton4Files/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	{
	string $selectorFile=$selectorsDir+$selectorFiles[$i];
	int $fileId=`fopen $selectorFile "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $selectorFile "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
print ("Updated:"+$selectorFiles[$i]+"\n");
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asConvertJointChainToLimb ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeHierarchy;
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Select joint to convert";
if (`objectType $sel[0]`!="joint")
	error "Selection must be joint";

if ($asFitModeScriptJob1Nr==0)
	asToggleFitMode;
if ($asFitModeHierarchy)//For now, just exit HierarchyMode, as we dont know how to preserve this ..yet
	asToggleFitModeHierarchy;
if (!`objExists FitSkeleton`)
	asCreateFitSkeleton;

$scale=`getAttr FitSkeleton.sx`;
string $previousLoc,$starLoc,$endLoc,$endEndLoc;
string $decendants[]=`listRelatives -type joint -ad $sel[0]`;
$decendants[size($decendants)]=$sel[0];
string $joints[];
for ($i=size($decendants)-1;$i>-1;$i--)
	$joints[size($joints)]=$decendants[$i];
for ($i=0;$i<size($joints);$i++)
	rename $joints[$i] ($joints[$i]+"OldJoint");

for ($i=0;$i<size($joints);$i++)
	{
	float $pos[]=`xform -q -ws -t ($joints[$i]+"OldJoint")`;
	$pos[0]/=$scale;
	$pos[1]/=$scale;
	$pos[2]/=$scale;
	$name=$joints[$i];
	if ($i==size($joints)-1)
		$name=$joints[$i-1]+"End";
	$loc=`asCreateLimbLoc $name {$pos[0],$pos[1],$pos[2]} {1.0,1.0,1.0} 0`;
	if ($i>0)
		connectAttr ($loc+".message") ($previousLoc+".child");
	if ($i==0) $starLoc=$loc;
	if ($i==size($joints)-2) $endLoc=$loc;
	if ($i==size($joints)-1) $endEndLoc=$loc;
	$previousLoc=$loc;
	}
//system connect
string $limbType="Basic";
string $sl=`asGetLimbLetter $limbType`;
string $system=`asCreateSystem "Basic" $sl`;
connectAttr ($starLoc+".message") ($system+".start");
connectAttr ($starLoc+".message") ($system+".mid");
connectAttr ($endLoc+".message") ($system+".end");
connectAttr ($endEndLoc+".message") ($system+".endEnd");

asEnsureSystem $system;
select -cl;
}

global proc asSwapCurve ()
{
string $side,$oppositeSide;
string $tempString[];
string $sel[]=`ls -sl`;
int $last=`size($sel)`-1;
string $selShapes[];
if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	if ($i==$last && `sets -im ControlSet $sel[$i]`)
		error ("\""+$sel[$i]+"\" is a control. The new curve must be select last, and must not be a existing control");
	}
select $sel[$last];
DeleteHistory;
//flip around the replacememnt curve, to make the orientation more intuitive
string $offset=$sel[$last]+"Offset";
if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
	if (!`objExists $offset`)
		{
		$tempString=`listRelatives -s $sel[$last]`;
		for ($y=0;$y<size($tempString);$y++)
			if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
				rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:99]");
		createNode -n $offset transform;
		asAlign $offset $sel[$last] 1 1 0 0;
		parent $sel[$last] $offset;
		rotate -r -os 90 0 90 $offset;
		}
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	$tempString=`listRelatives -s $sel[$last]`;
	for ($y=0;$y<size($tempString);$y++)
		parent -add -s $tempString[$y] $sel[$i];
	delete $selShapes[$i];
	if (`gmatch $sel[$i] "*_R"` || `gmatch $sel[$i] "*_L"`)
		{
		if (!`objExists ($sel[$last]+"Mirrored")`)
			{
			duplicate -n ($sel[$last]+"Mirrored") $sel[$last];
			setAttr ($sel[$last]+"Mirrored.v") 0;
			int $numCv;
			$form=`getAttr ($sel[$last]+".form")`;
			$spans=`getAttr ($sel[$last]+".spans")`;
			$degrees=`getAttr ($sel[$last]+".degree")`;
			if ($form==2)
				$numCv=$spans;
			else
				$numCv=$spans+$degrees;
			for ($y=0;$y<$numCv;$y++)
				{
				createNode -n ($sel[$last]+"MirroredMultiplyDivide"+$y) multiplyDivide;
				connectAttr ($sel[$last]+".cv["+$y+"]")  ($sel[$last]+"MirroredMultiplyDivide"+$y+".input1");
				setAttr -type float3 ($sel[$last]+"MirroredMultiplyDivide"+$y+".input2") -1 -1 -1;
				connectAttr ($sel[$last]+"MirroredMultiplyDivide"+$y+".output") ($sel[$last]+"Mirrored.cv["+$y+"]");
				}
			}

		if (`gmatch $sel[$i] "*_R"`) {$side="_R";$oppositeSide="_L";}
		if (`gmatch $sel[$i] "*_L"`) {$side="_L";$oppositeSide="_R";}
		if(`gmatch $sel[$i] "IK*"` || `gmatch $sel[$i] "Pole*"`)
			$tempString=`listRelatives -s $sel[$last]`;
		else
			$tempString=`listRelatives -s ($sel[$last]+"Mirrored")`;
		for ($y=0;$y<size($tempString);$y++)
			parent -add -s $tempString[$y] `substitute $side $sel[$i] $oppositeSide`;
		delete `substitute $side $selShapes[$i] $oppositeSide`;
		}
	}
	dgdirty -a;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
float $poseValue,$currentValue;
float $runValues[];
string $tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				$poseValue=$runValues[$y];

		if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
			$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
		}
	}

if ($newRunCmds=="")
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;
setAttr -type "string" ($fitSkeleton+".run") ($runCmd+";"+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
int $numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}

//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

if ($tool=="Poser")
	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName,$file;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`internalVar -utd`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c asJointsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"evalEcho saveInitialState -all\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"evalEcho InteractivePlayback\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l UnBake -c \"asDynUnBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=$menuItems[$i]+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	string $buffer[];
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[7]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"asSelChangeToggle;optionVar -iv asShowSelection 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowSelection 0\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"asSelChangeToggle;optionVar -iv asShowKeyed 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowKeyed 0\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeleton4File=`asGetScriptLocation`+"/AdvancedSkeleton4.mel";
int $fileId2=`fopen $AdvancedSkeleton4File "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
string $nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

int $fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed`)
	return;
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
if (`about -linux`)
	$ext=".xpm";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;
for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && !$asSelChangeSwitching && `objExists $obj`)
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="")
			return;
		$numTok=`tokenize $currImage "_" $buffer`;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;		
		}
	}
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;		
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "IK2FK";
}

global proc asAlignFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "FK2IK";
}

global proc asSwitchIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $name, string $objs[], string $alignSwitchCmd, string $W2K)
{
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" "+$name+" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $tempLoc1[],$tempLoc2[],$tempConstraint[];
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
float $tempFloat[],$alignIkToFloat[];
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

if ($W2K=="FK2IK")
	{
	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	delete $tempConstraint[0];
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr -type float3 ($tempLoc2[0]+".translate") ($charsize/3.333) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
	}
else
	{
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$startJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$startJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$middleJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		$tempFloat=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FKToes"+$side);
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;
setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");	

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");

if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

currentTime (`currentTime -q` +1);


asAlignFKIK $name $IK $side $W2K;


setAttr ($controlCurve+".FKIKBlend") $Blend;
setAttr ($poleCurve+".follow") 0;

setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;
for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`objExists ($nameSpace+":Main")`)
		if (`attributeExists "version" ($nameSpace+":Main")`)
			if (`asFilterCheck $name $nameSpace`)
				menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $result=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$result=1;
	}
return $result;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "Setting nameSpace from selected object\n";
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
string $cmd=`asPoserGetCmd $uiName $anim`;
if (!$anim)
	menuItem -e -en 1 -c $cmd ($uiName+"PosePaste");
else
	menuItem -e -en 1 -c ($cmd+" 0") ($uiName+"AnimPaste");
}

global proc string[] asGetControlSetsFromUI (string $uiName)
{
string $controlSets[];
string $tempString[];
string $controlSetsText;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (`text -q -ex ($uiName+"ControlSetsText")`)
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asDeleteStaticChannels (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("Static channels cleaned\n");
select $sel;
}
	
global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;
if ($uiName=="asPoserDefault")
	{
	if (`checkBox -q -ex asPoserOnlySel`)
		$onlySel=`checkBox -q -v asPoserOnlySel`;
	}
else if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
if (`gmatch $uiName "asPoser*"`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`gmatch $gridOrder[$i-1] "asPoser*"`)
			$childNum=$i;
	$childNum++;

	$animationFile="untitled_"+$childNum;
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
	}
else
	{
	$animationFile="ClipBoard";
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Selector/";
	}

string $animCurves[];

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

	{
for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+" "+$animCurves[$y]+";";
						}
					}
				}
		}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
string $sel[]=`ls -sl`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -e -st 0;
createNode -n tempXform transform;
int $shiftButton,$ctrlButton,$altButton;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $buffer[],$buffer2[],$buffer3[],$tempString[];
string $obj,$attr,$objAttr,$animCurve,$newAnimCurve;
float $value;

string $animationFile,$projectName;

if ($childNum==0)
	{
	$projectName="Selector";
	$animationFile=`internalVar -utd`+"AdvancedSkeleton/Selector/ClipBoard.ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$animationFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $animationFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	$value=$buffer2[1];
	$animCurve=$buffer2[2];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		{
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
		if (!`attributeExists $attr tempXform`)
			addAttr -k 1 -ln $attr -at double tempXform;
		connectAttr -f ($projectName+":"+$animCurve+".output") ("tempXform."+$attr);
		copyKey -time ":" -hierarchy none -at $attr tempXform;
		pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {$obj};
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr  $animationFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".jpg"`;
print ($mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror "+$uiName);
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
if (!`window -q -ex $uiName`)
	error ("Window : "+$uiName+" not found !");
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $sortedControls[];
if (`stringArrayCount "Main" $controlSets`)
	$sortedControls={"Main","RootX_M","CenterExtra_M"};

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg_*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm_*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];
$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$cmd,$loc1,$loc2;
float $pos[3],$rot[3];
int $wsXform[];
int $flip;
int $isFaceControl;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$flip=1;
		if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
		 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`)
		 	{
		 	if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ty" || $allKeyableAttrs[$y]=="tz")
		 		$flip=-1;
		 	}
		else
			if ($allKeyableAttrs[$y]=="tz" || $allKeyableAttrs[$y]=="rx" || $allKeyableAttrs[$y]=="ry")
				$flip=-1;
		if ($isFaceControl && !`gmatch $controls[$i] ($nameSpace+"ctrl*")`)
			{
			if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ry" || $allKeyableAttrs[$y]=="rz")
				$flip=-1;
			else
				$flip=1;
			}
		if (`gmatch $controls[$i] ($nameSpace+"Aim*")` || `gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")` || `gmatch $controls[$i] ($nameSpace+"RootX_M*")`)
			$wsXform[$i]=1;
		if (!$wsXform[$i])
			if (`getAttr -se ($dest+"."+$allKeyableAttrs[$y])`)
				$cmd+="setAttr "+$dest+"."+$allKeyableAttrs[$y]+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
eval ($cmd);
select $sel;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$cmd,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($nameSpace=="")
			catch (`evalEcho ($run)`);
		else
			{
			tokenize $run ";" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				tokenize $tempString[$i] $tempString2;
				$objAttr=`substitute "\"" $tempString2[1] ""`;
				$objAttr=`substitute "\"" $objAttr ""`;
				$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
				catch (`evalEcho ($cmd)`);
				}
			}
		}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	string $dynObj="dynamics"+`substitute ($nameSpace+"FK") $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		delete $dynObj;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}
}

global proc asDynAdd (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
global string $gSelect;
setToolTo $gSelect;

string $deformJoints[];
for ($i=0;$i<size($sel);$i++)
	{
	$deformJoints[$i]=`substitute ($nameSpace+"FK") $sel[$i] ($nameSpace+"")`;
	if (`objExists ("dynamics"+$deformJoints[$i])`)
		error ("dynamics for "+$deformJoints[$i]+" already exists");
	}
$dynSortedDeformJoints=`asResolveDynJoints $nameSpace $deformJoints`;
asDynAddChain $nameSpace $dynSortedDeformJoints;
}

global proc asDynAddChain (string $nameSpace, string $dynSortedDeformJoints[])
{
string $dynJoints[],$tempString[];
string $name;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	select $dynSortedDeformJoints[$i];
	$dynJoints[$i]="dyn"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`+$i;
	joint -n $dynJoints[$i];
	}
string $startJoint=$dynJoints[0];
string $endJoint=$dynJoints[size($dynJoints)-1];

string $dynTopNode="dynamics"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`;
if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n ($dynJoints[0]+"Offset") transform;
int $foundParentFK;
string $parentFK,$fk;
string $joint=$dynSortedDeformJoints[0];
while($parentFK=="")
	{
	$tempString=`listRelatives -type joint -p $joint`;
	if ($tempString[0]=="")
		$parentFK=$nameSpace+"RootX_M";
	else
		{
		$joint=$tempString[0];
		if ($nameSpace=="")
			$fk="FK"+$joint;
		else
			$fk=`substitute $nameSpace $joint ($nameSpace+"FK")`;
		if (`objExists $fk`)
			$parentFK=$fk;
		}
		
	}
parentConstraint $parentFK ($dynJoints[0]+"Offset");
createNode -n $dynTopNode transform;
parent ($dynJoints[0]+"Offset") $dynTopNode;
parent $dynTopNode Dynamics;
setAttr ($dynTopNode+".overrideEnabled") 1;
setAttr ($dynTopNode+".overrideDisplayType") 2;

for ($i=1;$i<size($dynJoints);$i++)
	parent $dynJoints[$i] $dynJoints[$i-1];
string $tempString[]=`ikHandle -n ("DynIKHandle"+$endJoint) -ns 2 -sol ikSplineSolver -sj $startJoint -ee $endJoint`;
rename $tempString[1] ("DynIKEffector"+$endJoint);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$endJoint)`;
parent ("DynIKHandle"+$endJoint) $dynTopNode;

parent $dynJoints[0] ($dynJoints[0]+"Offset");

//remove existing
string $dynNodes[]={("DynParticle"+$endJoint),("DynIKCurveSoft"+$endJoint),("DynParticleArrayMapper"+$endJoint),("DynParticleRamp"+$endJoint)};
for ($node in $dynNodes)
	if (`objExists $node`)
		delete $node;

//$numCv
int $numCv;
$form=`getAttr ($ikCurve+".form")`;
$spans=`getAttr ($ikCurve+".spans")`;
$degrees=`getAttr ($ikCurve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//soft
$tempString=`soft -d -g 1 -c ("DynIKCurve"+$endJoint)`;
rename $tempString[0] ("DynParticle"+$endJoint);
$tempString=`listRelatives -p ("DynParticle"+$endJoint)`;
rename $tempString[0] ("DynIKCurveSoft"+$endJoint);
rename ("copyOfDynIKCurve"+$endJoint)  ("copyOfDynIKCurveDeform"+$endJoint);
parent ("DynIKCurveSoft"+$endJoint) ("copyOfDynIKCurveDeform"+$endJoint) $dynTopNode;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	float $massPP=($i+0.00)/$numCv;
	if ($massPP==0)
		$massPP=0.01;
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$endJoint);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$endJoint) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$endJoint);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$endJoint+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$endJoint);
removeMultiInstance -break true ("DynParticleRamp"+$endJoint+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].position") 1;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].color") -type double3 1 1 1 ;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].color") -type double3 0 0 0;

string $fkEnd;
int $arrayNr=size($dynSortedDeformJoints)-1;
if ($nameSpace=="")
	$fkEnd="FK"+$dynSortedDeformJoints[$arrayNr];
else
	$fkEnd=`substitute $nameSpace $dynSortedDeformJoints[$arrayNr] ($nameSpace+"FK")`;
if (!`attributeExists blend $fkEnd`)
	addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists baseGoal $fkEnd`)
	addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists tipGoal $fkEnd`)
	addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $fkEnd;
if (!`attributeExists conserve $fkEnd`)
	addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $fkEnd;
connectAttr ($fkEnd+".baseGoal") ("DynParticleArrayMapper"+$endJoint+".maxValue");
connectAttr ($fkEnd+".tipGoal") ("DynParticleArrayMapper"+$endJoint+".minValue");
connectAttr ($fkEnd+".conserve") ("DynParticle"+$endJoint+".conserve");

//skinCurve
select -cl;
string $fkx;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($nameSpace=="")
		$fkx="FKX"+$dynSortedDeformJoints[$i];
	else
		$fkx=`substitute $nameSpace $dynSortedDeformJoints[$i] ($nameSpace+"FKX")`;
	if (`objExists $fkx`)
		select -add $fkx;
	}
select -add ("copyOfDynIKCurveDeform"+$endJoint);
newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false";

//pairBlend
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($i>0)
		{
		$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at tx -at ty -at tz`;
		rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		}
	$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($fkEnd+".blend") ("parBlendR"+$dynJoints[$i]+".weight");
	}

setAttr -l 1 ($startJoint+"Offset.v") 0;
setAttr -l 1 ("DynIKHandle"+$endJoint+".v") 0;
setAttr -l 1 ("copyOfDynIKCurveDeform"+$endJoint+".v") 0;

select $fkEnd;
}

global proc string[] asResolveDynJoints (string $nameSpace, string $joints[])
{
string $dynJoints[];
string $jointLongNames[],$tempStringA[],$tempStringB[];
for ($i=0;$i<size($joints);$i++)
	{
	$tempStringA=`ls -l $joints[$i]`;
	$jointLongNames[$i]=$tempStringA[0];
	}
string $sorted[]=`sort $jointLongNames`;
for ($i=1;$i<size($sorted);$i++)
	{
	$tempStringA=`ls $sorted[$i]`;
	$tempStringB=`ls $sorted[$i-1]`;
	if (!`gmatch $sorted[$i] ($sorted[$i-1]+"*")`)
	error ("\""+$tempStringA[0]+"\" is not a child of \""+$tempStringB[0]+"\", select controls in same hiarchy");
	}

string $dynEndJointLongName=$sorted[size($sorted)-1];
$tempStringA=`ls -sn $dynEndJointLongName`;
$dynJoints[0]=$tempStringA[0];
string $joint=$dynJoints[0];
int $reachedStartJoint,$reachedParentOfStartJoint;
while (!$reachedStartJoint)
	{
	$tempStringA=`listRelatives -p -f -type joint $joint`;
	if (!size($tempStringA))
		break;
	$jointLongName=$tempStringA[0];
	$tempStringA=`ls -sn $tempStringA[0]`;
	$joint=$tempStringA[0];
	if (size($joints)==1)
		{
		//single control selected
		if (!`stringArrayCount $jointLongName $sorted`)
			if (!`gmatch $joint "*Part[0-9]*"`)
				$reachedStartJoint=1;
		}
	else
		{
		//several controls selected
		if ($jointLongName==$sorted[0])
			$reachedStartJoint=1;
		}
	$dynJoints[size($dynJoints)]=$joint;
	}
string $dynJointReverse[];
for ($i=size($dynJoints)-1;$i>-1;$i--)
	$dynJointReverse[size($dynJointReverse)]=$dynJoints[$i];
return $dynJointReverse;
}

global proc asAnimBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Bake character ?\n"
	+"This creates a single joint chain for game engine export\n"
	+"The rig controllers will no longer work")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $name=`substitute ":" $nameSpace ""`;
string $bakeNameSpace=$name+"Bake:";
namespace -add ($name+"Bake");
namespace -set ($name+"Bake");
$tempString=`listRelatives -c ($nameSpace+"DeformationSystem")`;
$tempString=`duplicate $tempString[0]`;
string $topBakeJoint=$tempString[0];
parent -w $topBakeJoint;
$tempString=`listRelatives -ad $topBakeJoint`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`!="joint")
		delete $tempString[$i];
string $allBakeJoints[]=`listRelatives -ad -type joint $topBakeJoint`;
$allBakeJoints[size($allBakeJoints)]=$topBakeJoint;
sets -rm ($nameSpace+"DeformSet") $allBakeJoints;
//Disable Skincluster
string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 1;
//Constraint bakeSkeleton
string $deformJoints[]=`listRelatives -ad -type joint ($nameSpace+"DeformationSystem")`;
for ($i=0;$i<size($deformJoints);$i++)
    {
		if ($nameSpace=="")
			$bakeDeformJoint=$bakeNameSpace+$deformJoints[$i];
		else
			$bakeDeformJoint=`substitute $nameSpace $deformJoints[$i] $bakeNameSpace`;
    parentConstraint $deformJoints[$i] $bakeDeformJoint;
//    scaleConstraint $deformJoints[$i] $bakeDeformJoint;//caues issues with overall scale
    }
//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $allBakeJoints;
//Transfer deformation to bake skeleton
for ($i=0;$i<size($deformJoints);$i++)
{
    $tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $deformJoints[$i]`;
    for ($y=0;$y<size($tempString);$y=$y+2)
        {        
        if ($nameSpace=="")
        	$newSource=$bakeNameSpace+$tempString[$y];
				else
	        $newSource=`substitute $nameSpace $tempString[$y] $bakeNameSpace`;
        catch (`connectAttr -f $newSource $tempString[$y+1]`);
        }
}
//Enable Skincluster
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 0;

namespace -set ":";
select $allBakeJoints;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select $topBakeJoint;
print ("Selected joint chain is ready for export, add geometry to selection and export\n");
}

global proc asDynBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
asDynUnBake $uiName;
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints true -shape false $softDynCurves;
}

global proc asDynUnBake (string $uiName)
{
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
string $particles;
int $spans,$degrees,$numCv;
for ($i=0;$i<size($softDynCurves);$i++)
	{
	$particles=`substitute "DynIKCurveSoft" $softDynCurves[$i] "DynParticle"`;
	$particles=`substitute "Shape" $particles ""`;
	if (!`isConnected ($particles+".targetGeometry") ($softDynCurves[$i]+".create")`)
		connectAttr ($particles+".targetGeometry") ($softDynCurves[$i]+".create");
	if (size(`listConnections -type animCurve $softDynCurves[$i]`))
		delete `listConnections -type animCurve $softDynCurves[$i]`;
	$spans=`getAttr ($softDynCurves[$i]+".spans")`;
	$degrees=`getAttr ($softDynCurves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		setAttr ($softDynCurves[$i]+".cv["+$y+"]") 0 0 0;
	}
}

global proc asJointsVisibilityToggle ()
{
int $vis;
int $firstModelEditor=0;
string $editors[]=`lsUI -editors`;
for ($i=0;$i<size($editors);$i++)
    if (`modelEditor -q -ex $editors[$i]`)
        {
        if (!$firstModelEditor)
            $vis=!(`modelEditor -q -joints $editors[$i]`);
        $firstModelEditor=1;
        modelEditor -e -joints $vis $editors[$i];
        }
}

global proc asControlsVisibilityToggle ()
{
int $vis;
string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`confirmDialog -title "Confirm"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	return;
nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
runTimeCommand -annotation "switches the visibility of controls" -category "User"
	-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
	advancedSkeletonVisibilitySwitch;
hotkey -keyShortcut "`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[];
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";

menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";

menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";

menu "Buttons";
	menuItem -c "asSDNewButtton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -onc "asSelChangeToggle;optionVar -iv asShowSelection 1;" -ofc "asSelChangeToggle;optionVar -iv asShowSelection 0;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -onc "asSelChangeToggle;optionVar -iv asShowKeyed 1;" -ofc "asSelChangeToggle;optionVar -iv asShowKeyed 0;" -l Keyed asSelectorKeyedCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSDNewLayout (int $LayoutType)
{
if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

select -cl;
if ($LayoutType==1)
	{
	asSDNewButtton FKElbow_R 136 78 72 27;
	asSDNewButtton FKShoulder_R 210 75 64 32;
	asSDNewButtton FKWrist_R 92 68 43 43;
	asSDNewButtton RootX_M 188 228 70 24;
		$tempString=`listConnections -p 1 Button_RootX_M.tx`;disconnectAttr $tempString[0] Button_RootX_M.tx;
		setAttr Button_RootX_M.tx 188;
		setAttr -type "string" Button_RootX_M.label Root;
	asSDNewButtton FKRoot_M 270 190 100 38;
	asSDNewButtton FKSpine1_M 270 149 100 38;
	asSDNewButtton FKChest_M 270 108 100 38;
	asSDNewButtton FKHip_R 267 234 48 106;
	asSDNewButtton FKKnee_R 275 346 39 104;
	asSDNewButtton FKAnkle_R 275 451 39 26;
	asSDNewButtton FKToes_R 243 461 30 14;
	asSDNewButtton FKScapula_R 277 67 25 41;
	asSDNewButtton FKNeck_M 304 79 30 26;
	asSDNewButtton FKHead_M 291 3 56 56;

	asSDNewButtton IKArm_R 92 10 43 43;
	asSDNewButtton PoleArm_R 160 22 30 30;
	asSDNewButtton FKIKArm_R 216 21 30 30;
	asSDNewButtton IKLeg_R 205 405 43 43;
	asSDNewButtton PoleLeg_R 210 333 30 30;
	asSDNewButtton FKIKLeg_R 210 261 30 30;
	asSDNewButtton RollHeelLeg_R 215 452 24 24;
	asSDNewButtton RollToes_R 188 452 24 24;
	asSDNewButtton RollToesEnd_R 160 452 24 24;

	asSDNewButtton HipSwinger_M 205 161 43 43;
		$tempString=`listConnections -p 1 Button_HipSwinger_M.tx`;disconnectAttr $tempString[0] Button_HipSwinger_M.tx;
		setAttr Button_HipSwinger_M.tx 205;

	asSDNewButtton Main 20 10 43 20;
		setAttr -type "string" Button_Main.label Main;

	asSDNewButtton FKWrist_R 6 330 140 100;
	asSDNewButtton FKIndexFinger1_R 114 268 32 58;
	asSDNewButtton FKMiddleFinger1_R 78 268 32 58;
	asSDNewButtton FKRingFinger1_R 43 268 32 58;
	asSDNewButtton FKPinkyFinger1_R 6 268 32 58;
	asSDNewButtton FKIndexFinger2_R 114 211 32 52;
	asSDNewButtton FKMiddleFinger2_R 78 211 32 52;
	asSDNewButtton FKRingFinger2_R 43 211 32 52;
	asSDNewButtton FKPinkyFinger2_R 6 211 32 52;
	asSDNewButtton FKIndexFinger3_R 114 167 32 40;
	asSDNewButtton FKMiddleFinger3_R 78 167 32 40;
	asSDNewButtton FKRingFinger3_R 43 167 32 40;
	asSDNewButtton FKPinkyFinger3_R 6 167 32 40;
	asSDNewButtton FKThumbFinger1_R 149 330 32 66;
	asSDNewButtton FKThumbFinger2_R 149 272 32 52;
	asSDNewButtton FKThumbFinger3_R 149 225 32 41;
	asSDNewButtton Fingers_R 31 436 91 24;
		setAttr -type "string" Button_Fingers_R.label Fingers;

	asSDNewButtton FKSpine 188 129 70 24;
		setAttr -type "string" Button_FKSpine.label Spine;
		setAttr -type "string" Button_FKSpine.multiObjs "FKChest_M FKSpine1_M FKRoot_M";
	asSDNewButtton IKSpine1_M 390 204 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine1_M.tx`;disconnectAttr $tempString[0] Button_IKSpine1_M.tx;
		setAttr Button_IKSpine1_M.tx 390;
	asSDNewButtton IKSpine2_M 390 164 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine2_M.tx`;disconnectAttr $tempString[0] Button_IKSpine2_M.tx;
		setAttr Button_IKSpine2_M.tx 390;
	asSDNewButtton IKSpine3_M 390 127 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine3_M.tx`;disconnectAttr $tempString[0] Button_IKSpine3_M.tx;
		setAttr Button_IKSpine3_M.tx 390;
	asSDNewButtton FKIKSpine_M 425 163 30 30;
		$tempString=`listConnections -p 1 Button_FKIKSpine_M.tx`;disconnectAttr $tempString[0] Button_FKIKSpine_M.tx;
		setAttr Button_FKIKSpine_M.tx 425;
	}
if ($LayoutType==2)
	{
	asSDNewButtton browOuter_R 143 20 33 33;
	asSDNewButtton browHalf_R 192 20 33 33;
	asSDNewButtton browInner_R 246 20 33 33;

	asSDNewButtton LidCorner2_R 150 103 33 33;
	asSDNewButtton upperLid1_R 208 67 33 33;
	asSDNewButtton LidCorner1_R 269 103 33 33;
	asSDNewButtton lowerLid1_R 208 139 33 33;
	asSDNewButtton upperLid3_R 178 74 25 25;
	asSDNewButtton upperLid2_R 243 75 25 25;
	asSDNewButtton lowerLid3_R 179 137 25 25;
	asSDNewButtton lowerLid2_R 244 137 25 25;

	asSDNewButtton noseCorner_R 253 251 33 33;
	asSDNewButtton cheek_R 187 311 33 33;

	asSDNewButtton Lip6_R 231 335 33 33;
	asSDNewButtton upperLip0_M 303 306 33 33;
	asSDNewButtton lowerLip0_M 303 358 33 33;
	asSDNewButtton upperLip3_R 271 320 25 25;
	asSDNewButtton lowerLip3_R 271 355 25 25;

	asSDNewButtton ctrlBrow_R 547 30 40 40;
	asSDNewButtton ctrlBrow_L 597 30 40 40;
	asSDNewButtton ctrlEye_R 547 104 40 40;
	asSDNewButtton ctrlEye_L 597 104 40 40;
	asSDNewButtton ctrlCheek_R 547 183 40 20;
	asSDNewButtton ctrlCheek_L 597 183 40 20;
	asSDNewButtton ctrlNose_R 547 245 40 20;
	asSDNewButtton ctrlNose_L 597 245 40 20;
	asSDNewButtton ctrlMouth_M 561 293 65 65;
		$tempString=`listConnections -p 1 Button_ctrlMouth_M.tx`;disconnectAttr $tempString[0] Button_ctrlMouth_M.tx;
		setAttr Button_ctrlMouth_M.tx 561;
	asSDNewButtton ctrlMouthCorner_R 547 377 40 40;
	asSDNewButtton ctrlMouthCorner_L 597 377 40 40;
	asSDNewButtton ctrlTongue_M 561 431 65 15;
		$tempString=`listConnections -p 1 Button_ctrlTongue_M.tx`;disconnectAttr $tempString[0] Button_ctrlTongue_M.tx;
		setAttr Button_ctrlTongue_M.tx 561;
	asSDNewButtton ctrlBox 520 299 13 159;

	asSDNewButtton lips 18 72 71 30;
		setAttr -type "string" Button_lips.label lips;
		setAttr -type "string" Button_lips.multiObjs "Lip6_R upperLip0_M Lip6_L lowerLip0_M";
	asSDNewButtton FKJaw_M 231 411 177 43;
	}

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeelLeg_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}
if ($LayoutType==2)
	{
	asSDNewIcon browOuter_R asBlueSG sphere;
	asSDNewIcon browHalf_R asGreen2SG sphere;
	asSDNewIcon browInner_R asBlueSG sphere;
	asSDNewIcon LidCorner2_R asGreenSG sphere;
	asSDNewIcon upperLid1_R asGreenSG sphere;
	asSDNewIcon LidCorner1_R asGreenSG sphere;
	asSDNewIcon lowerLid1_R asGreenSG sphere;
	asSDNewIcon upperLid3_R asGreen2SG sphere;
	asSDNewIcon upperLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid3_R asGreen2SG sphere;
	asSDNewIcon noseCorner_R asBlue2SG sphere;
	asSDNewIcon cheek_R asBlue2SG sphere;
	asSDNewIcon Lip6_R asGreenSG sphere;
	asSDNewIcon upperLip0_M asGreenSG sphere;
	asSDNewIcon lowerLip0_M asGreenSG sphere;
	asSDNewIcon upperLip3_R asGreen2SG sphere;
	asSDNewIcon lowerLip3_R asGreen2SG sphere;
	
	}
select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}

global proc asSDNewButtton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
string $multiObjString;
string $sel[]=`ls -sl`;
string $buttonName="Button_"+$name;
if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=$sel[$i]+" ";
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

string $tempString[]=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
int $doMirrorBox[];
float $pos[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $annBuffer[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;
for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (!`objExists $mirrorBox`)
			{
			$doMirrorBox[$i]=1;
			$doMirrorBox[size($renderBoxes)]=1;
			$renderBoxes[size($renderBoxes)]=$mirrorBox;
			}
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	createNode -n SelectorScaleSampler transform;
	string $tempString[]=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`;
	$y=`getAttr ($guiBox+".ty")`;
	$width=`getAttr ($guiBox+".sx")`;
	$height=`getAttr ($guiBox+".sy")`;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
		error "No background image, Render a background first";
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		$fileName="combo"+$x+$y;
		}

	createNode -n SelectorFileNode file;
	setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
	float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
	float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
	createNode -n SelectorFilePlace place2dTexture;
	connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
	connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
	connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
	connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
	connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
	connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
	connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
	connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
	connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
	setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
	setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
	setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
	setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

	createNode -n SelectorRampU ramp;
	createNode -n SelectorRampV ramp;
	setAttr SelectorRampU.type 1;
	setAttr SelectorRampU.interpolation 0;
	setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
//	if ($width>2)
		setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
	setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
	setAttr SelectorRampV.type 0;
	setAttr SelectorRampV.interpolation 0;
	setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
//	if ($height>2)
		setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
	connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
	setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
	setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
	setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
	setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


	createNode -n SelectorLayeredTexture layeredTexture;
	setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
	connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
	connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
	connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

	string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
	string $buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
	string $buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
	string $buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
	
	//Off K0 version
	select SelectorLayeredTexture;
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
	delete asTempSolidTx;

	//add tint now, so that selection/keyed buttons (with blank space background) are also visible
	setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
	
	//Off K1 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
	delete asTempSolidTx;
	
	//On K0 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
	delete asTempSolidTx;
	
	//On K1 version
	setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
	delete asTempSolidTx;
	for ($q=0;$q<size($deleteObjs);$q++)
		if (`objExists $deleteObjs[$q]`)
			delete $deleteObjs[$q];


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"` && !`gmatch $renderBoxObjs[$i] "FKIKSp*ine*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
	reloadImage $buttonImageFileOffK0 $buttonName;
	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $result=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result!="Ok")
	return;
iconTextButton -e -iol (`promptDialog -q -tx`) $button;
if (`promptDialog -q -tx`=="All")
	iconTextButton -e -ann "ControlSet" $button;
//asSelectorRefresh;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c asPoserDesigner "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`internalVar -utd`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $result=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
$jpgImage=`substitute "[.]xpm" $jpgImage ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext;
if (`asMayaVersionAsFloat`>=2011)
	{
	$ext="png";
	setAttr "defaultRenderGlobals.imageFormat" 32;
	}
else
	{
	$ext="xpm";
	setAttr -type "string" defaultRenderGlobals.imfPluginKey "xpm";
	setAttr defaultRenderGlobals.imageFormat 50;
	}
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];


if (`about -linux`)
	$iconImage=`asConvertToXpm $iconImage`;

//32x32
if (!`file -q -ex $bgImageFile32`)
	{
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;
	if (`about -linux`)
		asConvertToXpm $bgImageFile32;
	}

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
//print ("$dragControl="+$dragControl+" $dropControl="+$dropControl+" $msgs[3]="+$msgs[3]+" $msgs[1]="+$msgs[1]+" $x="+$x+" $y="+$y+" $type="+$type+"\n");
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeleton4Files/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";
string $tempString[]=`listConnections time1.timewarpIn_Raw`;
if (size($tempString))
	delete $tempString;
AddTimeWarp;

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
character -name walkDesignerSet -excludeVisibility -excludeScale;
clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
setAttr walkDesignerClip.postCycle 9999;

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//

//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
if (`objExists FaceGroup`)
	if (`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton already exists, this will reset the FaceFitSkeleton"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
if (`objExists FaceGroup`)
	delete FaceGroup;
createNode -n FaceGroup transform;
setAttr -l 1 FaceGroup.inheritsTransform 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FaceFitSkeleton;
parent FaceFitSkeleton FaceGroup;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:7];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
parent FaceFitSkeletonHeight FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
delete FaceFitSkeletonHeight;
move -r 0 1.5 0 FaceFitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FaceFitSkeleton.tx;setAttr -k 1 -l 0 FaceFitSkeleton.ty 8;setAttr -k 0 -l 1 FaceFitSkeleton.tz;
setAttr -k 0 -l 1 FaceFitSkeleton.rx;setAttr -k 0 -l 1 FaceFitSkeleton.ry 0;setAttr -k 0 -l 1 FaceFitSkeleton.rz;
setAttr -k 0 FaceFitSkeleton.sx;setAttr -k 0 FaceFitSkeleton.rz;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sx;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sz;
if (`objExists Head_M` && `objExists Neck_M`)
	{
	float $temp1[]=`xform -q -ws -t Head_M`;
	float $temp2[]=`xform -q -ws -t Neck_M`;
	setAttr FaceFitSkeleton.ty (($temp1[1]+$temp2[1])/2.0);
	}
if (`objExists Main`)
	if (`attributeExists height Main`)
		setAttr FaceFitSkeleton.sy (`getAttr Main.height`/5.0);

asFaceEnsureFitBase;
select FaceFitSkeleton;
}

global proc asAnimateFaceFit ()
{
int $autoKeyState=`autoKeyframe -q -state`;
int $eyeBrowsCartoony=0;
if (`optionMenu -q -sl asFaceEyeBrowsStyleOptionMenu`==2)
	$eyeBrowsCartoony=1;
if (!$autoKeyState)
			autoKeyframe -state 1;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`*0.666;
playbackOptions -min 0 -max 190 -ast 0 -aet 190;
currentTime 0;
int $startStopFrames[];
string $locs[];
$locs={"EyeBrowMain0","EyeBrowMain3","EyeBrowMain6"};
if (`objExists EyeBrowMain0`)
	{
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			geometryConstraint $geometry $locs[$i];
	$startStopFrames={0,10,20,30,40,50,60};
	for ($a=0;$a<size($startStopFrames);$a++)
		for ($i=0;$i<size($locs);$i++)
			{
			currentTime $startStopFrames[$a];
			setKeyframe ($locs[$i]+".t");
			}
	currentTime 5;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (0.0853434*$scale) (-0.0151578*$scale) $locs[$i];
	currentTime 15;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (-0.0853434*$scale) 0 $locs[$i];
	currentTime 25;refresh;
	move -r 0 (0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 35;refresh;
	move -r (0.0487867*$scale) (-0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 45;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r (0.050709*$scale) 0 0 $locs[$i];
	currentTime 55;refresh;
	move -r (-0.0451116*$scale) (0.0709945*$scale) (-0.0499044*$scale) EyeBrowMain6;
	}
if (`objExists lowerEyeLidOuter3`)
	{
	setKeyframe -t 90 -t 100 lowerEyeLidOuter3.t;
	currentTime 95;refresh;
	move -r (0.00834774*$scale) (0.0515147*$scale) (-0.0123916*$scale) lowerEyeLidOuter3;
	}
if (`objExists upperLip0`)
	{
	setKeyframe -t 0 -t 10 -t 20 -t 30 upperLip0.twist;
	setKeyframe -t 5 -v 100 upperLip0.twist;
	setKeyframe -t 25 -v -80 upperLip0.twist;
	setKeyframe -t 10 -t 20 -t 30 -t 40 lowerLip0.twist;
	setKeyframe -t 20 -t 30 lowerLip0.twist;
	setKeyframe -t 15 -v -100 lowerLip0.twist;
	setKeyframe -t 35 -v 80 lowerLip0.twist;
	setKeyframe -t 20 -t 30 upperLip0.t;
	currentTime 25;refresh;
	move -r 0 (0.034805*$scale) (0.0559906*$scale) upperLip0;
	setKeyframe -t 30 -t 40 lowerLip0.t;
	currentTime 35;refresh;
	move -r 0 (-0.0484243*$scale) (0.0453978*$scale) lowerLip0;
	currentTime 40;
	setKeyframe -t 50 -t 60 -t 70 Lip6.t upperLip0.t lowerLip0.t upperLip3.t lowerLip3.t;
	currentTime 55;refresh;
	move -r (-0.108898*$scale) (0.139484*$scale) (-0.0650974*$scale) Lip6;
	move -r 0 (0.0378315*$scale) (-0.0196724*$scale) upperLip0;
	move -r 0 (-0.0474174*$scale) (-0.0391381*$scale) lowerLip0;
	move -r (-0.143168*$scale) (-0.00257716*$scale) (-0.0584678*$scale) lowerLip3;
	move -r (-0.0354011*$scale) (0.0393*$scale) (-0.0138085*$scale) upperLip3;
	currentTime 65;refresh;
	move -r (0.0506868*$scale) 0 (0.0461135*$scale) Lip6;
	move -r 0 (0.0181591*$scale) 0 upperLip0;
	move -r 0 (-0.0293536*$scale) 0 lowerLip0;
	move -r (0.0290451*$scale) (0.0308008*$scale) (0.0103786*$scale) upperLip3;
	move -r (0.0230078*$scale) (-0.0187822*$scale) (0.00995779*$scale) lowerLip3;
	
	setKeyframe -t 70 -t 80 lowerLipCylinder.cv[0:1][5];
	currentTime 75;refresh;
	move -r 0 (0.025*$scale) 0 lowerLipCylinder.cv[0:1][5];
	setKeyframe -t 80 -t 90 upperLip0.t upperLip0.twist lowerLip0.t lowerLip0.twist;
	currentTime 85;refresh;
	setAttr upperLip0.twist 80;
	move -r 0 (-0.01*$scale) 0 upperLip0;
	setAttr lowerLip0.twist -80;
	move -r 0 (0.01*$scale) 0 lowerLip0;
	}
if (`objExists noseCorner`)
	{
	setKeyframe -t 120 -t 130 -t 140 -t 150 noseCorner;
	currentTime 125;refresh;
	move -r (0.0109107*$scale) (0.0584232*$scale) (-0.00117445*$scale) noseCorner;
	currentTime 135;refresh;
	move -r (-0.028*$scale) 0 0 noseCorner;
	currentTime 145;refresh;
	move -r (0.028*$scale) 0 0 noseCorner;
	}
if (`objExists Lip6`)
	{
	setKeyframe -t 150 -t 160 -t 170 -t 180 -t 190 Lip6;
	currentTime 155;refresh;
	move -r (-0.0449702*$scale) 0 (-0.0544978*$scale) Lip6;
	currentTime 165;refresh;
	move -r (0.0621199*$scale) 0 (0.0613577*$scale) Lip6;
	currentTime 175;refresh;
	move -r (-0.0721402*$scale) (0.121836*$scale) (-0.0335431*$scale) Lip6;
	currentTime 185;refresh;
	move -r (-0.0180624*$scale) (-0.0745626*$scale) (-0.0415436*$scale) Lip6;
	}

if (`objExists EyeBrowMain0`)
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			delete ($locs[$i]+"_geometryConstraint1");

if (!$autoKeyState)
			autoKeyframe -state 0;
currentTime 0;
}

global proc asFaceFitProject (string $section,string $part,int $upAndLo)
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;
spaceLocator -n tempLoc;
string $locs[]=`listRelatives -c ("FaceFit"+$section+$part+"Loc")`;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;

	if (`objExists ($upperLower+$section+$part+"4")`)
		$locs[size($locs)]=($upperLower+$section+$part+"4");
	if (`objExists ($upperLower+$section+$part+"1")`)
		$locs[size($locs)]=($upperLower+$section+$part+"1");
	}

for ($a=0;$a<size($locs);$a++)
	{
	parent tempLoc $locs[$a];
	setAttr -type float3 tempLoc.t 0 0 0;
	geometryConstraint $geometry tempLoc;
	for ($i=0;$i<10;$i++)
	  {
		setAttr tempLoc.tx 0;
		setAttr tempLoc.ty 0;
		}
	float $pos[]=`xform -q -ws -t tempLoc`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $locs[$a];
	}
delete tempLoc;
/*
for ($a=0;$a<size($locs);$a++)
	if ($section=="Lip")
		if (`gmatch $locs[$a] "*0"` || `gmatch $locs[$a] "*3"` || `gmatch $locs[$a] "*6"`)
			move -os -r 0 0 ($scale/-30.0) $locs[$a];
*/
/*
for ($a=0;$a<size($locs);$a++)
	{
	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	if ($upAndLo)
		{
		if (`gmatch $locs[$a] "lower*"`)
			connectAttr -f ("lower"+$section+$part+"Curve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
		else
			connectAttr -f ("upper"+$section+$part+"Curve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
		}
	else if (`objExists ($section+$part+"Curve")`)
		connectAttr -f ($section+$part+"Curve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
	float $posA[]=`xform -q -ws -t $locs[$a]`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $posA[0] $posA[1] $posA[2];
	float $posB[]=`getAttr tempNearestPointOnCurve.position`;
	if (!`objExists ($section+$part+"Curve")`)
		$posB=`xform -q -ws -t $locs[$a]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	move -r 0 0 $dist $locs[$a];
	delete tempNearestPointOnCurve;
	}
*/
select $sel;
}

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,float $radius,int $isSphere)
{
if (`objExists ("FaceFit"+$section+$part)`)
	error ("FaceFit"+$section+$part+" Already Exists");

string $sel[]=`ls -sl -fl`;
int $edgeSelection,$vertexSelection;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		$vertexSelection=1;
	}

int $nr;
float $scale=`asFaceGetScale`;
float $dist,$dist2;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
currentTime 0;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part) -p FaceFitSkeleton transform;
createNode -n ("FaceFit"+$section+$part+"Geo") -p ("FaceFit"+$section+$part) transform;
setAttr ("FaceFit"+$section+$part+"Geo.inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve") -p ("FaceFit"+$section+$part) transform;
setAttr ("FaceFit"+$section+$part+"Curve.inheritsTransform") 0;
setAttr ("FaceFit"+$section+$part+"Curve.v") 0;
createNode -n ("FaceFit"+$section+$part+"Loc") -p ("FaceFit"+$section+$part) transform;
if ($isSphere)
	{
	duplicate -n $section templateLoc;
	parent ($section) ("FaceFit"+$section+$part+"Loc");
	sphere -n ($section+"Sphere") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere") ("FaceFit"+$section+$part+"Geo");
	connectAttr ($section+".t") ($section+"Sphere.t");
	connectAttr ($section+".r") ($section+"Sphere.r");
	connectAttr ($section+".s") ($section+"Sphere.s");
	setAttr ($section+"SphereShape.overrideEnabled") 1;
	setAttr ($section+"SphereShape.overrideDisplayType") 2;
	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double $section;
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 $section;
	
	}

if ($section=="EyeLid" && $part=="Main")
	addAttr -k 1 -ln numExtra -at long -dv 1 FaceFitEyeLidMain;

if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
//if ($mainAndOuter==0 && $a>0)
//	continue;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	$tempString=`cylinder -n ($upperLower+$section+"Cylinder"+$part) -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r $radius -hr 2 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 1`;
	rename $tempString[1] ($upperLower+$section+"MakeNurbCylinder"+$part);
	parent ($upperLower+$section+"Cylinder"+$part) FaceFitSkeleton;
	displaySmoothness -divisionsU 3 -divisionsV 3 -pointsWire 16 -pointsShaded 4 -polygonObject 3 ($upperLower+$section+"Cylinder"+$part); 
	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.overrideDisplayType") 2;
	setAttr -type float3 ($upperLower+$section+"Cylinder"+$part+".r") 0 0 90;
	setAttr -type float3 ($upperLower+$section+"Cylinder"+$part+".s") 0.025 0.2 0.025;
	parent ($upperLower+$section+"Cylinder"+$part) ("FaceFit"+$section+$part+"Geo");
	if ($section=="Lip")
		{
		select ($upperLower+$section+"Cylinder"+$part);
		$tempString=`nonLinear -type twist -lowBound -1 -highBound 1 -startAngle 0 -endAngle 0`;
		rename $tempString[0] ($upperLower+$section+"Twist");
		rename $tempString[1] ($upperLower+$section+"TwistHandle");
		parent ($upperLower+$section+"TwistHandle") FaceFitLipGeo;
		setAttr ($upperLower+$section+"TwistHandle.v") 0;
		}

	$curveCmd="curve -d 3 ";
	for ($i=0;$i<7;$i++)
		{
		select -r ($upperLower+$section+"Cylinder"+$part+".cv["+$i+"][0:7]");
		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($upperLower+$section+"Cluster"+$part+$i);
		rename $tempString[1] ($upperLower+$section+"ClusterHandle"+$part+$i);
		$tempString2=`listRelatives -s ($upperLower+$section+"ClusterHandle"+$part+$i)`;
		rename $tempString2[0] ($upperLower+$section+"ClusterHandleShape"+$part+$i);
		setAttr -l 1 ($upperLower+$section+"ClusterHandle"+$part+$i+".v") 0;
		$tempString=`listConnections ($upperLower+$section+"Cluster"+$part+$i+".message")`;
		rename $tempString[0] ($upperLower+$section+"Cluster"+$part+$i+"Set");

		$pos=`xform -q -ws -piv ($upperLower+$section+"ClusterHandle"+$part+$i)`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		duplicate -n ($upperLower+$section+$part+$i) templateLoc;
		if ($i==1 || $i==3)
			setAttr ($upperLower+$section+$part+$i+"Shape.overrideColor") 14;
		parent ($upperLower+$section+$part+$i) ("FaceFit"+$section+$part+"Loc");
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+$i);
		parent ($upperLower+$section+"ClusterHandle"+$part+$i) ($upperLower+$section+$part+$i);
		}
	//aim
	if ($section!="Nose" && $section!="Tongue")
		{
		aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"2") ($upperLower+$section+"ClusterHandle"+$part+"0");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"2") ($upperLower+$section+"ClusterHandle"+$part+"1");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"4") ($upperLower+$section+"ClusterHandle"+$part+"5");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"4") ($upperLower+$section+"ClusterHandle"+$part+"6");
		}
	parent ($upperLower+$section+$part+"1") ($upperLower+$section+$part+"0");
	parent ($upperLower+$section+$part+"2") ($upperLower+$section+$part+"0");
	parent ($upperLower+$section+$part+"4") ($upperLower+$section+$part+"6");
	parent ($upperLower+$section+$part+"5") ($upperLower+$section+$part+"6");
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool ($upperLower+$section+$part+"0");
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool ($upperLower+$section+$part+"6");
	connectAttr ($upperLower+$section+$part+"0.fineCtrl") ($upperLower+$section+$part+"2.v");
	connectAttr ($upperLower+$section+$part+"6.fineCtrl") ($upperLower+$section+$part+"4.v");
	setAttr ($upperLower+$section+$part+"1.v") 0;
	setAttr ($upperLower+$section+$part+"5.v") 0;
	$pos=`xform -q -ws -t ($upperLower+$section+$part+"0")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+"1");
	$pos=`xform -q -ws -t ($upperLower+$section+$part+"6")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+"5");
	$tempString[0]=`eval ($curveCmd)`;
	rename $tempString[0] ($upperLower+$section+$part+"Curve");
	parent ($upperLower+$section+$part+"Curve") ("FaceFit"+$section+$part+"Curve");
	for ($i=0;$i<7;$i++)
		connectAttr ($upperLower+$section+$part+$i+".worldPosition") ($upperLower+$section+$part+"Curve.controlPoints["+$i+"]");

	//Colors
	if ($part=="Main")
		sets -e -forceElement "asRedSG" ($upperLower+$section+"Cylinder"+$part);
	if ($part=="Outer")
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part);
	if ($section=="Lip" && $upperLower=="upper")
		sets -e -forceElement "asRedSG" upperLipCylinder;
	if ($section=="Lip" && $upperLower=="lower")
		sets -e -forceElement "asBlueSG" lowerLipCylinder;
	if ($section=="Lip")
		{
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][0]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][2]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][4]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][6]");
		}
	if ($section=="Nose")
		sets -e -forceElement "asGreenSG" NoseCylinder;
	if ($section=="Tongue")
		sets -e -forceElement "asRedSG" TongueCylinder;
	}
if ($section=="noseCorner" || $section=="cheek")
	sets -e -forceElement "asBlue2SG" ($section+"Sphere");

//EyeBrow Place
if ($section=="EyeBrow" && $part=="Main")
	{
	setAttr -type float3 EyeBrowMain0.t -0.102 1 0.55;
	setAttr -type float3 EyeBrowMain3.t -0.224 1 0.55;
	setAttr -type float3 EyeBrowMain6.t -0.347 1 0.55;
	select EyeBrowMain6 EyeBrowMain3 EyeBrowMain0;
	}
if ($section=="EyeBrow" && $part=="Outer")
	{
	setAttr -type float3 EyeBrowOuter0.t 0 1.2 0.55;
	setAttr -type float3 EyeBrowOuter3.t -0.224 1.2 0.55;
	setAttr -type float3 EyeBrowOuter6.t -0.347 1.2 0.55;
	setAttr -l 1 EyeBrowOuter0.tx 0;
	select EyeBrowOuter6 EyeBrowOuter3 EyeBrowOuter0;
	}

//EyeLid Place
if ($section=="EyeLid")
	{
	for ($z=0;$z<7;$z=$z+6)//0 && 6
		{
		duplicate -n ("EyeLid"+$part+$z) templateLoc;parent ("upperEyeLid"+$part+$z) ("lowerEyeLid"+$part+$z) ("EyeLid"+$part+$z);
		setAttr ("upperEyeLid"+$part+$z+"Shape.v") 0;setAttr ("lowerEyeLid"+$part+$z+"Shape.v") 0;
		addAttr -k 1 -dv 0 -ln fineCtrl -at bool ("EyeLid"+$part+$z);
		connectAttr ("EyeLid"+$part+$z+".fineCtrl") ("upperEyeLid"+$part+$z+".fineCtrl");connectAttr ("EyeLid"+$part+$z+".fineCtrl") ("lowerEyeLid"+$part+$z+".fineCtrl");
		setAttr -type float3 ("upperEyeLid"+$part+$z+".t") 0 0 0;
		setAttr -type float3 ("lowerEyeLid"+$part+$z+".t") 0 0 0;
		}
	parent ("EyeLid"+$part+"0") ("EyeLid"+$part+"6") ("FaceFitEyeLid"+$part+"Loc");
	select ("upperEyeLid"+$part+"3") ("lowerEyeLid"+$part+"3") ("EyeLid"+$part+"6") ("EyeLid"+$part+"0");
	}
if ($section=="EyeLid" && $part=="Main")
	{
	setAttr -type float3 EyeLidMain0.t -0.131 0.75 0.5;
	setAttr -type float3 EyeLidMain6.t -0.391 0.748 0.5;
	setAttr -type float3 upperEyeLidMain3.t -0.261 0.848 0.5;
	setAttr -type float3 lowerEyeLidMain3.t -0.261 0.653 0.5;
	setAttr -type float3 upperEyeLidMain2.t (-0.033*$scale) (0.041*$scale) 0;
	setAttr -type float3 lowerEyeLidMain2.t (-0.033*$scale) (-0.041*$scale) 0;
	setAttr -type float3 upperEyeLidMain4.t (0.033*$scale) (0.041*$scale) 0;
	setAttr -type float3 lowerEyeLidMain4.t (0.033*$scale) (-0.041*$scale) 0;
	}
if ($section=="EyeLid" && $part=="Outer")
	{
	setAttr -type float3 EyeLidOuter0.t -0.002 0.75 0.5;
	setAttr -type float3 EyeLidOuter6.t -0.588 0.748 0.5;
	setAttr -type float3 upperEyeLidOuter3.t -0.261 0.945 0.5;
	setAttr -type float3 lowerEyeLidOuter3.t -0.261 0.556 0.5;
	setAttr -type float3 upperEyeLidOuter2.t (-0.065*$scale) (0.077*$scale) 0;
	setAttr -type float3 lowerEyeLidOuter2.t (-0.065*$scale) (-0.077*$scale) 0;
	setAttr -type float3 upperEyeLidOuter4.t (0.065*$scale) (0.077*$scale) 0;
	setAttr -type float3 lowerEyeLidOuter4.t (0.065*$scale) (-0.077*$scale) 0;
	}

//Jaw Place
if ($section=="Jaw" && $part=="Main")
	{
	setAttr -type float3 JawMain0.t 0 0.07 0.545;
	setAttr -type float3 JawMain6.t -0.51 0.603 0;
	setAttr -type float3 JawMain6.r 90 -40 -90;
	setAttr -type float3 JawMain3.t -0.53 0.255 0.301;
	setAttr -type float3 JawMain2.t (-0.067*$scale) 0 0;
	setAttr -type float3 JawMain4.t (0.067*$scale) 0 0;
	setAttr -l 1 JawMain0.tx 0;
	select JawMain0 JawMain3 JawMain6;
	}
if ($section=="Jaw" && $part=="Outer")
	{
	setAttr -type float3 JawOuter0.t 0 -0.165 0.071;
	setAttr -type float3 JawOuter6.t -0.51 0.603 0;
	setAttr -type float3 JawOuter6.r 90 -40 -90;
	setAttr -type float3 JawOuter3.t -0.431 0.179 -0.09;
	setAttr -type float3 JawOuter2.t (-0.067*$scale) 0 0;
	setAttr -type float3 JawOuter4.t (0.122*$scale) (-0.12*$scale) (-0.014*$scale);
	setAttr -l 1 JawOuter0.tx 0;
	select JawOuter0 JawOuter3 JawOuter6;
	}

//Nose Place
if ($section=="Nose")
	{
	setAttr -type float3 Nose0.t 0 0.685 0.547;
	setAttr -type float3 Nose0.r 0 6.36 90;
	setAttr -type float3 Nose0.s (1.5/$scale) (0.75/$scale) (0.15/$scale);
	setAttr -type float3 Nose2.t (-0.035*$scale) 0 0;
	setAttr -type float3 Nose3.t 0 0.522 0.721;
	setAttr -type float3 Nose3.r 0 0 90;
	setAttr -type float3 Nose3.s (1.5/$scale) (1.5/$scale) (0.15/$scale);
	setAttr -type float3 Nose4.t (0.035*$scale) 0 0;
	setAttr -type float3 Nose6.t 0 0.454 0.612;
	setAttr -type float3 Nose6.r 0 -75.871 90;
	setAttr -type float3 Nose6.s (1.5/$scale) (1.5/$scale) (0.15/$scale);
	select Nose0 Nose3 Nose6;
	}

//NoseCorner Place
if ($section=="noseCorner")
	{
	setAttr -type float3 noseCorner.t -0.117 0.502 0.5;
	select noseCorner;
	}

//Cheek Place
if ($section=="cheek")
	{
	setAttr -type float3 cheek.t -0.332 0.433 0.5;
	select cheek;
	}

//Tongue Place
if ($section=="Tongue")
	{
	setAttr -type float3 Tongue0.t 0 0.268 0.161;
	setAttr -type float3 Tongue0.r -90 56 -90;
	setAttr -type float3 Tongue0.s (1.5/$scale) (1.5/$scale) (6/$scale);
	setAttr -type float3 Tongue2.t (-0.044*$scale) 0 0;
	setAttr -type float3 Tongue3.t 0 0.308 0.306;
	setAttr -type float3 Tongue3.r 0 90 0;
	setAttr -type float3 Tongue3.s (1.5/$scale) (1.5/$scale) (6/$scale);
	setAttr -type float3 Tongue4.t (0.01*$scale) 0 0;
	setAttr -type float3 Tongue4.s 1 1 4;
	setAttr -type float3 Tongue6.t 0 0.315 0.478;
	setAttr -type float3 Tongue6.r 0 90 0;
	setAttr -type float3 TongueClusterHandle6.s 0 0 0;
	setAttr -l 1 Tongue0.tx 0;
	setAttr -l 1 Tongue2.ty 0;
	setAttr -l 1 Tongue3.tx 0;
	setAttr -l 1 Tongue4.ty 0;
	setAttr -l 1 Tongue6.tx 0;
	select Tongue0 Tongue3 Tongue6;
	}

//Lip Place
if ($section=="Lip")
	{
	duplicate -n Lip6 templateLoc;parent upperLip6 lowerLip6 Lip6;
	setAttr upperLip6Shape.v 0;setAttr lowerLip6Shape.v 0;
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool Lip6;
	connectAttr Lip6.fineCtrl upperLip6.fineCtrl;connectAttr Lip6.fineCtrl lowerLip6.fineCtrl;
	setAttr -type float3 upperLip6.t 0 0 0;
	setAttr -type float3 lowerLip6.t 0 0 0;
	parent Lip6 FaceFitLipLoc;
	setAttr -type float3 upperLip0.t 0 0.375 0.6;
	setAttr -type float3 upperLip1.t -0.001 0 0;
	setAttr -type float3 upperLip3.t -0.09 0.33 0.6;
	setAttr -type float3 upperLip5.t 0.001 0 0;
	setAttr -type float3 lowerLip0.t 0 0.274 0.6;
	setAttr -type float3 lowerLip1.t -0.001 0 0;
	setAttr -type float3 lowerLip3.t -0.09 0.29 0.6;
	setAttr -type float3 lowerLip5.t 0.001 0 0;
	setAttr -type float3 Lip6.t -0.183 0.307 0.6;
	setAttr -type float3 Lip6.s (0.45/$scale) (0.45/$scale) (0.45/$scale);
	setAttr upperLip2.t (-0.02*$scale) 0 0;
	setAttr lowerLip2.t (-0.02*$scale) 0 0;
	setAttr upperLip4.t (0.066*$scale) 0 0;
	setAttr lowerLip4.t (0.066*$scale) 0 0;
	setAttr -l 1 upperLip0.tx 0;
	setAttr -l 1 lowerLip0.tx 0;
	addAttr -k 1 -ln twist -at double upperLip0;
	addAttr -k 1 -ln twist -at double lowerLip0;
	connectAttr upperLip0.twist upperLipTwist.startAngle;
	connectAttr lowerLip0.twist lowerLipTwist.startAngle;
	select upperLip0 upperLip3 Lip6 lowerLip3 lowerLip0;

	//Push inside lip mesh
	refresh;
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
		for ($i=0;$i<7;$i++)
			{
			$posA=`xform -q -ws -t ($upperLower+"Lip"+$i)`;
			$posB=`xform -q -ws -t ($upperLower+"LipCylinder.cv["+$i+"][3]")`;
			$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
			move -r 0 0 ($dist*-1) ($upperLower+"LipClusterHandle"+$i);
			}
		}
	}

delete templateLoc;
//select EyeBrowMain0 EyeBrowMain2 EyeBrowMain4 EyeBrowOuter0 EyeBrowOuter2 EyeBrowOuter4 upperEyeLidMain2 lowerEyeLidMain2 upperEyeLidOuter2 lowerEyeLidOuter2 EyeLidMain0 EyeLidMain4 EyeLidOuter4 JawMain0 JawMain2 JawMain4 JawOuter0 JawOuter2 JawOuter4 upperLip0 upperLip2 lowerLip0 lowerLip2 Lip4 Nose0 Nose4 noseCorner Cheek0 Tongue0 Tongue2 Tongue4 EyeLidOuter0 Nose2;
if (`checkBox -q -ex ("asFace"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFace"+$section+$part);


//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

addAttr -ln selection -dt "string" ("FaceFit"+$section+$part);
$tempString[0]="";
for ($i=0;$i<size($sel);$i++)
	$tempString[0]=$tempString[0]+$sel[$i]+" ";
setAttr -type "string" ("FaceFit"+$section+$part+".selection") $tempString[0];

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($section=="noseCorner" || $section=="cheek")
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part);
	return;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*[.]e*"`)
		continue;
	select $sel[$i];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
		if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
		if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
		if ($pos[0]>$maxPos[0]) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
		if ($pos[1]>$maxPos[1]) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
		if ($pos[2]>$maxPos[2]) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
		}
	}
string $startVxt=$maxXVtx;
string $endVxt=$minXVtx;
if ($section=="Nose") {$startVxt=$maxYVtx;$endVxt=$minYVtx;}
if ($section=="Tongue") {$startVxt=$minZVtx;$endVxt=$maxZVtx;}

select $startVxt;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];
string $prevVtxs[],$vtxs1[],$vtxs2[];

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVxt`;
if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
	;
else
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVxt;
$prevVtxs[0]=$startVxt;
$vtxs1[size($vtxs1)]=$startVxt;

for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $endVxt $tempString`)
			$around=1;
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
		;
	else
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		break;
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($upAndLo)
	{
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $maxXVtx;
	$pos=`xform -q -ws -t $maxXVtx`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$maxXVtx;
		$vtxs2[size($vtxs2)]=$maxXVtx;
		}
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $minXVtx $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			error "Not a complete edgeloop";
		$vtxs2[size($vtxs2)]=$tempString2[0];
		$pos=`xform -q -ws -t $tempString2[0]`;
		if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
			;
		else
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	string $edges2[]=`ls -sl -fl`;
	eval $curveCmd;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;
	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
		$upperVtxs=$vtxs1;
		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 upperFaceLoopCurve;
		rename faceLoopCurve2 lowerFaceLoopCurve;
		}
	else
		{
		$upperVtxs=$vtxs2;
		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 lowerFaceLoopCurve;
		rename faceLoopCurve2 upperFaceLoopCurve;
		}
	addAttr -ln upperSelection -dt "string" ("FaceFit"+$section+$part);
	addAttr -ln lowerSelection -dt "string" ("FaceFit"+$section+$part);
	$tempString[0]="";
	for ($i=0;$i<size($upperVtxs);$i++)
		$tempString[0]=$tempString[0]+$upperVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".upperSelection") $tempString[0];
	$tempString[0]="";
	for ($i=0;$i<size($lowerVtxs);$i++)
		$tempString[0]=$tempString[0]+$lowerVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".lowerSelection") $tempString[0];
	}
if (!$upAndLo)
	rename faceLoopCurve1 FaceLoopCurve;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo)
		{
		$upperLower="";
		if ($upperLowerFactor==-1) 
			continue;
		}

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.004 ($upperLower+"FaceLoopCurve");	
	for ($i=0;$i<9;$i++)
		{
		$nr=$i;
		if ($i==4 || $i==5) continue;//Do 4&5 last
		if ($i==7) $nr=4;
		if ($i==8) $nr=5;
		$pos=`xform -q -ws -t ($upperLower+"FaceLoopCurve.cv["+$nr+"]")`;
		if (($nr==0 && $section!="Lip") || $nr==6)
			xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part+$nr);
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+$nr);
		}
	}
if ($upAndLo)
	delete upperFaceLoopCurve lowerFaceLoopCurve;
else
	delete FaceLoopCurve;

//Lip thickness
if ($section=="Lip")
	{
	$posA=`xform -q -ws -t upperLip0`;
	$posB=`xform -q -ws -t lowerLip0`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $posA[]=`xform -q -ws -t upperLipCylinder.cv[0][7]`;
	float $posB[]=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
	float $dist2 =`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $lipScale=(`getAttr upperLip0.sx`*($dist/$dist2))/1.0;
	setAttr -type float3 upperLip0.s $lipScale $lipScale $lipScale;
	setAttr -type float3 lowerLip0.s $lipScale $lipScale $lipScale;

	$posA=`xform -q -ws -t upperLip3`;
	$posB=`xform -q -ws -t lowerLip3`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $posA[]=`xform -q -ws -t upperLipCylinder.cv[3][7]`;
	float $posB[]=`xform -q -ws -t upperLipCylinder.cv[3][3]`;
	float $dist2 =`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $lipScale=(`getAttr upperLip3.sx`*($dist/$dist2))/1.0;
	setAttr -type float3 upperLip3.s $lipScale $lipScale $lipScale;
	setAttr -type float3 lowerLip3.s $lipScale $lipScale $lipScale;

	setAttr -type float3 Lip6.s ($lipScale/2.0) ($lipScale/2.0) ($lipScale/2.0);
	}
select ("FaceFit"+$section+$part);
}

global proc int asCanBuild (string $section)
{
int $canBuild=0;
if ($section=="EyeBall")
	if (`objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeLid")
	if (`objExists EyeLidMain0` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeBrow")
	if (`objExists EyeBrowMain0` && `objExists EyeLidMain0` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="Jaw")
	if (`objExists JawOuter0` && `objExists EyeLidMain0` && `objExists FitEyeBall`
	 && `objExists FitEyeBall` && `objExists upperLip0` && `objExists  Nose0`
	 && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Cheek")
	if (`objExists upperLip0` && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Lip")
	if (`objExists upperLip0`)
		$canBuild=1;
if ($section=="Tongue")
	if (`objExists Tongue0`)
		$canBuild=1;
return $canBuild;
}

global proc asBuildAdvancedFace ()
{
global string $gMainProgressBar;
global string $gSelect;
setToolTo $gSelect;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
float $pos[],$posA[],$posB[],$tempFloat[];
string $tempString[],$allFaceGeo[],$cmds[];
string $cmd;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`objExists FaceFitSkeleton`)
	error "Face FitSkeleton not found";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
if (! `objExists FaceMotionSystem`)
	{
	if (`objExists Eye_R`) error "Object called \"Eye_R\" exists, rename this to another name before building face-setup";
	if (`objExists Eye_L`) error "Object called \"Eye_L\" exists, rename this to another name before building face-setup";
	}
if (`objExists EyeBrowMain0`)
	if (!size(`listConnections EyeBrowMain0.tx`))
		error "No Fit Animation Found, Click the \"Animate Fit\" button, before building the face";
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
currentTime 0;

if (`objExists PausedForSim2`)
	{
	asBuildAdvancedFaceContinue2;
	return;
	}
if (`objExists PausedForSim1`)
	{
	asBuildAdvancedFaceContinue1;
	return;
	}

if (`headsUpDisplay -q -ex HUDFitModeFace`)
	asToggleFitModeFace;

if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists asFaceBS`)
	asKeepBlendShapes;

//Rebuild ?
if (`objExists FaceMotionSystem`) 
	{
	if (!`asConfirmIfNotInBuildPose`)
		return;
	//Pre Rebuild CurveShapes
	string $controlSetMembers[]=`sets -q FaceControlSet`;
	//add ctrlBox, so Shape of this is maintained in ReBuild
	if (`objExists "ctrlBox"`)
		$controlSetMembers[size($controlSetMembers)]="ctrlBox";
	string $curveShape;
	int $spans,$degree,$numCVs;
	float $cvPos[3];
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		$curveShape=$tempString[0];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		}
	//ctrlBox xform
	$tempFloat=`getAttr ctrlBox.t`;
	$cmds[size($cmds)]="setAttr -type float3 ctrlBox.t "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";
	$tempFloat=`getAttr ctrlBox.r`;
	$cmds[size($cmds)]="setAttr -type float3 ctrlBox.r "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";
	$tempFloat=`getAttr ctrlBox.s`;
	$cmds[size($cmds)]="setAttr -type float3 ctrlBox.s "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";

	//lockWeights all but headJoint
	$tempString=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($tempString);$i++)
		if ($tempString[$i]!=$headJoint)
			setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
	//remove previous inf`s
	select `listRelatives -ad -type joint FaceDeformationSystem`;
	select -add $geometry;
	RemoveInfluence;
	skinPercent -normalize 1 $skinCluster $geometry;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
	delete `sets -q FaceAllSet`;
	//intermediateObject
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if ($allFaceGeo[$i]==$geometry)
			continue;
//		if (size(`listRelatives -s -ni $allFaceGeo[$i]`))
//			continue;
		$tempString=`listRelatives -s $allFaceGeo[$i]`;
		for ($y=1;$y<size($tempString);$y++)
			delete $tempString[$y];
		if (size($tempString))
			setAttr ($tempString[0]+".intermediateObject") 0;
		}
	}

//Prep
setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v 0;
string $allBefore[]=`ls`;
asFaceEnsureAdvancedBase;
spaceLocator -n tempLoc;
setAttr tempLoc.v 0;
createNode -n tempLocFlip transform;
parent tempLoc tempLocFlip;

if ($buildEyeBall)
	{
	setAttr ctrlBoxEye_L.v 1;
	setAttr ctrlBoxEye_R.v 1;
	}
if ($buildEyeBrow)
	{
	setAttr ctrlBoxBrow_R.v 1;
	setAttr ctrlBoxBrow_L.v 1;
	}
if ($buildCheek)
	{
	setAttr ctrlBoxCheek_R.v 1;
	setAttr ctrlBoxCheek_L.v 1;
	setAttr ctrlBoxNose_R.v 1;
	setAttr ctrlBoxNose_L.v 1;
	}
if ($buildJaw)
	{
	setAttr ctrlBoxMouth_M.v 1;
	setAttr ctrlBoxMouthCorner_R.v 1;
	setAttr ctrlBoxMouthCorner_L.v 1;
	}
if ($buildTongue)
	setAttr ctrlBoxTongue_M.v 1;

setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;

//create faceTargets by wrapping
createNode -n faceTargets transform;
setAttr faceTargets.v 0;
duplicate -n tempTarget $geometry;
asLockAttr tempTarget 0 0 0 0;
//sets -remove jawArea tempTarget.vtx[0:9999];
parent tempTarget faceTargets;
$tempString=`listRelatives -s tempTarget`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
setAttr tempTarget.v 0;
duplicate -n target_default tempTarget;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;

//EyeBall
if ($buildEyeBall)
	asAdvancedEyeBall;


//EyeLid
if ($buildEyeLid)
	asAdvancedEyeLid;


//EyeBrow
if ($buildEyeBrow)
	asAdvancedEyeBrow;


if (`objExists tempNearestPointOnCurve`)
	delete tempNearestPointOnCurve;

if (`objExists "Group"`) setAttr "Group.v" 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;

asUpdateAllSet $allBefore;
if ($modifier %  8)
	{
	playbackOptions -min 0 -max 190 -ast 0 -aet 190;
	createNode -n PausedForSim1 transform;
	progressBar -e -ep $gMainProgressBar;
	return;
	}
asBuildAdvancedFaceContinue1;

//Post Rebuild
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
}

global proc asBuildAdvancedFaceContinue1 ()
{
global string $gMainProgressBar;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
float $scale=`asFaceGetScale`;
float $pos[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$deformJoints[],$lidJoints[],$lipJoints[],$insideVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allBefore[]=`ls`;

if (`objExists PausedForSim1`)
	delete PausedForSim1;

string $faceTargets[]={"brow_raiser_R","brow_lowerer_R","brow_innerRaiser_R","brow_innerLowerer_R","brow_squeeze_R","brow_outerRaiser_R"};
if (`objExists foreheadGeo`)
	asFaceSkinSim $faceTargets foreheadGeo;//nCloth sim

//cleanup
if (`objExists "Group"`) setAttr "Group.v" 1;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
if (`objExists foreheadGeo`)
	{
	select foreheadGeo;
	DeleteHistory;
	delete foreheadGeoSlideOn tempdynamicConstraint foreheadGeo;
	}

//cleanup brow
if ($buildEyeBrow)
	{
	for ($a=1;$a<5;$a++)
		delete ("foreHeadBorderCurve"+$a);
	delete tempNClothConstraint2 tempNClothRigid1 eyeBrowPoly EyeBrowMainPoly EyeBrowExtrude EyeBrowCircle EyeBrowMainCurve2;
	}


//Jaw
if ($buildJaw)
	{
	asAdvancedJaw;
	//asFaceBsSdk
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK2Jaw_M.rz 15;
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK2Jaw_M.tx ($scale/30);
	//asFaceBsSdk ctrlMouth_M.ty -1 FKSDK2Jaw_M.sx 0.9;
	}


//Cheek
if ($buildCheek)
	asAdvancedCheek;


if (`objExists "Group"`) setAttr "Group.v" 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;

asUpdateAllSet $allBefore;
if ($modifier %  8)
	{
	createNode -n PausedForSim2 transform;
	progressBar -e -ep $gMainProgressBar;
	return;
	}
asBuildAdvancedFaceContinue2;
}

global proc asBuildAdvancedFaceContinue2 ()
{
global string $gMainProgressBar;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
int $tempInts[];
float $scale=`asFaceGetScale`;
float $pos[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$deformJoints[],$lidJoints[],$lipJoints[],$insideVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allBefore[]=`ls`;

cycleCheck -e off;

if (`objExists PausedForSim2`)
	delete PausedForSim2;

string $faceTargets[]=
	{
	"mouth_rollInUpper_R","mouth_rollInLower_R","mouth_rollOutUpper_R","mouth_rollOutLower_R",
	"chin_raiser_C","mouth_wide_C","mouth_oo_C","chinRaiser_C","mouth_presser_R","cheek_raiser_R",
	"cheek_puff_R","cheek_suck_R","nose_wrinkler_R","nose_dilator_R","nose_compressor_R",
	"mouth_puckerAnti_R","mouth_pucker_R","mouth_smile_R","mouth_frown_R"
	};
if (`objExists mouthGeo`)
	asFaceSkinSim $faceTargets mouthGeo;//nCloth sim


//Tongue
if ($buildTongue)
	asAdvancedTongue;

//Squint
if ($buildEyeBall)
	asFaceSquintByLattice;

//cleanup
if (`objExists "Group"`) setAttr "Group.v" 1;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
if (`objExists mouthGeo`)
	{
	select mouthGeo;
	DeleteHistory;
	}
string $deleteObjs[]={"lipGeometry","JawCylinderMainPoly","NoseCylinderPoly","lowerEyeLidCylinderOuterPoly",
	"noseCornerSpherePoly","lipGeometry","JawCylinderMainPoly","NoseCylinderPoly","lowerEyeLidCylinderOuterPoly",
	"noseCornerSpherePoly","CheekPuffDynamicConstraint","CheekSuckDynamicConstraint","mouthNCloth","mouthGeo"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//Keep Blandshapes
if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists keepTweakedBlendShapes`)
	{
	string $shps[];
	string $keepShpsXforms[]=`listRelatives -c keepTweakedBlendShapes`;
	for ($i=0;$i<size($keepShpsXforms);$i++)
		$shps[size($shps)]=`substitute "_tweaked" $keepShpsXforms[$i] ""`;
	for ($i=0;$i<size($shps);$i++)
		connectAttr ($shps[$i]+"_tweaked.outMesh") ($shps[$i]+".inMesh");
	}

//asFaceBS blendShape
if (`objExists faceTargets`)
	{
	delete tempTarget target_default;
	select `listRelatives -c faceTargets`;
	select -add $geometry;
	$tempString=`blendShape -frontOfChain`;
	rename $tempString asFaceBS;
	}

//asFaceBsSdk
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";

	if ($buildEyeBrow)
		{
		asFaceBsSdk ("ctrlBrow"+$side+".ty")  1 ("asFaceBS.brow_raiser"+$side) 1;
		setAttr ("asFaceBS_brow_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".ty") -1 ("asFaceBS.brow_lowerer"+$side) 1;
		setAttr ("asFaceBS_brow_lowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx")  1 ("asFaceBS.brow_innerRaiser"+$side) 1;
		setAttr ("asFaceBS_brow_innerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx") -1 ("asFaceBS.brow_innerLowerer"+$side) 1;
		setAttr ("asFaceBS_brow_innerLowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		if (!`attributeExists squeeze ("ctrlBrow"+$side)`)
			addAttr -ln "squeeze"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".squeeze") 10 ("asFaceBS.brow_squeeze"+$side) 1;
	
		if (!`attributeExists outerUpDown ("ctrlBrow"+$side)`)
			addAttr -ln "outerUpDown"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".outerUpDown") 10 ("asFaceBS.brow_outerRaiser"+$side) 1;
		//	setAttr ("asFaceBS_brow_outerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		}

	if ($buildEyeBall)
		{
		if (!`attributeExists squint ("ctrlEye"+$side)`)
			addAttr -ln "squint"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
		asFaceBsSdk ("ctrlEye"+$side+".squint") 10 ("asFaceBS.eye_squint"+$side) 1;
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlCheek"+$side+".ty") 1 ("asFaceBS.cheek_raiser"+$side) 1;
		setAttr ("asFaceBS_cheek_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") 1 ("asFaceBS.cheek_puff"+$side) 1;
		setAttr ("asFaceBS_cheek_puff"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") -1 ("asFaceBS.cheek_suck"+$side) 1;
		setAttr ("asFaceBS_cheek_suck"+$side+".postInfinity") 0; // no neg weight when drive>0
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlNose"+$side+".ty") 1 ("asFaceBS.nose_wrinkler"+$side) 1;
		setAttr ("asFaceBS_nose_wrinkler"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") 1 ("asFaceBS.nose_dilator"+$side) 1;
		setAttr ("asFaceBS_nose_dilator"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") -1 ("asFaceBS.nose_compressor"+$side) 1;
		setAttr ("asFaceBS_nose_compressor"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}

if ($buildCheek)
	{
	asFaceBsSdk ctrlMouth_M.tx 1 asFaceBS.mouth_wide_C 1;
	setAttr ("asFaceBS_mouth_wide_C.preInfinity") 1; // no neg weight when drive<0
	
	asFaceBsSdk ctrlMouth_M.tx -1 asFaceBS.mouth_oo_C 1;
	setAttr ("asFaceBS_mouth_oo_C.postInfinity") 0; // no neg weight when drive>0
	}

if ($buildJaw)
	{
	if (!`attributeExists JAW ctrlMouth_M`)
		addAttr -k 0 -ln "JAW" -at "double" ctrlMouth_M;setAttr -l 1 -cb 1 ctrlMouth_M.JAW;
	if (!`attributeExists jawSide ctrlMouth_M`)
		addAttr -ln "jawSide"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawSide 10 FKSDK1Jaw_M.ry ($scale*4.0);
	asFaceBsSdk ctrlMouth_M.jawSide -10 FKSDK1Jaw_M.ry ($scale*-4.0);	
	if (!`attributeExists jawForward ctrlMouth_M`)
		addAttr -ln "jawForward"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawForward 10 FKSDK1Jaw_M.tx ($scale/35.0);
	asFaceBsSdk ctrlMouth_M.jawForward -10 FKSDK1Jaw_M.tx ($scale/-35.0);
	if (!`attributeExists CHIN ctrlMouth_M`)
		addAttr -k 0 -ln "CHIN" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.CHIN;
	if (!`attributeExists chinRaiser ctrlMouth_M`)
		addAttr -ln "chinRaiser"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.chinRaiser 10 asFaceBS.chinRaiser_C 1;
	}
if ($buildCheek)
	{
	if (!`attributeExists LIP_PRESS ctrlMouth_M`)
		addAttr -k 0 -ln "LIP_PRESS" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_PRESS;
	if (!`attributeExists lipPress_R ctrlMouth_M`)
		addAttr -ln "lipPress_R"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	if (!`attributeExists lipPress_L ctrlMouth_M`)
		addAttr -ln "lipPress_L"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipPress_R 10 asFaceBS.mouth_presser_R 1;
	asFaceBsSdk ctrlMouth_M.lipPress_L 10 asFaceBS.mouth_presser_L 1;
	
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists LIP_ROLL ctrlMouth_M`)
			addAttr -k 0 -ln "LIP_ROLL" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_ROLL;
		if (!`attributeExists ("lipUpperRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipUpperRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) -10 ("asFaceBS.mouth_rollInUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInUpper"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) 10 ("asFaceBS.mouth_rollOutUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutUpper"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists ("lipLowerRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipLowerRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) -10 ("asFaceBS.mouth_rollInLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInLower"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) 10 ("asFaceBS.mouth_rollOutLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutLower"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") 1 ("asFaceBS.mouth_puckerAnti"+$side) 1;
		setAttr ("asFaceBS_mouth_puckerAnti"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") -1 ("asFaceBS.mouth_pucker"+$side) 1;
		setAttr ("asFaceBS_mouth_pucker"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") 1 ("asFaceBS.mouth_smile"+$side) 1;
		setAttr ("asFaceBS_mouth_smile"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") -1 ("asFaceBS.mouth_frown"+$side) 1;
		setAttr ("asFaceBS_mouth_frown"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}
if (`objExists faceTargets`)
	delete faceTargets;


//PingPongs
if ($buildEyeBrow)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
	
		asPingPong EyeBrowMain0 browInner $b $side 6 1 1;
		asPingPong EyeBrowMain3 browHalf $b $side 10 1 1;
		asPingPong EyeBrowMain6 browOuter $b $side 6 1 1;
		}
	//Weighting PingPongs via a skinCage(foreHeadMesh)
	loft -n foreHeadLoftNurbs -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true EyeBrowOuterCurve EyeBrowMainCurve upperEyeLidOuterCurve;
	nurbsToPoly -n foreHeadLoft -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs;
	duplicate -n foreHeadLoft2 foreHeadLoft;
	setAttr foreHeadLoft2.sx -1;
	loft -n foreHeadLoftNurbs3 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[13] foreHeadLoft.e[13];
	nurbsToPoly -n foreHeadLoft3 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs3;
	loft -n foreHeadLoftNurbs4 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[15] foreHeadLoft.e[15];
	nurbsToPoly -n foreHeadLoft4 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs4;
	loft -n foreHeadLoftNurbs5 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft.e[17] foreHeadLoft.e[0];
	nurbsToPoly -n foreHeadLoft5 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs5;
	loft -n foreHeadLoftNurbs6 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft2.e[17] foreHeadLoft2.e[0];
	nurbsToPoly -n foreHeadLoft6 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs6;
	delete foreHeadLoftNurbs foreHeadLoftNurbs3 foreHeadLoftNurbs4 foreHeadLoftNurbs5 foreHeadLoftNurbs6;
	polyUnite -n foreHeadMesh -ch 0 -mergeUVSets 1 foreHeadLoft foreHeadLoft foreHeadLoft2 foreHeadLoft3 foreHeadLoft4 foreHeadLoft5 foreHeadLoft6;
	polyMergeVertex -d 0.01 -am 1 -ch 0 foreHeadMesh;
	spaceLocator -n tempGeoSnapLoc;
	spaceLocator -n tempGeoSnapLocOffset;
	parent tempGeoSnapLoc tempGeoSnapLocOffset;
	int $popOutVtxNrs[]={29,30};
	for ($a=0;$a<size($popOutVtxNrs);$a++)
		{
		$pos=`xform -q -ws -t ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLocOffset;
		geometryConstraint $geometry tempGeoSnapLoc;
		for ($i=0;$i<10;$i++)
		  {
			setAttr tempGeoSnapLoc.tx 0;
			setAttr tempGeoSnapLoc.ty 0;
			}
		$pos=`xform -q -ws -t tempGeoSnapLoc`;
		xform -ws -t 0 $pos[1] $pos[2] ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]");
		}
	delete tempGeoSnapLocOffset;
	
	select foreHeadMesh FaceAttachToHead;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] foreHeadSC;
	string $browJoints[]={"browInnerJoint_R","browHalfJoint_R","browOuterJoint_R","browInnerJoint_L","browHalfJoint_L","browOuterJoint_L"};
	int $browJointVtxNrs[]={7,6,11,21,20,25};
	for ($i=0;$i<size($browJoints);$i++)
		{
		skinCluster -e -ai $browJoints[$i] -lw false -wt 0 foreHeadSC;
		skinPercent -tv $browJoints[$i] 1 foreHeadSC ("foreHeadMesh.vtx["+$browJointVtxNrs[$i]+"]");
		}
	skinPercent -tv browInnerJoint_R 0.5 -tv browHalfJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[9];
	skinPercent -tv browInnerJoint_L 0.5 -tv browHalfJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[23];
	skinPercent -tv browHalfJoint_R 0.5 -tv browOuterJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[13];
	skinPercent -tv browHalfJoint_L 0.5 -tv browOuterJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[27];
	skinPercent -tv browInnerJoint_R 0.5 -tv browInnerJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[29];
	
	int $tempInts[]=`polyEvaluate -v $geometry`;
	int $numVtx=$tempInts[0];
	select -cl;
	for ($i=0;$i<$numVtx;$i++)
		{
		$vtx=$geometry+".vtx["+$i+"]";
		$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
		if (size($infs)==1 && $infs[0]==$headJoint)
			select -add $vtx;
		}
	string $headJointWeightedVtxs[]=`ls -sl`;
	select -r foreHeadMesh.vtx[0:28];
	select -add $headJointWeightedVtxs;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete foreHeadMesh;
	}

select -r $geometry;
doPruneSkinClusterWeightsArgList 1 { "0.001" };
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if ($buildCheek)
	{
	//SoftModPingPongs
	//determine default radius if first build
	if (`getAttr cheek.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t cheek`;
	  float $posB[]=`xform -q -ws -t Lip6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr cheek.falloffRadius $dist;
		}
	if (`getAttr noseCorner.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t noseCorner`;
	  float $posB[]=`xform -q -ws -t Nose6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr noseCorner.falloffRadius $dist;
		}
	
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster cheek cheek $b $side;
		softCluster noseCorner noseCorner $b $side;
		}
	}
	

//Lip
if ($buildLip)
	asAdvancedLip;


//Post
progressBar -e -ep $gMainProgressBar;
$deleteObjs={"eyeLidVtxs","foreHeadVtxs","grownUpLipVtxs","grownUpLipVtxsInverse","jawArea","tempLocFlip",
		"tempLoc","nucleus1","keepTweakedBlendShapes"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//Also delete iconsGroup
if (`objExists iconsGroup`) delete iconsGroup;

//Also update buildPose
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

asUpdateAllSet $allBefore;

cycleCheck -e on;

select -cl;
print ("// Advanced Face created\n");
}

global proc asAdvancedEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $eyeBallPos[3]=`xform -q -ws -t FitEyeBall`;
float $scale=`asFaceGetScale`;
string $tempString[];

createNode -n EyeSetup -p FaceMotionSystem transform;
string $eye,$eyeBallSkinCluster;
string $eyeGeos[];

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
parentConstraint $headJoint EyeAimFollowHead;
scaleConstraint $headJoint EyeAimFollowHead;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject FaceAttachToHead AimAimAt AimEye_M;
setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M AimEyeOffset_M;
parent AimEye_M AimEyeFollow_M;
parent AimEyeOffset_M Aimcontrols;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$scale) AimEyeOffset_M;
createNode -n AimEyeUpVec -p FitEyeBall transform;
parent AimEyeUpVec EyeAimFollowHead;

addAttr -k 1 -ln aim -at double -min 0 -max 10 -dv 0 AimEye_M;
createNode -n eyeAimSetRange setRange;
setAttr eyeAimSetRange.minX 0;
setAttr eyeAimSetRange.maxX 1;
setAttr eyeAimSetRange.oldMinX 0;
setAttr eyeAimSetRange.oldMaxX 10;
connectAttr AimEye_M.aim eyeAimSetRange.value.valueX;

addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimFollowSetRange setRange;
setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;
parentConstraint -mo $headJoint FaceGroup AimEyeFollow_M;
connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.FaceGroupW1;
connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJoint+"W0");

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	select FaceAttachToHead;
	joint -n ("Eye"+$side);
	setAttr ("Eye"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("Eye"+$side);
	delete `orientConstraint -o 0 -90 0 FitEyeBall  ("Eye"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Eye"+$side);
	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
	setAttr ("Eye"+$side+".jointOrientX") 180;
	if ($side=="_L")
		setAttr Eye_L.jointOrientY (`getAttr Eye_R.jointOrientY`*-1);
	joint -n ("EyeEnd"+$side);
	if (`objExists DeformSet`)
		sets -add DeformSet ("EyeEnd"+$side);
	setAttr ("EyeEnd"+$side+".tx") ($scale*0.5);

	$eyeJoint="Eye"+$side;
	$eye=`textField -q -tx ("asFaceEye"+$side+"TextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$eyeBallSkinCluster=$historyNodes[$y];
				}
	
		if ($haveSkinCluster)
			{
			skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinCluster;
			setAttr ($eyeJoint+".lockInfluenceWeights") 0;
			skinPercent -tv $eyeJoint 1 $eyeBallSkinCluster $eyeGeos[$i];
			}
		else
			{
			select $eyeJoint $eyeGeos[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($y=0;$y<size($tempString);$y++)
				rename $tempString[$y] ("eyeSC"+$side);
			}
		}
	connectAttr ("ctrlEye"+$side+".sx") ($eyeJoint+".sz");
	connectAttr ("ctrlEye"+$side+".sy") ($eyeJoint+".sy");
	connectAttr ("ctrlEye"+$side+".sz") ($eyeJoint+".sx");
	//SDK
	asFaceBsSdk ("ctrlEye"+$side+".tx") -1 ($eyeJoint+".ry") -30;
	asFaceBsSdk ("ctrlEye"+$side+".tx") 1 ($eyeJoint+".ry") 30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") -1 ($eyeJoint+".rz") -30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") 1 ($eyeJoint+".rz") 30;
	//Look-at
	createNode -n ("EyeOffset"+$side) -p ("Eye"+$side) transform;
	parent ("EyeOffset"+$side) EyeAimFollowHead;
	duplicate -n ("EyeAimTargetOn"+$side) ("EyeOffset"+$side);
	parent ("EyeAimTargetOn"+$side) ("Eye"+$side);
	setAttr ("EyeAimTargetOn"+$side+".tx") $scale;
	parent ("EyeAimTargetOn"+$side) EyeSetup;
	duplicate -n ("EyeAimTargetOff"+$side) ("EyeAimTargetOn"+$side);
	parent ("EyeAimTargetOff"+$side) EyeAimFollowHead;
	parent ("EyeAimTargetOn"+$side) AimEye_M;
	duplicate -n ("EyeAim"+$side) ("EyeOffset"+$side);
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
	createNode -n ("EyeAimBlend"+$side) blendColors;
	connectAttr ("EyeAim"+$side+".rotate") ("EyeAimBlend"+$side+".color1");
	connectAttr ("Eye"+$side+"_rotateY.output") ("EyeAimBlend"+$side+".color2G");
	connectAttr ("Eye"+$side+"_rotateZ.output") ("EyeAimBlend"+$side+".color2B");
	connectAttr -f ("EyeAimBlend"+$side+".outputR") ("Eye"+$side+".rx");
	connectAttr -f ("EyeAimBlend"+$side+".outputG") ("Eye"+$side+".ry");
	connectAttr -f ("EyeAimBlend"+$side+".outputB") ("Eye"+$side+".rz");

	aimConstraint -aimVector 1 0 0 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("EyeAimTargetOff"+$side) ("EyeAimTargetOn"+$side) ("EyeAim"+$side);
	connectAttr eyeAimSetRange.outValue.outValueX ("EyeAimBlend"+$side+".blender");
	}
}

global proc asAdvancedEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$tempString3[],$infs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

createNode -n LidSetup -p FaceMotionSystem transform;
createNode -n LidJoints -p LidSetup transform;
parentConstraint $headJoint LidJoints;
scaleConstraint $headJoint LidJoints;
setAttr -l 1 LidSetup.v 0;
select FaceAttachToHead;
joint -n faceLid;
setAttr faceLid.segmentScaleCompensate 0;
skinCluster -e -wt 0 -ai faceLid  -lw true $skinCluster;
print ("skinCluster -e -wt 0 -ai faceLid  -lw true "+$skinCluster+"\n");

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
	parent ("LidSetup"+$side) faceLid;
	}

//Setup Lid
int $numLid=20;
int $numLidUpper=20;
int $numLidLower=20;
string $selectionMainVtxs[],$selectionMainVtxsAll[],$selectionOuterVtxs[],$selectionOuterVtxsAll[];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double LidSetup;
	addAttr -dv 0.2 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLid"+$side) -at double LidSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double LidSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double LidSetup;

	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("LidSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
	setAttr -l 1 ("LidLocs"+$side+".v") 0;
	createNode -n ("LidCurves"+$side) transform;
	parent ("LidCurves"+$side) LidSetup;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if (`attributeExists selection FaceFitEyeLidMain`)
			{
			$tempString[0]=`getAttr ("FaceFitEyeLidMain."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionMainVtxs;
			$selectionMainVtxsAll=`stringArrayCatenate $selectionMainVtxsAll $selectionMainVtxs`;
			$numLid=size($selectionMainVtxs);
			if ($upperLower=="upper")
				$numLidUpper=$numLid;
			else
				$numLidLower=$numLid;
			$tempString[0]=`getAttr ("FaceFitEyeLidOuter."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionOuterVtxs;
			$selectionOuterVtxsAll=`stringArrayCatenate $selectionOuterVtxsAll $selectionOuterVtxs`;
			}

		duplicate -n ($upperLower+"LidCurve2"+$side) ($upperLower+"EyeLidMainCurve");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.004 ($upperLower+"LidCurve2"+$side);	
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[2]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[1]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[3]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[2]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[4]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[3]");
		if ($side=="_R")
			{
			//find best position for cv[2,1&3]
			int $nudgeVtxNrs[]={2,1,3};
			for ($i=0;$i<size($nudgeVtxNrs);$i++)
				{
				connectAttr -f ($upperLower+"LidCurve2"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]")`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$posA=`getAttr tempNearestPointOnCurve.position`;
				connectAttr -f ($upperLower+"EyeLidMainCurve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$posB=`getAttr tempNearestPointOnCurve.position`;
				move -r (($posB[0]-$posA[0])*2) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]");
				}
			}

		//Might need to flip over Left curve here
		if ($side=="_L")
			scale -r -p 0 0 0 -1 1 1 ($upperLower+"LidCurve2"+$side+".cv[0:4]");
		parent ($upperLower+"LidCurve2"+$side) ("LidCurves"+$side);

		//make Tweaked-Shape, so each cv is zero position at the correct place
		createNode -n ($upperLower+"LidCurve2"+$side+"TweakedShape") -p ($upperLower+"LidCurve2"+$side) nurbsCurve;
		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") ($upperLower+"LidCurve2"+$side+"TweakedShape.create");
		setAttr ($upperLower+"LidCurve2"+$side+"Shape.intermediateObject") 1;

		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		for ($i=1;$i<($numLid+1);$i++)
			{
			setAttr tempPointOnCurveInfo.parameter (($i-1)/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionMainVtxs[$i-1]`;
				$pos[0]=$pos[0]*$b;
				}
			$eyeJoint="Eye"+$side;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"LidCurve1"+$side);
		duplicate -n ($upperLower+"EyeLidMainCurve1"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidCurves"+$side);

		//EyeLidOuterCurve1 (for loft)
		connectAttr -f ($upperLower+"EyeLidOuterCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		
		int $numLowerLid=20;
		if (`attributeExists selection FaceFitEyeLidMain`)
			$numLowerLid=size($selectionOuterVtxs);
		for ($i=1;$i<$numLowerLid+1;$i++)
			{
			setAttr tempPointOnCurveInfo.parameter (($i-1)/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionOuterVtxs[$i-1]`;
				$pos[0]=$pos[0]*$b;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"EyeLidOuterCurve1"+$side);
		$spans=`getAttr ($upperLower+"EyeLidMainCurve1"+$side+".spans")`;
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 1 -tol 0.004 ($upperLower+"EyeLidOuterCurve1"+$side);	

		for ($i=1;$i<($numLid+1);$i++)
			{
			spaceLocator -n ($upperLower+"LidLoc"+$i+$side);
			parent ($upperLower+"LidLoc"+$i+$side) ("LidLocs"+$side);
			createNode -n ($upperLower+"LidPoci"+$i+$side) pointOnCurveInfo;
			setAttr ($upperLower+"LidPoci"+$i+$side+".turnOnPercentage") 1;
			setAttr ($upperLower+"LidPoci"+$i+$side+".parameter") (($i-1)/($numLid-1.00));
			connectAttr ($upperLower+"LidPoci"+$i+$side+".position") ($upperLower+"LidLoc"+$i+$side+".translate");
			connectAttr ($upperLower+"LidCurve1"+$side+"Shape.worldSpace[0]") ($upperLower+"LidPoci"+$i+$side+".inputCurve");

			createNode -n ($upperLower+"LidInner"+$i+"Aim"+$side) transform;
			parent ($upperLower+"LidInner"+$i+"Aim"+$side) ("LidSetup"+$side);
			setAttr -type float3 ($upperLower+"LidInner"+$i+"Aim"+$side+".t") 0 0 0;
			aimConstraint -worldUpType objectrotation -worldUpObject $headJoint -worldUpVector 1 0 0 ($upperLower+"LidLoc"+$i+$side) ($upperLower+"LidInner"+$i+"Aim"+$side);
			select -cl;
			joint -n ($upperLower+"LidInner"+$i+$side);
			$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+($i-1)+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidInner"+$i+$side);
			parent ($upperLower+"LidInner"+$i+$side) ($upperLower+"LidInner"+$i+"Aim"+$side);
			}
	
		if ($upperLower=="upper")
			duplicate -n ("closedLidCurve2"+$side) ("upperLidCurve2"+$side);
		if ($upperLower=="lower")
			{
			select -r ("upperLidCurve2"+$side) ("lowerLidCurve2"+$side) ("closedLidCurve2"+$side);
			blendShape -n ("closedLidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
			connectAttr ("LidSetup.blinkCenter"+$side) ("closedLidCurveCloseBS"+$side+".upperLidCurve2"+$side);
			connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedLidCurveCloseBS"+$side+".lowerLidCurve2"+$side);
			}
		duplicate -n ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve2"+$side);
		select -r ($upperLower+"LidCurve2"+$side) ("closedLidCurve2"+$side) ($upperLower+"LidCurveClose"+$side);
		blendShape -n ($upperLower+"LidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;

		createNode -n ($upperLower+"CloseLidCurveMixer"+$side) plusMinusAverage;
		connectAttr ("LidSetup.blink"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[0]");
		connectAttr ("LidSetup."+$upperLower+"Lid"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[1]");
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"LidCurveCloseBS"+$side+".closedLidCurve2"+$side);

		createNode -n ($upperLower+"blinkReverse"+$side) reverse;
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"blinkReverse"+$side+".inputX");
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"LidCurve2"+$side);

//		connectAttr ("blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"LidCurve2"+$side);

		//wireDeform in WorldSpace, since wireDefomer does not work well with 180 rotation, and extreme scaling.
		createNode -n ("LidWireWS"+$side) -p ("LidCurves"+$side) transform;
		parentConstraint $headJoint ("LidWireWS"+$side);
		scaleConstraint $headJoint ("LidWireWS"+$side);
		duplicate -n ($upperLower+"LidCurve1OS"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidWireWS"+$side);
		wire -n ($upperLower+"LidCurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve1OS"+$side);
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveWire"+$side+".scale[0]");
		setAttr ($upperLower+"LidCurveWire"+$side+".dropoffDistance[0]") 20;
		connectAttr ($upperLower+"LidCurve1OS"+$side+"Shape.create") ($upperLower+"LidCurve1"+$side+"Shape.create");

		if ($b==1 && $upperLowerFactor==1)
			connectAttr -f tempNearestPointOnCurve.position tempLoc.translate;
		connectAttr -f ($upperLower+"LidCurve1"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;

		if ($upperLower=="upper")
			{
			asPingPong ("upperLidCurve2"+$side+".ep[0]") "LidCorner1" 1 $side 7 1 0;
			asPingPong ("upperLidCurve2"+$side+".ep[2]") "LidCorner2" 1 $side 7 1 0;
			}

		//$upperLower (1)
		$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".ep[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		int $closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid1") 1 $side 7 1 0;

		//$upperLower (2)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		int $closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid2") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid2"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid2"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner1Joint"+$side)} ($upperLower+"Lid2Joint"+$side) 1;
//		setAttr ($upperLower+"Lid2Joint"+$side+"AddIn_parentConstraint1."+$upperLower+"Lid1Joint"+$side+"W0") 3;

		//$upperLower (3)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[3]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		int $closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid3") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid3"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid3"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner2Joint"+$side)} ($upperLower+"Lid3Joint"+$side) 1;
//		setAttr ($upperLower+"Lid3Joint"+$side+"AddIn_parentConstraint1."+$upperLower+"Lid1Joint"+$side+"W0") 3;
/*
		//Bind the curves
		select ("LidCorner1Joint"+$side) ("LidCorner2Joint"+$side) ($upperLower+"Lid1Joint"+$side)
			($upperLower+"Lid2Joint"+$side) ($upperLower+"Lid3Joint"+$side) ($upperLower+"LidCurve2"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"LidCurveSC"+$side);

		skinPercent -tv ("LidCorner1Joint"+$side) 1 ($upperLower+"LidCurveSC"+$side) ($upperLower+"LidCurve2"+$side+".cv[0]");
		skinPercent -tv ($upperLower+"Lid2Joint"+$side) 1 ($upperLower+"LidCurveSC"+$side) ($upperLower+"LidCurve2"+$side+".cv[1]");
		skinPercent -tv ($upperLower+"Lid1Joint"+$side) 1 ($upperLower+"LidCurveSC"+$side) ($upperLower+"LidCurve2"+$side+".cv[2]");
		skinPercent -tv ($upperLower+"Lid3Joint"+$side) 1 ($upperLower+"LidCurveSC"+$side) ($upperLower+"LidCurve2"+$side+".cv[3]");
		skinPercent -tv ("LidCorner2Joint"+$side) 1 ($upperLower+"LidCurveSC"+$side) ($upperLower+"LidCurve2"+$side+".cv[4]");
*/
		connectAttr ("LidCorner2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[4]");
		connectAttr ($upperLower+"Lid3Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[3]");
		connectAttr ($upperLower+"Lid1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[2]");
		connectAttr ($upperLower+"Lid2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[1]");
		connectAttr ("LidCorner1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[0]");

		//now after binding the curve, we can parent the joints
		if ($upperLower=="upper")
			parent ("LidCorner1JointOffset"+$side) ("LidCorner2JointOffset"+$side) LidJoints;
		parent ($upperLower+"Lid1JointOffset"+$side) ($upperLower+"Lid2JointOffset"+$side) ($upperLower+"Lid3JointOffset"+$side) LidJoints;


		// LidControlFollow
		createNode -n ($upperLower+"Lid1JointFollow"+$side) transform;
		$pos=`xform -q -ws -t ($upperLower+"Lid1Joint"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid1JointFollow"+$side);
		$tempString=`listRelatives -p ($upperLower+"Lid1Joint"+$side)`;
		parent ($upperLower+"Lid1JointFollow"+$side) $tempString[0];
		duplicate -n ($upperLower+"Lid1JointFollowBlended"+$side) ($upperLower+"Lid1JointFollow"+$side);
		createNode -n ($upperLower+"Lid1JointFollowLidRot"+$side) transform;
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) $tempString[0];
		$pos=`xform -q -ws -t $eyeJoint`;
		$rot=`xform -q -ws -ro $eyeJoint`;
		asAlign ($upperLower+"Lid1JointFollowLidRot"+$side) $eyeJoint 1 1 0 1;
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($upperLower+"Lid1JointFollowLidRot"+$side);
//		if ($side=="_L")
//			rotate -r -os 0 -180 0 ($upperLower+"Lid1JointFollowLidRot"+$side);
//		setAttr ($upperLower+"Lid1JointFollowLidRot"+$side+".rotateOrder") `getAttr ($eyeJoint+".rotateOrder")`;
		duplicate -n ($upperLower+"Lid1JointFollowLidRotOffset"+$side) ($upperLower+"Lid1JointFollowLidRot"+$side);
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollowLidRotOffset"+$side);
		parentConstraint -mo ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollow"+$side);
		connectAttr ($eyeJoint+".rx") ($upperLower+"Lid1JointFollowLidRot"+$side+".rx");
		connectAttr ($eyeJoint+".ry") ($upperLower+"Lid1JointFollowLidRot"+$side+".ry");
		connectAttr ($eyeJoint+".rz") ($upperLower+"Lid1JointFollowLidRot"+$side+".rz");
//		parentConstraint -mo $eyeJoint ($upperLower+"Lid1JointFollow"+$side);
		createNode -n ($upperLower+"LidFollowMultiply"+$side) multiplyDivide;
		connectAttr ($upperLower+"Lid1JointFollow"+$side+".t") ($upperLower+"LidFollowMultiply"+$side+".input1");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2X");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Y");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Z");
		connectAttr ($upperLower+"LidFollowMultiply"+$side+".output") ($upperLower+"Lid1JointFollowBlended"+$side+".t");
		asFaceAddIn {($upperLower+"Lid1JointFollowBlended"+$side)} ($upperLower+"Lid1Joint"+$side) 1;
		}
	}

//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLid ("ctrlEye"+$side)`)
		addAttr -ln "upperLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLid ("ctrlEye"+$side)`)
		addAttr -ln "lowerLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);

	if (`objExists LidSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("LidSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("LidSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("LidSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0.2;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") 10 ("LidSetup.upperLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") -10 ("LidSetup.upperLid"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") 10 ("LidSetup.lowerLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") -10 ("LidSetup.lowerLid"+$side) -1;
		setAttr ("LidSetup.upperLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidFollow") 10 ("LidSetup.upperLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".upperLidFollow") 10;
		setAttr ("LidSetup.lowerLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidFollow") 10 ("LidSetup.lowerLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 3;
		}
	connectAttr ("ctrlEye"+$side+".sx") ("LidSetup"+$side+".sz");
	connectAttr ("ctrlEye"+$side+".sy") ("LidSetup"+$side+".sy");
	connectAttr ("ctrlEye"+$side+".sz") ("LidSetup"+$side+".sx");
	}

//EyeLidSkinCage
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	loft -n ($upperLower+"tempLoft_R") -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true ($upperLower+"EyeLidMainCurve1_R") ($upperLower+"EyeLidOuterCurve1_R");
	nurbsToPoly -n ($upperLower+"EyeLidSkinCage_R") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+"tempLoft_R");
	delete ($upperLower+"tempLoft_R");
	}

//polyUnite upperLower
polyUnite -ch 0 -mergeUVSets 1 -name ("EyeLidSkinCage_R") ("upperEyeLidSkinCage_R") ("lowerEyeLidSkinCage_R");
polyMergeVertex -d 0.0001 -am 1 -ch 0 ("EyeLidSkinCage_R");

//Weighting Lid
sets -em -n eyeLidVtxs;
if (`objExists "Sets"`)
	sets -add "Sets" eyeLidVtxs;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max (2*$numLid) $gMainProgressBar;

select faceLid;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$numLid=$numLidUpper;}
	else {$upperLower="lower";$numLid=$numLidLower;}

	for ($i=1;$i<($numLid+1);$i++)
		select -add ($upperLower+"LidInner"+$i+"_R");
	}
select -d ("lowerLidInner"+"1_R") ("lowerLidInner"+$numLidLower+"_R");//not include first/last lower joints, avoid overlap
select -add ("EyeLidSkinCage_R");
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] ("KidSC_R");
$tempInts=`polyEvaluate -v ("EyeLidSkinCage_R")`;
for ($i=0;$i<$tempInts[0];$i++)
	{
	$tempString=`skinPercent -ignoreBelow 0.001 -q -t ("KidSC_R") ("EyeLidSkinCage_R.vtx["+$i+"]")`;
	if (size($tempString)>1)
		skinPercent -tv faceLid 1 ("KidSC_R") ("EyeLidSkinCage_R.vtx["+$i+"]");
	}
//find vtx within sphere volume (to copy weights to)
polySphere -n tempVolumeSphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
delete `pointConstraint LidCorner1Joint_R LidCorner2Joint_R tempVolumeSphere`;
float $posA[]=`xform -q -ws -t tempVolumeSphere`;
float $longestDist=0;
for ($i=0;$i<7;$i++)
	{
	float $posB[]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+$i+"]")`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist>$longestDist)
		$longestDist=$dist;
	}
setAttr -type float3 tempVolumeSphere.s $longestDist $longestDist $longestDist;
makeIdentity -a 1 -t 1 -r 1 -s 1 tempVolumeSphere;
selectVtxsInsideGeo $geometry tempVolumeSphere;
$insideVtxs=`ls -sl -fl`;
delete tempVolumeSphere;

//update $insideVtxs to a probably more accurate selection, if used guide-edges
if (`attributeExists selection FaceFitEyeLidMain`)
	{
	asCreateSamplerMesh $geometry;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr samplerMesh.outMesh closestSampler.inMesh;
	$posA=`xform -q -ws -t upperEyeLidMainCurve.ep[2]`;
	$posB=`xform -q -ws -t upperEyeLidOuterCurve.ep[2]`;
	setAttr -type float3 closestSampler.inPosition (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0);
	select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	for ($i=0;$i<30;$i++)
		{
		refresh;
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $selectionMainVtxsAll $selectionOuterVtxsAll;
		}
	select -add $selectionMainVtxsAll $selectionOuterVtxsAll;
	$insideVtxs=`ls -sl -fl`;
	string $mirroredInsideVtxs[];
	delete samplerMesh closestSampler;
	}

//Xfer weights to face
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$numLid=$numLidUpper;}
		else {$upperLower="lower";$numLid=$numLidLower;}
	
		for ($i=1;$i<($numLid+1);$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			skinCluster -e -ai ($upperLower+"LidInner"+$i+$side) -lw false -wt 0 $skinCluster;
			}
		}
	}
select ("EyeLidSkinCage_R.vtx[0:999]") $insideVtxs;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//update eyeLidVtxs-set
for ($i=0;$i<size($insideVtxs);$i++)
	{
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $insideVtxs[$i]`;
	for ($y=0;$y<size($infs);$y++)
		if (`gmatch $infs[$y] "*Lid*"`)
			sets -add eyeLidVtxs $insideVtxs[$i];
	}

//InnerExtra weight
int $numExtra=`getAttr FaceFitEyeLidMain.numExtra`;
select $selectionMainVtxsAll;
$tempString=`ls -sl -fl`;
for ($y=0;$y<$numExtra;$y++)
	{
	clear $tempString3;
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		for ($z=0;$z<$y+1;$z++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d `sets -q eyeLidVtxs`;
			$tempString2=`ls -sl -fl`;
			$tempString3=`stringArrayCatenate $tempString3 $tempString2`;
			}
		}
	for ($i=0;$i<size($tempString);$i++)
		{
		$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`;
		select $tempString[$i];
		for ($z=0;$z<$y+1;$z++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d `sets -q eyeLidVtxs`;
			}
		$tempString2=`ls -sl -fl`;
		for ($a=0;$a<size($tempString2);$a++)
			if (`stringArrayCount $tempString2[$a] $tempString3`==1)
				skinPercent -tv $infs[0] 1 $skinCluster $tempString2[$a];
		}
	}
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//hammer
if (`attributeExists selection FaceFitEyeLidMain`)
	{
	select eyeLidVtxs;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		if ($pos[0]>0)
			select -d $tempString[$i];
		}
	$tempString[0]=`getAttr FaceFitEyeLidMain.upperSelection`;
	eval ("select -d "+$tempString[0]);
	$tempString[0]=`getAttr FaceFitEyeLidMain.lowerSelection`;
	eval ("select -d "+$tempString[0]);
	weightHammerVerts;
	}
delete EyeLidSkinCage_R;
delete upperEyeLidMainCurve1_R upperEyeLidOuterCurve1_R lowerEyeLidMainCurve1_R lowerEyeLidOuterCurve1_R;
delete upperEyeLidMainCurve1_L upperEyeLidOuterCurve1_L lowerEyeLidMainCurve1_L lowerEyeLidOuterCurve1_L;
}

global proc asAdvancedEyeBrow ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;

//create curves around forhead region
$curveCmd="curve -d 3 ";
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("EyeBrowOuter"+$i)`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve1;

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeBrowOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;delete `pointConstraint EyeBrowOuter6 EyeLidOuter6 tempGeoSnapLoc`;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeLidOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve2;

duplicate -n foreHeadBorderCurve3 upperEyeLidMainCurve;
parent -w foreHeadBorderCurve3;
$tempString=`listRelatives -s foreHeadBorderCurve3`;
rename $tempString[0] "foreHeadBorderCurveShape3";
reverseCurve -ch 0 -rpo 1 "foreHeadBorderCurve3";

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeLidMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidOuter0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<10;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve4;

//select vtx`s from forehead region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
string $borderVtxs[];
progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("foreHeadBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
//			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				$borderVtxs[size($borderVtxs)]=$vtx;
			}
		}
	}
//ensure complete loop
select $borderVtxs;
asEnsureSelectionCompleteLoop;
$borderVtxs=`ls -sl -fl`;

//Find centerForHead vtx to grow from
$posA=`xform -q -ws -t foreHeadBorderCurve1.cv[0]`;
$posB=`xform -q -ws -t foreHeadBorderCurve4.cv[2]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $foreheadStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete tempGeoSnapLoc tempPointOnCurveInfo samplerMesh closestSampler;

//grow until forehead region, to create separate forhead object;
select $foreheadStartVtx;
for ($i=0;$i<30;$i++)
{
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d $borderVtxs;
}
select -add $borderVtxs;
sets -n foreHeadVtxs;
if (`objExists "Sets"`)
	sets -add "Sets" foreHeadVtxs;
select -d $borderVtxs;
ConvertSelectionToFaces;
string $forheadFaces[]=`ls -sl`;

duplicate -n foreheadGeo $geometry;
asLockAttr foreheadGeo 0 0 0 0;
$tempString=`listRelatives -p foreheadGeo`;
if (size($tempString))
	parent -w foreheadGeo;
$tempString=`listRelatives -s foreheadGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
select foreheadGeo.f[0:99999];
for ($i=0;$i<size($forheadFaces);$i++)
	select -d (`substitute $geometry $forheadFaces[$i] foreheadGeo`);
delete;

//ncloth
select foreheadGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] foreheadNCloth;
setAttr foreheadNCloth.ignoreSolverGravity 1;
setAttr foreheadNCloth.damp 10;
setAttr foreheadNCloth.stretchResistance 0;
setAttr foreheadNClothShape.selfCollide 0;
setAttr foreheadNCloth.selfCollisionFlag 4;
setAttr foreheadNCloth.stretchResistance 5;
setAttr foreheadNCloth.compressionResistance 3;
setAttr foreheadNCloth.bendResistance 3;

select -r foreheadGeo.vtx[0:9999];
refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$tempString=`createNConstraint transform 0`;
print (":"+$tempString[0]+"\n");
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

$curveCmd="curve -d 3 ";
$pos=`xform -q -ws -t EyeBrowOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];

spaceLocator -n tempGeoSnapLoc;delete `pointConstraint EyeBrowOuter6 EyeBrowMain6 tempGeoSnapLoc`;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;

$pos=`xform -q -ws -t EyeBrowMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain5`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain4`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain3`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain2`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain1`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<10;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeBrowMain0`;$curveCmd+=" -p "+($pos[0]*-1)+" "+$pos[1]+" "+$pos[2];

$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] EyeBrowMainCurve2;
connectAttr EyeBrowMainCurve.controlPoints[0] EyeBrowMainCurve2.cv[8];
connectAttr EyeBrowMainCurve.controlPoints[1] EyeBrowMainCurve2.cv[7];
connectAttr EyeBrowMainCurve.controlPoints[2] EyeBrowMainCurve2.cv[6];
connectAttr EyeBrowMainCurve.controlPoints[3] EyeBrowMainCurve2.cv[5];
connectAttr EyeBrowMainCurve.controlPoints[4] EyeBrowMainCurve2.cv[4];
connectAttr EyeBrowMainCurve.controlPoints[5] EyeBrowMainCurve2.cv[3];
connectAttr EyeBrowMainCurve.controlPoints[6] EyeBrowMainCurve2.cv[2];
circle -n EyeBrowCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($scale/100.0) -d 3 -ut 0 -tol 0.00393701 -s 8 -ch 1;
extrude -n EyeBrowExtrude -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 EyeBrowCircle EyeBrowMainCurve2;
nurbsToPoly -n EyeBrowMainPoly -mnd 1  -ch 1 -f 2 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 20 -vt 2 -vn 256 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowExtrude;

nurbsToPoly -n eyeBrowPoly -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 8 -vt 1 -vn 8 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowCylinderMain;
select -r foreheadGeo EyeBrowMainPoly;
//select -r foreheadGeo eyeBrowPoly;
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNClothRigid1;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempNClothConstraint2;

setAttr tempNClothConstraintShape2.constraintMethod 2;
setAttr tempNClothConstraintShape2.connectionMethod 1;
float $posA[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][1]`;
float $posB[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][5]`;
//float $posA[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][1]`;
//float $posB[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][5]`;
float $browWidth=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
setAttr tempNClothConstraintShape2.maxDistance ($browWidth/2.0);
duplicate -n foreheadGeoSlideOn foreheadGeo;
setAttr foreheadGeoSlideOn.v 0;
select -r foreheadGeo.vtx[0:655] ;
select -add foreheadGeoSlideOn;
$tempString=`createNConstraint slideOnSurface 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNRigid;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempdynamicConstraint;
setAttr tempdynamicConstraintShape.collideWidthScale 0;

//Find nearby vtx and remove these from the slideConstraint, to have smoother the main eyeBrow part
select -r foreheadGeo;
string $nearBrowVtxs[];
for ($i=0;$i<56;$i++)
	{
	$pos=`xform -q -ws -t eyeBrowPoly.vtx[$i]`;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $browWidth -dp $pos[0] $pos[1] $pos[2];
	select -add $nearBrowVtxs;
	$nearBrowVtxs=`ls -sl`;
	}
polySelectConstraint -m 0;
select $nearBrowVtxs;
select -add tempdynamicConstraint;
dynamicConstraintMembership "remove";
}

global proc asAdvancedJaw ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
float $scale=`asFaceGetScale`;
string $tempString[];

//Existing Jaw ?
if (`objExists Jaw_M`)
	error "Jaw_M already exists, can not build new Jaw, remove old jaw first";

createNode -n JawSetup -p FaceMotionSystem transform;
createNode -n JawSetupFollowHead -p JawSetup transform;
parentConstraint $headJoint JawSetupFollowHead;
scaleConstraint $headJoint JawSetupFollowHead;

createNode -n JawUpVectorOffset -p JawSetup transform;
parentConstraint $headJoint JawUpVectorOffset;
createNode -n JawUpVector transform;
parent JawUpVector JawUpVectorOffset;
setAttr -type float3 JawUpVector.t 0 0 0;

select -cl;
float $pos[]=`xform -q -ws -t JawOuterCurve.cv[6]`;
joint -n Jaw_M;
xform -ws -t 0 $pos[1] $pos[2] Jaw_M;
delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject JawUpVector JawMain0 Jaw_M`;
select -cl;
joint -n TeethUpper_M;
parent Jaw_M TeethUpper_M FaceAttachToHead;
//setAttr TeethUpper_M.ty ($scale*0.2);
makeIdentity -a 1 -t 0 -r 1 -s 0 Jaw_M;

select -cl;
joint -n TeethLower_M;
parent TeethLower_M Jaw_M;
//setAttr TeethLower_M.ty ($scale*-0.2);
string $curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve FKTeethTemplate;
sets -add FaceControlSet FKTeethTemplate;
setAttr FKTeethTemplateShape.overrideEnabled 1;
setAttr FKTeethTemplateShape.overrideColor 17;
setAttr -type float3 FKTeethTemplate.s ($scale/86.0) ($scale/36.0) ($scale/250.0);
rotate -r -os 90 0 0 FKTeethTemplate;
makeIdentity -a 1 -t 0 -r 1 -s 1 FKTeethTemplate;

string $upperLower,$upperLowerTeeth,$teethUpperLowerM;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;$teethUpperLowerM="TeethUpper_M";}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;$teethUpperLowerM="TeethLower_M";}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			select $tempString[0];
		float $bb[]=`xform -q -bb`;
		xform -ws -t (($bb[0]+$bb[3])/2.0) (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) $teethUpperLowerM;
		duplicate -n ("FK"+$teethUpperLowerM) FKTeethTemplate;
		asAlign ("FK"+$teethUpperLowerM) $teethUpperLowerM 1 1 0 0;
		createNode -n ("FKOffset"+$teethUpperLowerM) transform;
		asAlign ("FKOffset"+$teethUpperLowerM) ("FK"+$teethUpperLowerM) 1 1 0 0;
		parent ("FK"+$teethUpperLowerM) ("FKOffset"+$teethUpperLowerM);
		parent ("FKOffset"+$teethUpperLowerM) JawSetupFollowHead;
		parentConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		scaleConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		move -r ($scale*0.33) 0 0 ("FK"+$teethUpperLowerM+".cv[0:8]");
		}
	}
delete FKTeethTemplate;

select Jaw_M;
joint -n JawEnd_M;
float $pos2[]=`xform -q -ws -t JawMain0`;
xform -ws -t $pos2[0] $pos2[1] $pos2[2] JawEnd_M;
setAttr Jaw_M.segmentScaleCompensate 0;
setAttr TeethUpper_M.segmentScaleCompensate 0;
setAttr TeethLower_M.segmentScaleCompensate 0;

string $curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve FKJaw_M;
sets -add FaceControlSet FKJaw_M;
setAttr FKJaw_MShape.overrideEnabled 1;
setAttr FKJaw_MShape.overrideColor 17;
//setAttr FKJaw_M.rx -90;
setAttr -type float3 FKJaw_M.s ($scale/18.0) ($scale/18.0) ($scale/36.0);
makeIdentity -a 1 -t 0 -r 0 -s 1 FKJaw_M;
createNode -n FKOffsetJaw_M transform;
createNode -n FKSDK1Jaw_M -p FKOffsetJaw_M transform;
createNode -n FKSDK2Jaw_M -p FKSDK1Jaw_M transform;
parent FKOffsetJaw_M JawSetupFollowHead;
parent FKJaw_M FKSDK2Jaw_M;
asAlign FKOffsetJaw_M Jaw_M 1 1 0 0;
parentConstraint FKJaw_M Jaw_M;
scaleConstraint FKJaw_M Jaw_M;
$pos=`xform -q -ws -t Jaw_M`;
move -r ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) FKJaw_M.cv[0:8];
rotate -r -p $pos2[0] $pos2[1] $pos2[2] -os 0 90 90 FKJaw_M.cv[0:8];
if ($lowerTeeth!="")
	parent FKOffsetTeethLower_M FKJaw_M;
asSkinJaw;
}

global proc asAdvancedCheek ()
{
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

select jawArea;
ConvertSelectionToFaces;
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $mouthAreFaces[]=`ls -sl`;
duplicate -n mouthGeo $geometry;
asLockAttr mouthGeo 0 0 0 0;
$tempString=`ls -l mouthGeo`;
if (`gmatch $tempString[0] "*?|*"`)
	parent -w mouthGeo;
$tempString=`listRelatives -s mouthGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
string $tempString[]=`listRelatives -s mouthGeo`;
if ($tempString[0]!="mouthGeoShape")
	rename $tempString[0] "mouthGeoShape";
sets -remove grownUpLipVtxs mouthGeoShape.vtx[0:9999];
sets -remove grownUpLipVtxsInverse mouthGeoShape.vtx[0:9999];
select mouthGeo.f[0:99999];
for ($i=0;$i<size($mouthAreFaces);$i++)
	select -d (`substitute $geometry $mouthAreFaces[$i] mouthGeo`);
delete;

createNode -n lipGeometry transform;
setAttr lipGeometry.v 0;
int $loop1VtxNrs[]={0,3,7,11,17,37,40,46,128,131,134,140,160,163,168};
int $loop2VtxNrs[]={12,13,16,18,39,41,45,47,133,135,139,141,162,164,169};
int $loop3VtxNrs[]={14,15,20,21,43,44,49,50,137,138,143,144,166,167,171};
int $loop4VtxNrs[]={8,9,10,19,36,38,42,48,130,132,136,142,161,165,170};
int $loop5VtxNrs[]={25,26,28,29,54,55,61,62,148,149,155,156,175,176,181};
int $loop6VtxNrs[]={22,23,24,27,52,53,59,60,146,147,153,154,173,174,180};
int $loop7VtxNrs[]={31,32,34,35,57,58,64,65,151,152,158,159,178,179,183};
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if ($side=="_R")
			{
			nurbsToPoly -n ($upperLower+"LipCylinderPoly_R") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 16 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+"LipCylinder");
			parent ($upperLower+"LipCylinderPoly"+$side) lipGeometry;
			}
		else
			{
			duplicate -n ($upperLower+"LipCylinderPoly_L") ($upperLower+"LipCylinderPoly_R");
			setAttr ($upperLower+"LipCylinderPoly_L.sx") -1;
			connectAttr ($upperLower+"LipCylinderPoly_R.outMesh") ($upperLower+"LipCylinderPoly_L.inMesh");
			}
		
		duplicate -n ($upperLower+"LipCylinderPolyBS"+$side) ($upperLower+"LipCylinderPoly"+$side);
		select ($upperLower+"LipCylinderPoly"+$side) ($upperLower+"LipCylinderPolyBS"+$side);
		blendShape -n ($upperLower+"LipBS"+$side) -frontOfChain -w 0 1;
		blendShape -e  -t ($upperLower+"LipCylinderPolyBS"+$side) 1 ($upperLower+"LipCylinderPoly"+$side) 1 ($upperLower+"LipCylinderPolyBS"+$side);

		if ($side=="_L")
			for ($i=0;$i<240;$i++)
				setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$i+"]") 0;

		for ($i=0;$i<size($loop1VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop1VtxNrs[$i]+"]") 0.5;
		for ($i=0;$i<size($loop2VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop2VtxNrs[$i]+"]") `abs($b-0.49)`;
		for ($i=0;$i<size($loop3VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop3VtxNrs[$i]+"]") `abs($b-0.35)`;
		for ($i=0;$i<size($loop4VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop4VtxNrs[$i]+"]") `abs($b-0.2)`;
		for ($i=0;$i<size($loop5VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop5VtxNrs[$i]+"]") `abs($b-0.1)`;
		}
	}

select mouthGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] mouthNCloth;
setAttr mouthNCloth.ignoreSolverGravity 1;
setAttr mouthNCloth.damp 10;
setAttr mouthNCloth.stretchResistance 0;
setAttr mouthNCloth.selfCollide 0;
setAttr mouthNCloth.selfCollisionFlag 4;
setAttr mouthNCloth.stretchResistance 5;
setAttr mouthNCloth.compressionResistance 3;
setAttr mouthNCloth.bendResistance 3;
setAttr mouthNCloth.selfCollide 0;

select -r mouthGeo.vtx[0:9999];

refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$borderVtxs=`ls -sl`;
$tempString=`createNConstraint transform 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

//find $grownUpLipVtxsOnMouthGeo & $grownUpLipVtxsInverseOnMouthGeo
string $grownUpLipVtxsOnMouthGeo[];
asCreateSamplerMesh mouthGeo;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
select `sets -q grownUpLipVtxs`;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$grownUpLipVtxsOnMouthGeo[$i]="mouthGeo.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	}
delete samplerMesh closestSampler;
select $grownUpLipVtxsOnMouthGeo;
InvertSelection;
string $grownUpLipVtxsInverseOnMouthGeo[]=`ls -sl`;

//constraint to lipGeo
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
	
		select -r mouthGeo ($upperLower+"LipCylinderPolyBS"+$side);
		$tempString=`createNConstraint pointToPoint 0`;
		$tempString2=`listRelatives -p $tempString[0]`;
		rename $tempString2[0] ($upperLower+"LipNClothRigid"+$side);
		$tempString2=`listRelatives -p $tempString[1]`;
		rename $tempString2[0] ($upperLower+"LipNClothConstraint"+$side);
	
		select ($upperLower+"LipNClothConstraint"+$side);
		select -add $borderVtxs;
		if ($upperLower=="upper")	select -add $grownUpLipVtxsInverseOnMouthGeo;
		if ($upperLower=="lower")	select -add $grownUpLipVtxsOnMouthGeo;
		dynamicConstraintMembership "remove";
		
		setAttr ($upperLower+"LipNClothConstraint"+$side+".constraintMethod") 2;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".connectionMethod") 1;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".maxDistance") ($scale*0.01);//using 1% of facescale as skinOffset
		}
	}

//constraint to JawCylinderMainPoly
asFaceClothConstraint JawCylinderMain ($scale*0.01);

//constraint to Nose
asFaceClothConstraint NoseCylinder ($scale*0.01);

//constraint to noseCorner
asFaceClothConstraint noseCornerSphere ($scale*0.01);

//constraint to lowerEyeLidCylinderPolyOuter_R
asFaceClothConstraint lowerEyeLidCylinderOuter ($scale*0.01);

//Cheek Puff & Suck forceFields
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekPuffDynamicConstraint;
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekSuckDynamicConstraint;
setAttr -type float3 CheekPuffDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr -type float3 CheekSuckDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr CheekPuffDynamicConstraintShape.force ($scale/1.5);
setAttr CheekSuckDynamicConstraintShape.force ($scale/1.5);

$pos=`xform -q -ws -t cheek`;
xform -ws -t ($pos[0]+($scale*0.02)) $pos[1] ($pos[2]-($scale*0.02)) CheekPuffDynamicConstraint;
xform -ws -t ($pos[0]-($scale*0.02)) $pos[1] ($pos[2]+($scale*0.02)) CheekSuckDynamicConstraint;
setKeyframe -v 0 -t 100 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 101 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 105 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 106 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 110 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 111 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 115 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 0 -t 116 CheekSuckDynamicConstraintShape.ena;


//Find LipVtxs
select -r mouthGeo upperLipCylinderPoly_R;CreateWrap;
select -r mouthGeo upperLipCylinderPoly_L;AddWrapInfluence;
select -r mouthGeo lowerLipCylinderPoly_R;AddWrapInfluence;
select -r mouthGeo lowerLipCylinderPoly_L;AddWrapInfluence;
$tempString=`listConnections mouthGeo.inMesh`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.exclusiveBind 0;
setAttr tempWrap.maxDistance ($scale*0.01);
setAttr upperLipCylinderPoly_R.tz (100*$scale);setAttr upperLipCylinderPoly_L.tz (100*$scale);
setAttr lowerLipCylinderPoly_R.tz (100*$scale);setAttr lowerLipCylinderPoly_L.tz (100*$scale);
int $tempInts[]=`polyEvaluate -v mouthGeo`;
int $numVtx=$tempInts[0];
select -cl;
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ("mouthGeo.vtx["+$i+"]")`;
	if ($pos[2]>(50*$scale))
		select -add  ("mouthGeo.vtx["+$i+"]");
	}
setAttr upperLipCylinderPoly_R.tz 0;setAttr upperLipCylinderPoly_L.tz 0;
setAttr lowerLipCylinderPoly_R.tz 0;setAttr lowerLipCylinderPoly_L.tz 0;
string $lipArea[]=`ls -sl`;
delete tempWrap;
createNode -n lipArea objectSet;
	if (`objExists "Sets"`)
		sets -add "Sets" lipArea;
sets -add lipArea $lipArea;
}

global proc asAdvancedLip ()
{
//Lip PingPongs
float $posA[]=`xform -q -ws -t Lip6`;
float $posB[]=`xform -q -ws -t upperLip0`;
float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
if (!`attributeExists falloffRadius Lip6`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double Lip6;
if (!`attributeExists falloffMode Lip6`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 Lip6;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	softCluster Lip6 Lip6 $b $side;
	sets -e -forceElement asFaceGreenSG ("Lip6"+$side);
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	float $posA[]=`xform -q -ws -t ($upperLower+"Lip0")`;
	float $posB[]=`xform -q -ws -t Lip6`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip0")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip0");
	if (!`attributeExists falloffMode ($upperLower+"Lip0")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip0");
	softCluster ($upperLower+"Lip0") ($upperLower+"Lip0") 1 "_M";
	sets -e -forceElement asFaceGreenSG ($upperLower+"Lip0_M");

	float $posA[]=`xform -q -ws -t ($upperLower+"Lip3")`;
	float $posB[]=`xform -q -ws -t Lip6`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip3")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip3");
	if (!`attributeExists falloffMode ($upperLower+"Lip3")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip3");
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster ($upperLower+"Lip3") ($upperLower+"Lip3") $b $side;
		sets -e -forceElement asFaceBrownSG ($upperLower+"Lip3"+$side);
		}
	}
}

global proc asAdvancedTongue ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
if ($tongue=="")
	return;
float $scale=`asFaceGetScale`/3.0;
string $tongueSkinCluster="";
string $tempString[];

createNode -n TongueSetup -p FaceMotionSystem transform;

//Tongue setup
select -cl;
joint -n tempTongueJoint;
select -add TongueCurve;
pathAnimation -n motionPathTemp -fractionMode true -follow true -followAxis x -upAxis z -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $headJoint -inverseUp false -inverseFront false -bank false -startTimeU `playbackOptions -query -minTime` -endTimeU  `playbackOptions -query -maxTime`;
delete `listConnections -scn 1 motionPathTemp.uValue`;
setAttr motionPathTemp.uValue 0;refresh;
duplicate -n faceRigTongue0_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.5;refresh;
duplicate -n faceRigTongue1_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.75;refresh;
duplicate -n faceRigTongue2_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.9;refresh;
duplicate -n faceRigTongue3_M tempTongueJoint;
setAttr motionPathTemp.uValue 1;refresh;
duplicate -n faceRigTongue4_M tempTongueJoint;
delete tempTongueJoint;
select FaceAttachToHead;
for ($i=0;$i<5;$i++)
	{
	if ($i==0)
		parent faceRigTongue0_M FaceAttachToHead;
	else
		parent ("faceRigTongue"+$i+"_M") ("faceRigTongue"+($i-1)+"_M");
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("faceRigTongue"+$i+"_M");
	}
setAttr faceRigTongue0_M.overrideEnabled 0;
setAttr faceRigTongue0_M.segmentScaleCompensate 0;
if (`objExists FKJaw_M`)
	{
	parentConstraint -mo FKJaw_M faceRigTongue0_M;
	scaleConstraint FKJaw_M faceRigTongue0_M;
	}

//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
xform -s $scale $scale $scale tempWeightCube;

select -r tempWeightCube.vtx[10:13] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue0;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue0_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue1;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue1_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue2;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue2_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue3;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue3_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[0:3] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue4;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue4_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

duplicate -n tempWeightCube2 tempWeightCube;
select -r tempWeightCube2 faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
select -r tempWeightCube2.vtx[10:13] ;
skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue1_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
skinPercent -tv faceRigTongue1_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue2_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
skinPercent -tv faceRigTongue2_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue3_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[0:3] ;
skinPercent -tv faceRigTongue3_M 1 tongueBoxSC `ls -sl`;

string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
//		skinCluster -n tongueSC -dr 4 -lw false -wt 1 -mi 1;
	$tongueSkinCluster="tongueSC";
	}
else
	skinCluster -e -wt 0 -ai faceRigTongue3_M -ai faceRigTongue2_M -ai faceRigTongue1_M -ai faceRigTongue0_M $tongueSkinCluster;

//move prefix_ inf joints, since in a rebuild case, weights gets copied to these joints instead of new ones
$tempString=`listConnections -type joint -s 1 -d 0 $tongueSkinCluster`;
skinCluster -e -moveJointsMode 1 $tongueSkinCluster;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "prefix_*"`)
		if(`objExists $tempString[$i]`)
			move -r 0 0 -10 $tempString[$i];
skinCluster -e -moveJointsMode 0 $tongueSkinCluster;

eval ("select tempWeightCube2 "+$tongue);
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
delete tempWeightCube tempWeightCube2;

asConnectTongueControl;
}

global proc asUpdateAllSet (string $allBefore[])
{
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;

select $allAfter;
select -ne -d $allSame;
select -ne -d `ls -type objectSet`;
select -d `listRelatives -ad FaceFitSkeleton`;
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] "*[.]*"`)
		sets -add FaceAllSet $sel[$i];
}

global proc asFaceSkinSim (string $faceTargets[], string $wrapDriver)
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $polyAverages[];

//Load custom cloth preset here. e.g:
//select tempNClothShape;
//AttributeEditor;
//applyPresetToNode "|tempNCloth|tempNClothShape" "" "" "C:/Program Files/Autodesk/Maya2015/presets/attrPresets/nCloth/putty.mel" 1;
//setAttr "tempNClothShape.ignoreSolverGravity" 1;

select -r tempTarget;
select -add $wrapDriver;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "0", "0" }`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.maxDistance 0.001;
setAttr tempWrap.exclusiveBind 1;
if (`objExists lipArea`)
	sets -remove lipArea mouthGeoBase.vtx[0:99999];

//remove teeth from wrapSet
$tempString=`listConnections tempWrap.message`;
rename $tempString[0] tempWrapSet;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1)  $teeth=$upperTeeth;
	if ($upperLowerFactor==-1) $teeth=$lowerTeeth;
	if ($teeth!="")
		{
		$tempString=`stringToStringArray $teeth " "`;
		select -cl;
		for ($i=0;$i<size($tempString);$i++)
			{
			$sub=`substitute $geometry $tempString[$i] "tempTarget"`;
			if (`objExists $sub`)
				select -add $sub;
			}
		if (size(`ls -sl`))
			{
			ConvertSelectionToVertices;
			sets -remove tempWrapSet `ls -sl`;
			}
		}
	}

int $time=-5;
createNode -n flipGroup transform;
progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max 24 $gMainProgressBar;
for ($i=0;$i<size($faceTargets);$i++)
	{
	if (`objExists lowerLipBS_L`) //$centerFade
		{
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";
			for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
				{
				if ($upperLowerFactor==1) $upperLower="upper";
				else $upperLower="lower";
				$centerFade=1;
				if (!`gmatch $faceTargets[$i] "*_R"`)
					$centerFade=0;
					{
					setAttr ($upperLower+"LipBS"+$side+".w[0]") $centerFade;
					setAttr ($upperLower+"LipBS"+$side+".w[1]") (!$centerFade);
					}
				}
			}
		}
	if ($faceTargets[$i]=="mouth_wide_C")
		{
		select lipArea;
		for ($y=0;$y<2;$y++)
			{
			$tempString=`polyAverageVertex -i 10 -ch 1`;
			$polyAverages[$y]=$tempString[0];
			}
		}

//	currentTime 0;
	currentTime $time;
	for ($y=0;$y<10;$y++)
		{
		$time++;
		currentTime $time;
		progressBar -e -s 1 $gMainProgressBar;
		}
	for ($y=0;$y<5;$y++)
		{
		currentTime ($time-1);	
		currentTime $time;	
		}
	duplicate -n $faceTargets[$i] tempTarget;

	if ($faceTargets[$i]=="mouth_wide_C") delete $polyAverages;

	if (!`gmatch $faceTargets[$i] "*_R"`)
		continue;

	//mirror target
	string $leftTarget=`substitute "_R" $faceTargets[$i] "_L"`;
	duplicate -n $leftTarget target_default;
//	parent $leftTarget faceTargets;
	duplicate -n WrapDriver $faceTargets[$i];
	setAttr flipGroup.sx 1;
	parent WrapDriver flipGroup;
	setAttr flipGroup.sx -1;
	select target_default WrapDriver;
	$tempString=`blendShape -frontOfChain`;
	rename $tempString[0] tempBS;
	setAttr tempBS.target_default 1;
	select -r $leftTarget;
	select -add WrapDriver;
	$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "0", "0" }`;
	rename $tempString[0] tempWrap2;
	setAttr tempWrap2.exclusiveBind 1;
	setAttr tempBS.target_default 0;
	select $leftTarget;
	DeleteHistory;
	delete WrapDriver;
}
delete flipGroup;
currentTime 0;
}

global proc asFaceClothConstraint (string $nurbs, float $maxDistance)
{
nurbsToPoly -n ($nurbs+"Poly") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 32 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 $nurbs;
setAttr ($nurbs+"Poly.v") 0;
select -r mouthGeo ($nurbs+"Poly");
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] ($nurbs+"NClothRigid");
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] ($nurbs+"NClothConstraint");
setAttr ($nurbs+"NClothConstraint.constraintMethod") 2;
setAttr ($nurbs+"NClothConstraint.connectionMethod") 1;
setAttr ($nurbs+"NClothConstraint.maxDistance") $maxDistance;//using 1% of facescale as skinOffset
}

global proc selectVtxsInsideGeo (string $geometry, string $volumeGeo)
{
int $tempInts[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInts[0];
float $pos[];
string $cpomNode = `createNode closestPointOnMesh`;
connectAttr ($volumeGeo + ".worldMesh") ($cpomNode + ".inMesh");
connectAttr -f ($volumeGeo+".worldMatrix[0]") ($cpomNode+".inputMatrix");
select -cl;
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	setAttr ($cpomNode + ".inPositionX") $pos[0];
	setAttr ($cpomNode + ".inPositionY") $pos[1];
	setAttr ($cpomNode + ".inPositionZ") $pos[2];
	vector $queryPoint = <<$pos[0], $pos[1], $pos[2]>>;
	float $cPosX = `getAttr ($cpomNode + ".positionX")`;
	float $cPosY = `getAttr ($cpomNode + ".positionY")`;
	float $cPosZ = `getAttr ($cpomNode + ".positionZ")`;
	vector $pos = unit($queryPoint - <<$cPosX, $cPosY, $cPosZ>>);
	float $nX = `getAttr ($cpomNode + ".normalX")`;
	float $nY = `getAttr ($cpomNode + ".normalY")`;
	float $nZ = `getAttr ($cpomNode + ".normalZ")`;
	vector $normal = unit(<<$nX, $nY, $nZ>>);
	if (dot($normal, $pos) <= 0)
		select -add ($geometry+".vtx["+$i+"]");
	}
delete $cpomNode;
}

global proc asFaceCreateTestDuplicate ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
if ($geometry=="")
	error "No \"Face\" Geometry choosen yet";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
createNode -n FaceSymmetryTestGroup transform;
duplicate -n FaceSymmetryTest $geometry;
parent FaceSymmetryTest FaceSymmetryTestGroup;
asLockAttr FaceSymmetryTestGroup 1 1 0 1;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sy;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sz;
setAttr FaceSymmetryTestGroup.sx -1;
select FaceSymmetryTestGroup;
connectControl asFaceDuplicateSlider FaceSymmetryTestGroup.sx;
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $shape;
string $tempString[];
//remove possible defomers first
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (size($tempString)<2)
		continue;
	$tempString=`listRelatives -ni -s $sel[$i]`;
	delete `listRelatives -s -ni $sel[$i]`;
	$tempString=`listRelatives -s $sel[$i]`;
	$shape=$tempString[0];
	setAttr ($shape+".intermediateObject") 0;
	$tempString=`listConnections -p 1 ($shape+".worldMesh[0]")`;
	if (size($tempString))
		disconnectAttr ($shape+".worldMesh[0]") $tempString[0];
	print ("// Deleting history for \""+$sel[$i]+"\", to avoid double deformations;\n");
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceSkinEyeLashes ()
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $numLid,$haveSkinCluster;
string $skinCluster;
string $tempString[],$historyNodes[];

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidInner"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidInner"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidInner"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select $geometry ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		
		for ($y=1;$y<$numLid+1;$y++)
			{
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			artAttrSkinWeightCopy;
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			artAttrSkinWeightPaste;
			}
		}
	}

select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	select $sel[$i];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidInner"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			if ($haveSkinCluster)
				for ($y=1;$y<$numLid+1;$y++)
					catchQuiet (`skinCluster -e -ai ($upperLower+"LidInner"+$y+$side) -lw false -wt 0 $skinCluster`);
			if (!$haveSkinCluster)
				{
				for ($y=1;$y<$numLid+1;$y++)
					select -add ($upperLower+"LidInner"+$y+$side);
				}
			}
		}
	if (!$haveSkinCluster)
		{
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=`rename $tempString[0] ($sel[$i]+"EyeLashSC")`;
		}

	select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
	select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
select $sel;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFace"+$region);
	return;
	}
delete ("FaceFit"+$region);
checkBox -e -ed 0 ("asFace"+$region);
}

global proc asEnsureSelectionCompleteLoop ()
{
string $borderVtxs[]=`ls -sl -fl`;
int $neighboursInLoop,$neighboursInLoop2,$expandsBeforeHit,$closestNr;
for ($i=0;$i<size($borderVtxs);$i++)
	{
	select $borderVtxs[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $borderVtxs[$i];
	$tempString=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $tempString[$y] $borderVtxs`)
			$neighboursInLoop++;

	if ($neighboursInLoop<2)
		{
		//edgeloop not complete, must add vtx`s.
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`stringArrayCount $tempString[$y] $borderVtxs`)
				continue;
			select $tempString[$y];
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $tempString[$y] $borderVtxs[$i];
			$tempString2=`ls -sl -fl`;
			int $foundSolution=0;
			for ($z=0;$z<size($tempString2);$z++)
				if (`stringArrayCount $tempString2[$z] $borderVtxs`)
					if (!`stringArrayCount $tempString[$y] $borderVtxs`)
						{
						$borderVtxs11[size($borderVtxs)]=$tempString[$y];
						$foundSolution=1;
						}
			if (!$foundSolution)
				for ($z=0;$z<size($tempString2);$z++)
					{
					if ($foundSolution)continue;
					select $tempString2[$z];
 					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $tempString2[$z];
					$tempString3=`ls -sl -fl`;
					for ($q=0;$q<size($tempString3);$q++)
  					if (`stringArrayCount $tempString3[$q] $borderVtxs`)
  						{
							if (`stringArrayCount $tempString3[$q] $tempString`)
							    continue;
							if (!`stringArrayCount $tempString2[$z] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString2[$z];
							if (!`stringArrayCount $tempString[$y] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString[$y];
              $foundSolution=1;                             
							}
					}
			}
		}
	}
select $borderVtxs;
}

global proc asSkinJaw ()
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $jawJoint="Jaw_M";
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="TeethUpper_M";
string $lowerTeethJoint="TeethLower_M";
string $vtx;
string $tempString[],$borderVtxs[];
float $pos[],$posA[],$posB[],$posC[];

//make sure teeth geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$upperTeeth=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$lowerTeeth=`stringArrayToString $tempString " "`;
	}

//add jaw joint as inf
$tempString=`listConnections ($jawJoint+".worldMatrix[0]")`;
if (!`stringArrayCount $skinCluster $tempString`)
	skinCluster -e -ai $jawJoint -lw false -wt 0 $skinCluster;

//define jawArea
//create curves around jaw region
$curveCmd="curve -d 3 ";
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("JawOuter"+$i)`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve1;

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;delete `pointConstraint JawOuter6 EyeLidOuter6 tempGeoSnapLoc`;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeLidOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve2;

duplicate -n JawBorderCurve3 lowerEyeLidMainCurve;
parent -w JawBorderCurve3;
$tempString=`listRelatives -s JawBorderCurve3`;
rename $tempString[0] "JawBorderCurveShape3";

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeLidMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidOuter0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<10;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve4;


//select vtx`s from Jaw region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
progressBar -e -st ("Setup JawArea") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("JawBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
//			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				$borderVtxs[size($borderVtxs)]=$vtx;
			}
		}
	}
select $borderVtxs;
GrowPolygonSelectionRegion;//Thicken the `Border` for the `Jaw-shell`.
$borderVtxs=`ls -sl -fl`;

//Find center vtx to grow from
$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $posA[1] $posA[2] tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $JawStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;
delete tempGeoSnapLoc JawBorderCurve1 JawBorderCurve2 JawBorderCurve3 JawBorderCurve4;

//grow until Jaw region, to create separate forhead object;
select $JawStartVtx;
for ($i=0;$i<50;$i++)
{
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d $borderVtxs; 
}
select -d `sets -q foreHeadVtxs`;
GrowPolygonSelectionRegion;
select -d `sets -q eyeLidVtxs`;
string $jawArea[]=`ls -sl`;
if (size($jawArea)==0)
	error "Unable to determine the jawArea";
//Remove eyeLidVtxs+grownOnce, to avoid bleeding eyeLidWeights
select eyeLidVtxs;GrowPolygonSelectionRegion;
string $expandedEyeLidVtxs[]=`ls -sl`;
select $jawArea;
select -d $expandedEyeLidVtxs;
$jawArea=`ls -sl`;
createNode -n jawArea objectSet;
	if (`objExists "Sets"`)
		sets -add "Sets" jawArea;
sets -add jawArea $jawArea;

//define 50% vtxs & 0% vtxs (as a line from mouthCnr (noseCnr) to JawStart
duplicate -n JawMainCurve50 JawMainCurve;
$pos=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[5:6];
$posA=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve50.cv[2:4];
duplicate -n JawMainCurve0 JawMainCurve;
$pos=`xform -q -ws -t Nose6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[5:6];
$posA=`xform -q -ws -t Nose6`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve0.cv[2:4];

//All head first
select jawArea;
skinPercent -tv $headJoint 1 $skinCluster `ls -sl`;

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

	tokenize $teeth " " $tempString;
	clear $teethObjects;
	for ($i=0;$i<size($tempString);$i++)
		$teethObjects[$i]=$tempString[$i];

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		if (`gmatch $teethObject "*[.]*"`)
			{
			tokenize $teethObject "." $tempString;
			$teethObject=$tempString[0];
			}
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
			}
		}
	}

//jaw line
asSelectCurveVtx JawMainCurve;
string $jawCurveVtxs[]=`ls -sl`;
skinPercent -tv $jawJoint 1 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve50;
string $jawCurve50Vtxs[]=`ls -sl`;
skinPercent -tv $jawJoint 0.5 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve0;
string $jawCurve0Vtxs[]=`ls -sl`;

//find $LipVtxs
$posA=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t upperLipCylinder.cv[0][7]`;
float $lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
select $geometry;
$pos=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $upperLipVtxs[]=`ls -sl`;
if (!size($upperLipVtxs))
	error ("Failed to find $upperLipVtxs, within radius of \""+$lipRadius+"\" of upperLipCylinder.cv[0][3]");

$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t lowerLipCylinder.cv[0][7]`;
float $lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
$pos=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $lowerLipVtxs[]=`ls -sl`;
polySelectConstraint -m 0;
if (!size($lowerLipVtxs))
	error ("Failed to find $lowerLipVtxs, within radius of \""+$lipRadius+"\" of lowerLipCylinder.cv[0][3]");


//find "$grownUpLipVtxs"
asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t Lip6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $sideLipVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
$pos=`xform -q -ws -t upperLip0`;
string $nearestInYVtx;
float $nearestInYDist=999;
for ($i=0;$i<size($upperLipVtxs);$i++)
	{
	$vtx=$upperLipVtxs[$i];
	float $pos2[]=`xform -q -ws -t $vtx`;
	float $dist=abs($pos[1]-$pos2[1]);
	if ($dist<$nearestInYDist)//closest in TY)
		{
		$nearestInYDist=$dist;
		$nearestInYVtx=$vtx;
		}
	}
select $nearestInYVtx;
string $grownUpLipVtxs[],$grownUpLipVtxsInverse[];
for ($i=0;$i<99;$i++)
	{
	GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount $sideLipVtx $tempString`)
		{
		$grownUpLipVtxs=`ls -sl`;
		sets -n grownUpLipVtxs;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxs;
		InvertSelection;
		$grownUpLipVtxsInverse=`ls -sl`;
		sets -n grownUpLipVtxsInverse;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxsInverse;
		break;
		}
	}

//update $upperLipVtxs[] & $lowerLipVtxs[], for up/lo lip separation
select $upperLipVtxs;
select -d $grownUpLipVtxsInverse;
$upperLipVtxs=`ls -sl`;
select $lowerLipVtxs;
select -d $grownUpLipVtxs;
$lowerLipVtxs=`ls -sl`;

//$noseEndVtx
$pos=`xform -q -ws -t Nose6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $noseEndVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;

skinPercent -tv $jawJoint 0.1 $skinCluster $upperLipVtxs;
skinPercent -tv $jawJoint 0.5 $skinCluster $sideLipVtx;
skinPercent -tv $jawJoint 0.9 $skinCluster $lowerLipVtxs;
skinPercent -tv $jawJoint 0.5 $skinCluster $jawCurve50Vtxs;

select jawArea;
select -d $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx;
select -d $jawCurve50Vtxs $jawCurve0Vtxs `sets -q eyeLidVtxs`;
weightHammerVerts;
select $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx $jawCurve50Vtxs $jawCurve0Vtxs;
weightHammerVerts;
select $jawCurve0Vtxs;GrowPolygonSelectionRegion;GrowPolygonSelectionRegion;
weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<99;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	asFacePaintClusterWeights;
	print "Detected this controller to control a \"Cluster\", starting Cluster Painting Tool";
	}
else
	{
	tokenize $sel[0] "_" $tempString;
	if (!($tempString[1]=="R" || $tempString[1]=="L" || $tempString[1]=="M"))
		$error=1;
	string $joint=$tempString[0]+"Joint_"+$tempString[1];
	print ("$tempString[1]="+$tempString[1]+" "+$joint+"\n");
	if (!`objExists $joint`)
		$error=1;
	if (!$error)
		{
		select $geometry;
		ArtPaintSkinWeightsTool;
		string $currentCtx = `currentCtx`;
		artSkinSelectInfluence artAttrSkinPaintCtx $joint;
		print "Detected this controller to control a \"Joint\", starting Skin Weight Tool";
		}
	}
if ($error)
		error "Unable to detect which joint or cluster this is controlling";
}

global proc asFacePaintClusterWeights ()
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ($geometry+".vtx[0:999999]");
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select $geometry;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asBSWizardStop ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
int $step=$previousStep+1;

if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;

string $objAttr;
float $value;
if ($step==1)
	{$objAttr="ctrlBrow_R.translateY";$value=-1;}
if ($step==2)
	{$objAttr="ctrlBrow_R.translateY";$value=1;}
if ($step==3)
	{$objAttr="ctrlBrow_R.translateX";$value=1;}
if ($step==4)
	{$objAttr="ctrlBrow_R.translateX";$value=-1;}
if ($step==5)
	{$objAttr="ctrlBrow_R.squeeze";$value=10;}
if ($step==6)
	{$objAttr="ctrlBrow_R.outerUpDown";$value=10;}
if ($step==7)
	$step=8;
//	{$objAttr="ctrlBrow_R.outerUpDown";$value=-10;}
if ($step==8)
	{$objAttr="ctrlEye_R.squint";$value=10;}
if ($step==9)
	{$objAttr="ctrlCheek_R.translateY";$value=1;}
if ($step==10)
	{$objAttr="ctrlCheek_R.translateX";$value=1;}
if ($step==11)
	{$objAttr="ctrlCheek_R.translateX";$value=-1;}
if ($step==12)
	{$objAttr="ctrlNose_R.translateY";$value=1;}
if ($step==13)
	{$objAttr="ctrlNose_R.translateX";$value=1;}
if ($step==14)
	{$objAttr="ctrlNose_R.translateX";$value=-1;}
if ($step==15)
	$step=16;
//	{$objAttr="ctrlNose_R.furrowDeepener";$value=10;}
if ($step==16)
	$step=17;
//	{$objAttr="ctrlMouth_M.translateY";$value=-1;}
if ($step==17)
	{$objAttr="ctrlMouth_M.translateX";$value=1;}
if ($step==18)
	{$objAttr="ctrlMouth_M.translateX";$value=-1;}
if ($step==19)
	$step=22;
if ($step==22)
	$step=23;
//	{$objAttr="ctrlMouth_M.jawShut";$value=10;}
if ($step==23)
	$step=24;
//	{$objAttr="ctrlMouth_M.chinRaiser";$value=10;}
if ($step==24)
	$step=25;
//	{$objAttr="ctrlMouth_M.oh";$value=10;}
if ($step==25)
	$step=26;
//	{$objAttr="ctrlMouth_M.pucker";$value=10;}
if ($step==26)
	$step=27;
//	{$objAttr="ctrlMouth_M.funnel";$value=10;}
if ($step==27)
	{$objAttr="ctrlMouth_M.lipPress_R";$value=10;}
if ($step==28)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=10;}
if ($step==29)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=-10;}
if ($step==30)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=10;}
if ($step==31)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=-10;}
if ($step==32)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=-1;}
if ($step==33)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=1;}
if ($step==34)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=1;}
if ($step==35)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=-1;}
if ($step==36)
	$step=37;
//	{$objAttr="ctrlMouthCorner_R.dimpler";$value=10;}
if ($step==37)
	$step=38;
//	{$objAttr="ctrlMouthCorner_R.stretcher";$value=10;}
if ($step==38)
	{
	print ("All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex faceHelpImage`)
		deleteUI faceHelpImage;
	return;
	}

text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asFaceHelpImage asBSWizardStep"+$step) asBSWizardHelpButton;
if (`window -q -ex faceHelpImage`)
	asFaceHelpImage ("asBSWizardStep"+$step);

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

/*
currentTime 1;
setKeyframe $objAttr;
currentTime 10;
setAttr $objAttr $value;
setKeyframe $objAttr;
string $tempString[]=`listConnections $objAttr`;
rename $tempString[0] tempAnimCurve;
*/
print ($step+"/"+$lastStep+"\n");
evalEcho ("setAttr "+$objAttr+" "+$value);
asBSAdjustTarget;
}

global proc asBSResetTarget ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$resetTargets[];
if (!`objExists deleteThis`)
	error "Click create blendshape target first";
$tempString=`listRelatives deleteThis`;
$resetTargets[0]=$tempString[0];
/*
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".v")`)
		$resetTargets[size($resetTargets)]=$tempString[$i];
*/
setAttr asFaceBS.envelope 0;
duplicate -n asBSResetTarget $geometry;
setAttr asFaceBS.envelope 1;
parent asBSResetTarget deleteThis;
$tempString=`listRelatives -s asBSResetTarget`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
for ($i=0;$i<size($resetTargets);$i++)
	{
	select -r asBSResetTarget $resetTargets[$i];
	blendShape -n deleteThisResetBS -frontOfChain;
	setAttr deleteThisResetBS.asBSResetTarget 1;
	select $resetTargets[$i];
	DeleteHistory;
	}
delete asBSResetTarget;
select $sel;
}

global proc asBSExtractAll ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
//for ($i=0;$i<$lastStep;$i++)
createNode -n asBlendShapes transform;
for ($i=0;$i<$lastStep;$i++)
	{
	asBSWizardNext;
	if (`objExists asFaceMirroWrap`)
		delete asFaceMirroWrap;
	if (`text -q -l asBSWizardStepText`=="0/37")
		break;
	parent `listRelatives -c deleteThis` asBlendShapes;
	}
string $tempString[]=`listRelatives -c asBlendShapes`;
for ($i=0;$i<size($tempString);$i++)
	if (!`getAttr ($tempString[$i]+".v")`)
		delete $tempString[$i];
}

global proc asBSAdjustTarget ()
{
select asFaceBS;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $targets[]=`listAttr -m asFaceBS.weight`;
string $targetLeft;
int $targetNum;
float $targetWeights[];
float $targetWeightsSum=0;
for ($i=0;$i<size($targets);$i++)
    {
    $targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
    $targetWeightsSum+=$targetWeights[$i];
    if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
        $targetNum=$i;
    }
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
			print ("asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
	AttributeEditor;
  error "Must have one target set to \"1\", and the rest set to \"0\\n";
  }
if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t JawOuter6`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;
if (`gmatch $targetName "*_R"`)
	{
	$targetLeft=`substitute "_R" $targetName "_L"`;
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
	setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
	}
setAttr ($skinCluster+".envelope") 0;
duplicate -n $targetName $geometry;
asLockAttr $targetName 0 0 0 0;
setAttr ($skinCluster+".envelope") 1;
parent $targetName deleteThis;
move -r ($cheekPos[0]*2.5) 0 0 $targetName;
select $targetName;
string $tempString[]=`listRelatives -f -s $targetName`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
connectAttr -f ($targetName+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$targetNum+"].inputTargetItem[6000].inputGeomTarget");

if (`gmatch $targetName "*_R"`)
    {
    refresh;
    $targetLeft=`substitute "_R" $targetName "_L"`;
    setAttr asFaceBS.envelope 0;
    duplicate -n $targetLeft $geometry;
    asLockAttr $targetLeft 0 0 0 0;
    parent $targetLeft deleteThis;
    setAttr asFaceBS.envelope 1;
    move -r ($cheekPos[0]*-2.5) 0 0 $targetLeft;
    $tempString=`listRelatives -f -s $targetLeft`;
    for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
    duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
    setAttr ($targetLeft+"MirrorDriver.sx") -1;
    setAttr ($targetLeft+"MirrorDriver.v") 0;
/*
    deformer -type wrap $targetLeft;
    select -r $targetLeft ($targetLeft+"MirrorDriver");
    AddWrapInfluence;
*/
    select -r $targetLeft ($targetLeft+"MirrorDriver");
		CreateWrap;
    $tempString=`listConnections ($targetLeft+"MirrorDriver.inflType")`;
		rename $tempString[0] asFaceMirroWrap;
		setAttr asFaceMirroWrap.exclusiveBind 1;
    connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
    
    for ($i=0;$i<size($targets);$i++)
        if ($targets[$i]==$targetLeft)
            connectAttr -f ($targetLeft+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$i+"].inputTargetItem[6000].inputGeomTarget");
    }

floatSlider -e -en 1 asFaceBSFloatSlider;
connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
select $targetName;
}

global proc asFaceConvertSoftModToControl (int $convertingBack)
{
global string $gSelect;
string $sel[]=`ls -sl`;
asFaceEnsureAdvancedBase;
float $pos[3],$posSoftMod[3],$posControl[3],$currentT[3],$currentR[3],$currentS[3];
string $tempString[],$historyList[];
string $side;
int $multiply;
int $autoKeyState=`autoKeyframe -q -state`;
string $fitJoint,$restoreCmd,$setAttrCmdExtra,$softModSet;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];

if ($convertingBack==1)
	{
	if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
		error "convertedSoftModHandle not selected";
	tokenize $sel[0] "_" $tempString;
	$fitJoint=$tempString[1];
	$side="_"+$tempString[2];
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	}
else
	{
	string $allBefore[]=`ls`;
	if (!`gmatch $sel[0] "softMod*"`)
		error "Selection is not a new SoftMod, name does not match \"softMod*\"";
	if ($convertingBack==0)
		{
		if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
			return;
		$fitJoint=`promptDialog -query -text`;
		}
	else if ($convertingBack==2)
		$fitJoint="Smile";
	if (`objExists $fitJoint` || $fitJoint=="")
		error "not a unique name";
	setToolTo $gSelect;

	//find $side, when tx=0
	float $locPos[3]=`getAttr ($sel[0]+".t")`;
	setAttr -type float3 ($sel[0]+".t") 0 0 0;
	float $pos[3]=`xform -q -ws -piv $sel[0]`;
	setAttr -type float3 ($sel[0]+".t") $locPos[0] $locPos[1] $locPos[2];
	$side="_M";
	if (!`checkBox -q -v asFaceIsMiddleControlCheckBox`)
		$side="_R";
	if ($pos[0]>0.001)
		error "SoftMod must be on Right side, or middle, currenly on Left side";

	$sel[0]=`rename $sel[0] ("convertedSoftModHandle_"+$fitJoint+$side)`;
	$tempString=`listConnections ("convertedSoftModHandle_"+$fitJoint+$side+".worldMatrix[0]")`;
	rename $tempString[0] ("convertedSoftMod_"+$fitJoint+$side);
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	string $deformObjs[]=`sets -q -no $softModSet`;
	$deformObjs=`stringArrayRemoveDuplicates $deformObjs`;

	$currentT=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t")`;
	$currentR=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r")`;
	$currentS=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s")`;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".t") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".r") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".s") 1 1 1;
	$posSoftMod=`xform -q -ws -piv ("convertedSoftModHandle_"+$fitJoint+$side)`;
	curve -n tempCurve -d 1 -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -k 0 -k 1;
	deformer -type wrap tempCurve;
	select -r tempCurve;
	select -add $geometry;
	AddWrapInfluence;

	$posControl=`xform -q -ws -t tempCurve.cv[0]`;
	createNode -n tempTransform transform;
	xform -ws -t $posControl[0] $posControl[1] $posControl[2] tempTransform;
	select tempTransform;
	int $color=6;
	if (size($deformObjs)>1)
		$color=9;
	asCreateFaceFitJoint $fitJoint `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffRadius")` $color;
	softCluster $fitJoint $fitJoint 1 $side;
	
	if ($side=="_R")
		{
		//Mirror pose before doing left to ensure identical attachment
		string $restoreCmd=`asFaceMirror`;
		softCluster $fitJoint $fitJoint -1 "_L";
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_R;xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_L;";
	
		eval ($restoreCmd);
		if ($autoKeyState)
			autoKeyframe -state 1;
		}
	else
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_M;";


	delete tempCurve tempTransform;
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t") $currentT[0] $currentT[1] $currentT[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r") $currentR[0] $currentR[1] $currentR[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s") $currentS[0] $currentS[1] $currentS[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	//add to faceBuildPose
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

	//FaceAllset
	string $allAfter[]=`ls`;
	string $allNew[];
	for ($i=0;$i<size($allAfter);$i++)
		if (!`stringArrayCount $allAfter[$i] $allBefore`)
			if (`objectType $allAfter[$i]`!="objectSet")
				$allNew[size($allNew)]=$allAfter[$i];
	sets -add FaceAllSet $allNew;
	sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;
	}

float $t[3]=`xform -q -ws -piv $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;

$pos=`xform -q -ws -t $fitJoint`;
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
string $cluster=$fitJoint+"Cluster"+$side;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;

float $falloffMode=`getAttr ($softMod+".falloffMode")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
setAttr ($fitJoint+".falloffMode") $falloffMode;

select $softModSet;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;

percent -v 0 $cluster $geometry;
asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;
if ($convertingBack)
	{
	select ($fitJoint+$side);
	asFaceMirrorClusterWeight;
	}
xform -ws -t $t[0] $t[1] $t[2] -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] ($fitJoint+$side);
select ($fitJoint+$side);
}

global proc asFaceConvertControlToSoftMod ()
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;

string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
$tempString=`listConnections ($sel[0]+".s")`;
if (!`gmatch $tempString[0] "*Cluster*"`)
	error "Selected object is not a \"cluster\" control";
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
if ($side=="_L")
	error "must be Right side";
float $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
float $falloffMode=`getAttr ($fitJoint+".falloffMode")`;

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ($geometry+".vtx[0:999999]");
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

float $t[3]=`xform -q -ws -t $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;
float $pos[3]=`xform -q -ws -t $sel[0]`;
select -r $geometry;
string $tempString[]=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
string $tempString[]=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]-$pos[0]) ($t[1]-$pos[1]) ($t[2]-$pos[2]) -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] $softModHandle;

if (`getAttr ($fitJoint+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			sets -add $softModSet $allFaceGeo[$i];
	}
select $softModHandle;
}

global proc string asFaceNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";
if ($nr==1) $letter="A";
if ($nr==2) $letter="B";
if ($nr==3) $letter="C";
if ($nr==4) $letter="D";
if ($nr==5) $letter="E";
if ($nr==6) $letter="F";
if ($nr==7) $letter="G";
if ($nr==8) $letter="H";
if ($nr==9) $letter="I";
return $letter;
}

global proc int asFaceLetterToNr (string $letter)
{
int $nr;
if ($letter=="") $nr=0;
if ($letter=="A") $nr=1;
if ($letter=="B") $nr=2;
if ($letter=="C") $nr=3;
if ($letter=="D") $nr=4;
if ($letter=="E") $nr=5;
if ($letter=="F") $nr=6;
if ($letter=="G") $nr=7;
if ($letter=="H") $nr=8;
if ($letter=="I") $nr=9;
return $nr;
}

global proc asChooseInput (string $textField)
{
int $confirmed;
float $tempFloat[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $txt,$dialog;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[];

if (!`gmatch $textField "*Joint*"`)
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType!="nurbsSurface" && $nodeType!="mesh")
				$sel=`stringArrayRemove {$sel[$i]} $sel`;		
			}
	}
select $restoreSel;

$txt=$sel[0];

if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];	

string $skinCluster;
//FaceGeometry validate
if ($textField=="asFaceGeometryTextField" && $sel[0]!="")
	{
	if (size($sel)>1)
		error "Face Geometry must be only 1 object";
	//Check zero xforms
/*
	$tempString=`ls -sl -l $sel[0]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempFloat=`xform -q -ws -t $tempString[$y]`;
		if ($tempFloat[0]!=0 || $tempFloat[1]!=0 || $tempFloat[2]!=0)
			error ($tempString[$y]+" Translate is not zero");
		$tempFloat=`xform -q -ws -piv $tempString[$y]`;
		if ($tempFloat[0]!=0 || $tempFloat[1]!=0 || $tempFloat[2]!=0)
			error ($tempString[$y]+" Pivot is not zero");
		}
*/
	$tempString=`listHistory $sel[0]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			$skinCluster=$tempString[$y];
			textField -e -tx $skinCluster asFaceSkinClusterTextField;
			}
	if ($skinCluster=="")
		{
		$dialog=`confirmDialog -t "Confirm"
		-m "No SkinCluster found on this geometry"
		-b "Create New SkinCluster" -db "Create New SkinCluster"
		-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			joint -n $headJoint;		
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $sel $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		select $sel;
		asChooseInput asFaceGeometryTextField;
		}
	}

//AllFaceGeo validate
if ($textField=="asFaceAllFaceGeoTextField" && $sel[0]!="")
	for ($i=0;$i<size($sel);$i++)
		{
		$tempString=`listRelatives -ni -s $sel[$i]`;
		if (!size($tempString))
			continue;
		if (!(`objectType $tempString[0]`=="mesh" || `objectType $tempString[0]`=="nurbsSurface"))
			continue;
		$tempString=`listHistory $sel[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
		if ($skinCluster=="")
			{
			if (!$confirmed)
				{
				$dialog=`confirmDialog -t "Confirm"
				-m "No SkinCluster found on some of the geometry"
				-b "Create New SkinClusters" -db "Create New SkinClusters"
				-b "Cancel" -ds "Cancel"`;
				if ($dialog!="Create New SkinClusters")
					return;
				}
			$confirmed=1;
			select -cl;
			if (!`objExists $headJoint`)
				joint -n $headJoint;
			select $sel[$i] $headJoint;
			$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
			}
		}

asFaceEnsureFitBase;

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc float asFaceGetScale ()
{
float $scale=1.5;
if (`objExists FaceFitSkeletonHeightShape`)
    {
    float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
    float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
    $scale=$pos1[1]-$pos2[1];
   	}
return $scale;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
asFaceEnsureFitBase;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFace"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFace"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

string $faceStep="BlendShapes";
string $pingPongJoints[]={"browMiddle","browInner","browHalf","browOuter","foreheadMiddle","foreheadOuter","noseMiddle"};
for ($i=0;$i<size($pingPongJoints);$i++)
	if ($name==$pingPongJoints[$i])
		$faceStep="PingPongs";
if ($name=="smile")
	$faceStep="Smile";
if (`gmatch $name "Lid*"`)
	$faceStep="Lid";

if (!`objExists ("FaceFit"+$faceStep)`)
	createNode -n ("FaceFit"+$faceStep) -p FaceFitSkeleton transform;

select ("FaceFit"+$faceStep);
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)
{
string $attrs[]={"Geometry","AllFaceGeo" ,"Eye_L","Eye_R","UpperTeeth","LowerTeeth","Tongue",
	"EyeBrow_L","EyeBrow_R","EyeLash_L","EyeLash_R","HeadJoint","SkinCluster"};
string $text;

for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFace"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		$text="";

		if ($attrs[$i]=="HeadJoint") $text="Head_M";
		if (`attributeExists $attrs[$i] FaceFitSkeleton`)
			$text=`getAttr ("FaceFitSkeleton."+$attrs[$i])`;
		textField -e -tx $text $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}
}

global proc asCreateFaceController (string $name, string $side, int $color)
{
float $scale=`asFaceGetScale`/5.0;
string $tempString[]=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/15.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
sets -add "FaceControlSet" ($name+$side);
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.castsShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.receiveShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.motionBlur");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.primaryVisibility");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.smoothShading");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInReflections");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInRefractions");
//disconnectAttr -na ($name+$side+"Shape.instObjGroups[0]") initialShadingGroup.dagSetMembers;
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Attach"+$side) transform;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
if ($color==6)
	parent ($name+"Attach"+$side) Acontrols;
if ($color==7 || $color==8)
	parent ($name+"Attach"+$side) Bcontrols;
if ($color==10)
	parent ($name+"Attach"+$side) Ccontrols;

if ($color==6)
	sets -e -forceElement asFaceBlueSG ($name+$side);
if ($color==7)
	sets -e -forceElement asFaceGreenSG ($name+$side);
if ($color==8)
	sets -e -forceElement asFaceCyanSG ($name+$side);
if ($color==10)
	sets -e -forceElement asFaceBrownSG ($name+$side);
}
	
global proc asPingPong (string $trnPos, string $name, int $b, string $side, int $color, int $createJoint, int $bindSkin)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`/3.0;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint="FaceAttachToHead";

float $pos[]=`xform -q -ws -t $trnPos`;

if (!`objExists ClusterSetup`)
	createNode -n ClusterSetup -p FaceMotionSystem transform;
if (!`objExists Brs`)
	{
	createNode -n Brs -p Bcontrols transform;
	orientConstraint -mo $headJoint Brs;
	scaleConstraint -mo $headJoint Brs;
	}

//Alternative attach position (e.g eyeLid)
float $attachPos[]=$pos;
string $altAttPosXform="";
int $nrUpperEyeInner,$nrLowerEyeInner;
for ($nrUpperEyeInner=1;$nrUpperEyeInner<99;$nrUpperEyeInner++) if (!`objExists ("upperEyeInner"+($nrUpperEyeInner+1))`) break;
for ($nrLowerEyeInner=1;$nrLowerEyeInner<99;$nrLowerEyeInner++) if (!`objExists ("lowerEyeInner"+($nrLowerEyeInner+1))`) break;
if ($name=="upperEye1")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/2);
if ($name=="lowerEye1")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/2);
if ($name=="upperEye2")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/4);	
if ($name=="lowerEye2")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/4);	
if ($name=="upperEye3")
	$altAttPosXform="upperEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
if ($name=="lowerEye3")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
//if ($name=="upperLip")
//	$altAttPosXform="upperEyeInner4";
if($altAttPosXform!="")
	{
	float $altAttachPos[]=`xform -q -ws -t $altAttPosXform`;
	$attachPos={$altAttachPos[0],$altAttachPos[1],$altAttachPos[2]};
	if ($side=="_L")
		$attachPos={$altAttachPos[0]*-1,$altAttachPos[1],$altAttachPos[2]};
	}

//Alternative control position (e.g lips)
float $controlPos[]=$pos;
string $altCtrlPosXform="";
int $nrUpperLipOuter,$nrLowerLipOuter;
for ($nrUpperLipOuter=1;$nrUpperLipOuter<99;$nrUpperLipOuter++) if (!`objExists ("upperLipOuter"+($nrUpperLipOuter+1))`) break;
for ($nrLowerLipOuter=1;$nrLowerLipOuter<99;$nrLowerLipOuter++) if (!`objExists ("lowerLipOuter"+($nrLowerLipOuter+1))`) break;
if ($name=="upperLip")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+"0";
if ($name=="lowerLip")
	$altCtrlPosXform="lowerLipMiddle"+`lipLetterClosestToCenterInY lower`+"0";
if ($name=="Lip")
	$altCtrlPosXform="lowerLipOuter"+$nrLowerLipOuter;
if ($name=="upperLipMid")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+($nrUpperLipOuter/2);
if($altCtrlPosXform!="" && `objExists $altCtrlPosXform`)
	{
	float $altControlPos[]=`xform -q -ws -t $altCtrlPosXform`;
	$controlPos=$altControlPos;
	$attachPos=$controlPos;
	}

//nurbsSphere controller
asCreateFaceController $name $side $color;
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Attach"+$side);

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	joint -n ($name+"Joint"+$side);
	createNode -n ($name+"JointOffset"+$side) transform;
	parent ($name+"Joint"+$side) ($name+"JointOffset"+$side);
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"JointOffset"+$side);
	parent ($name+"JointOffset"+$side) $headJoint;
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}


//Attach
string $tempString[]=`listRelatives -ni -s $geometry`;
if (!`objExists closestSampler`)
	createNode -n closestSampler closestPointOnMesh;
if (!`isConnected ($tempString[0]+".outMesh") closestSampler.inMesh`)
	connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
if (!`isConnected ($geometry+".worldMatrix[0]") closestSampler.inputMatrix`)
	connectAttr -f ($geometry+".worldMatrix[0]") closestSampler.inputMatrix;

setAttr -type float3 closestSampler.inPosition ($attachPos[0]*$b) $attachPos[1] $attachPos[2];
string $vtx=`getAttr closestSampler.result.closestVertexIndex`;
delete closestSampler;
select ($geometry+".vtx["+$vtx+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
select $edges[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
string $dupCurve=$tempString[0];
rename $dupCurve ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveEdge"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
parent ($name+"Curve"+$side) ClusterSetup;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
//determine PointOnCurveInfo.parameter
float $tempFloatA[]=`xform -q -ws -t ($name+$side)`;
float $tempFloatB[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
float $tempFloatC[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
connectAttr -f Brs.r ($name+"Attach"+$side+".r");
connectAttr -f Brs.s ($name+"Attach"+$side+".s");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

if ($createJoint)
	{
	connectAttr ($name+$side+".tx") ($name+"Joint"+$side+".tx");connectAttr ($name+$side+".ty") ($name+"Joint"+$side+".ty");connectAttr ($name+$side+".tz") ($name+"Joint"+$side+".tz");
	connectAttr ($name+$side+".rx") ($name+"Joint"+$side+".rx");connectAttr ($name+$side+".ry") ($name+"Joint"+$side+".ry");connectAttr ($name+$side+".rz") ($name+"Joint"+$side+".rz");
	connectAttr ($name+$side+".sx") ($name+"Joint"+$side+".sx");connectAttr ($name+$side+".sy") ($name+"Joint"+$side+".sy");connectAttr ($name+$side+".sz") ($name+"Joint"+$side+".sz");
	}
select -cl;
refresh;
}

global proc string lipLetterClosestToCenterInY (string $upperLower)
{
string $letter;
string $tempString[]=`ls -type joint ($upperLower+"LipMiddle*0_M")`;
string $closestJoint=$tempString[0];
float $minValue=999;
float $centerPos[]=`xform -q -ws -t ($upperLower+"LipCenter0_M")`;
for ($i=0;$i<size($tempString);$i++)
	{
	float $pos[]=`xform -q -ws -t $tempString[$i]`;
	float $absY=abs($centerPos[1]-$pos[1]);
	if ($absY<$minValue)
		{
		$minValue=$absY;
		$closestJoint=$tempString[$i];
		}
	}
$tempString[0]=`substitute ($upperLower+"LipMiddle") $closestJoint ""`;
$letter=`substitute "0_M" $tempString[0] ""`;
return $letter;
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
//string $jawJoint=`textField -q -tx asFaceJawJointTextField`;
string $jawControl="Jaw_M";
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

select $allFaceGeo;
float $scale=`asFaceGetScale`/3.0;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r $geometry;
string $tempString[]=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
string $tempString[]=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

asPingPong $name $name $b $side 8 0 0;
parent ($name+"Attach"+$side) Acontrols;

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			sets -add $softModSet $allFaceGeo[$i];
	}

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
//changed:trying to bring back -pruning
	dgdirty -a;
softMod -e -pr $softMod;
string $tempString[]=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

catch (`reorderDeformers $skinCluster $cluster $geometry`);
catch (`reorderDeformers asFaceBS $cluster $geometry`);
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
string $softMod=$tempString[0];

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+".vtx[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]vtx*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
    delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $multiply;
int $numVtxs[]=`polyEvaluate -v $geometry`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ($geometry+".vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select $geometry;
sets -add ($oppositeCluster+"Set") $geometry;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
createNode -n closestSampler closestPointOnMesh;
string $tempString[]=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".worldMatrix[0]") closestSampler.inputMatrix;
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 closestSampler.inPosition ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr closestSampler.result.closestVertexIndex`;
	$tempFloat=`percent -q -v $cluster ($geometry+".vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ($geometry+".vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete closestSampler;

eval ($restoreCmd);
}

global proc int [] asFaceSelVtxIntArray ()
{
int $intArray[];
string $tempString[];
string $sel[]=`ls -sl -fl`;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "[" $tempString;
	$intArray[$i]=`substitute "]" $tempString[1] ""`;
    	}
return $intArray;
}

global proc asFaceHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
columnLayout;
image -i ($asScriptLocation+"/AdvancedSkeleton4Files/div/images/faceHelp/"+$region+".jpg") asFaceHelpImage;
if (`gmatch $region "asBSWizardStep*"`)
	button -l "Toggle Default" -c asFaceTglDefault;
showWindow;
}

global proc asFaceTglDefault ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $curImage=`image -q -i asFaceHelpImage`;
string $ann=`image -q -ann asFaceHelpImage`;
if (!`gmatch $curImage "*asBSWizardStep*[0-9][.]*"`)
	return;
if ($ann=="")
	{
	image -e -ann $curImage asFaceHelpImage;
	image -e -i ($asScriptLocation+"/AdvancedSkeleton4Files/div/images/faceHelp/asBSWizardStep0.jpg") asFaceHelpImage;
	}
else
	{
	image -e -ann "" asFaceHelpImage;
	image -e -i $ann asFaceHelpImage;
	}
}

global proc asFaceSquintByLattice ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $dist;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[];
string $tempString[];
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	duplicate -rr -n ("eye_squint"+$side) $geometry;
	parent ("eye_squint"+$side) faceTargets;
	$tempString=`listRelatives -s ("eye_squint"+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];

	select ("eye_squint"+$side);
	$tempString=`lattice  -divisions 3 4 4 -objectCentered true  -ldv 2 2 2`;
	string $ffd=$tempString[0];
	string $lattice=$tempString[1];
	string $latticeBase=$tempString[2];

	$pos=`xform -q -ws -t FitEyeBall`;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $lattice;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $latticeBase;
	delete `scaleConstraint FitEyeBall $lattice`;
	delete `scaleConstraint FitEyeBall $latticeBase`;
	scale -r 2 2 2 $lattice;
	scale -r 2 2 2 $latticeBase;
	setAttr ($lattice+".sx") ($pos[0]*4*$b);
	setAttr ($latticeBase+".sx") ($pos[0]*4*$b);
 	select ($lattice+".pt[1:2][1:2][2]");
	scale -r -p $pos[0] $pos[1] $pos[2] 1 0.2 1 ;
	$pos=`xform -q -ws -t ($lattice+".pt[0][2][3]")`;
	$pos2=`xform -q -ws -t ($lattice+".pt[0][1][3]")`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	move -r 0 0 ($dist*0.2); 
	select ("eye_squint"+$side);
	DeleteHistory;
//	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ("eye_squint"+$side) 1 asFaceBS;
	}
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;

//pre post infinity
string $nodes[]=`listConnections -s 1 -d 0 -scn 1 $bs`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 4;
		setAttr ($nodes[$i]+".postInfinity") 4;
		}
	}
}

global proc float[] asGetMidHeadPos ()
{
float $midHeadPos[];
//first look for joints, as the fig might be from before faceFitScaleCurve came about
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
string $tempString[]=`listRelatives -c $headJoint`;
if(size($tempString))
	{
	$temp=`xform -q -ws -t $tempString[0]`;
	$midHeadPos[0]=(($headPos[0]+$temp[0])/2.0);
	$midHeadPos[1]=(($headPos[1]+$temp[1])/2.0);
	$midHeadPos[2]=(($headPos[2]+$temp[2])/2.0);
	}
if (`objExists FaceFitSkeletonHeightShape`)
	{
	float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
	float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
	$midHeadPos={$headPos[0],($pos1[1]+$pos2[1])/2.0,$headPos[2]};
	}

return $midHeadPos;
}

global proc asFaceCtrlBox ()
{
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
float $scale=`asFaceGetScale`/3.0;
float $temp[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $midHeadPos[]=`asGetMidHeadPos`;
float $boxTZ=($midHeadPos[2]+($scale*1.3));
if (`objExists FitEyeBall`)
	{
	$temp=`xform -q -ws -t FitEyeBall`;
	$boxTZ=$temp[2];
	}

setAttr FaceFitSkeletonShape.v 0;
setAttr FaceFitSkeletonHeightShape.v 0;

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionSystem;
parentConstraint -mo $headJoint ctrlBoxOffset;
scaleConstraint -mo $headJoint ctrlBoxOffset;
addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;
setAttr ctrlBoxShape.overrideEnabled 1;
setAttr ctrlBoxShape.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -ws -t ($scale*1.8) ($midHeadPos[1]-(0.3*$scale)) $boxTZ ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;
scale -r 2 2 2 ctrlBoxMouth_M;
asFaceCreateCtrlBox "Tongue_M" 0 ($scale*-1.3) 2;
setAttr "ctrlBoxTongue_MShape.overrideVisibility" 0;
setAttr -l 1 -k 0 ctrlTongue_M.tx;
setAttr -l 1 -k 0 ctrlTongue_M.ty;

string $ctrls[]=`listRelatives -type transform -c ctrlBox`;
for ($i=0;$i<size($ctrls);$i++)
	setAttr ($ctrls[$i]+".v") 0;

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.ACtrlVis Acontrols.v;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.BCtrlVis Bcontrols.v;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.CCtrlVis Ccontrols.v;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.AimCtrlVis Aimcontrols.v;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RenderSpheres" -at bool -dv true ctrlBox;

delete ctrlBoxTemplate;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asKeepBlendShapes ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;

createNode -n keepTweakedBlendShapes transform;
setAttr keepTweakedBlendShapes.v 0;
string $udas[]=`listAttr -ud FaceFitSkeleton`;
string $keepShps[];
for ($i=0;$i<size($udas);$i++)
	{
	if (`gmatch $udas[$i] "*_tweaked"`)
		if (`getAttr ("FaceFitSkeleton."+$udas[$i])`)
			$keepShps[size($keepShps)]=`substitute "_tweaked" $udas[$i] ""`;
	}
for ($i=0;$i<size($keepShps);$i++)
	{
	setAttr ("asFaceBS."+$keepShps[$i]) 1;
	duplicate -n ($keepShps[$i]+"_tweaked") $geometry;
	parent ($keepShps[$i]+"_tweaked") keepTweakedBlendShapes;
	setAttr ("asFaceBS."+$keepShps[$i]) 0;
	}
}

global proc asBuildFitEyeBall ()
{
string $righEyeGeoText=`textField -q -tx asFaceEye_RTextField`;
if ($righEyeGeoText=="")
	error "No Eye Geometry choosen";
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint:\""+$headJoint+"\" not found");
asFitModeEnsureShaders;
spaceLocator -n FitEyeBall;
setAttr FitEyeBall.rotateOrder 2;
setAttr -type float3 FitEyeBallShape.localScale 1.5 1.5 1.5;
createNode -n FaceFitEyeBall -p FaceFitSkeleton transform;
parent FitEyeBall FaceFitEyeBall;
polySphere -n FitEyeSphere -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr FitEyeSphere.overrideEnabled 1;
setAttr FitEyeSphere.overrideDisplayType 2;
parent FitEyeSphere FitEyeBall;
setAttr FitEyeSphere.rx 90;
setAttr -type float3 FitEyeBall.s (0.05*$height) (0.05*$height) (0.05*$height);
float $pos[]=`xform -q -ws -t $headJoint`;
setAttr -type float3 FitEyeBall.t (-0.05*$height) ($pos[1]*1.05) (0.05*$height);
sets -e -forceElement asWhiteSG FitEyeSphere;
sets -e -forceElement asBlackSG FitEyeSphere.f[56:63];

//guestimate placement (and scale) based upon 1st selected geo
string $tempString[],$tempString2[],$eyeGeos[];
tokenize $righEyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	CenterPivot;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w FitEyeBall;
		xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) FitEyeBall;
		parent FitEyeBall FaceFitEyeBall;
		}
	}
/*
select FitEye;
print ("// FitEye created, place this to match the eye-ball of your character\n");
*/
checkBox -e -ed 1 -v 1 asFaceEyeBall;
}

global proc asConnectTongueControl ()
{
string $tempString[];
string $axis,$connectTo;
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	for ($y=1;$y<4;$y++)
		{
		if (!`attributeExists ("rot"+$axis+$y) ctrlTongue_M`)
			addAttr -ln ("rot"+$axis+$y) -k 1 ctrlTongue_M;
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.r"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.rot"+$axis+$y) $connectTo;
		}
	}
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	if (!`attributeExists ("size"+$axis) ctrlTongue_M`)
		addAttr -ln ("size"+$axis) -dv 1 -k 1 ctrlTongue_M;
	for ($y=1;$y<4;$y++)
		{
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.s"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.size"+$axis) ($connectTo);
		}
	}

/*
//pre post infinity
select `listRelatives -type transform -c ctrlBox`;
select `listRelatives -type transform -c`;
string $nodes[]=`listConnections -s 0 -d 1 `;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 1;
		setAttr ($nodes[$i]+".postInfinity") 1;
        $tempFloat=`keyframe -q -fc $nodes[$i]`;
        if ($tempFloat[0]==0.0)
		    setAttr ($nodes[$i]+".preInfinity") 0;
		if ($tempFloat[size($tempFloat)-1]==0.0)
		    setAttr ($nodes[$i]+".postInfinity") 0;
		}
	}
*/
select -cl;
}

global proc asFaceEnsureFitBase ()
{
if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
}

global proc asFaceEnsureAdvancedBase ()
{
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

//enable the GoTOBuildPose for Face button, part 1
int $hadFaceSetup=`objExists FaceMotionSystem`;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
createNode -n FaceDeformationSystem -p FaceGroup transform;
createNode -n ControlsSetup -p FaceMotionSystem transform;
createNode -n Acontrols transform;
createNode -n Bcontrols transform;
createNode -n Ccontrols transform;
createNode -n Aimcontrols transform;
parent Acontrols Bcontrols Ccontrols Aimcontrols ControlsSetup;

select FaceDeformationSystem;
joint -n FaceAttachToHead;
setAttr -l 1 FaceAttachToHead.v 0;
asAlign FaceAttachToHead $headJoint 1 0 0 0;
setAttr -type float3 FaceAttachToHead.jointOrient 90 0 90;
parentConstraint -mo $headJoint FaceAttachToHead;
scaleConstraint $headJoint FaceAttachToHead;
skinCluster -e -ai FaceAttachToHead -lw false -wt 0 $skinCluster;

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	}

//Shaders
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan"};
float $rs[]={0.0,0.541,0.000,0.0};
float $gs[]={0.0,0.282,0.275,0.5};
float $bs[]={1.0,0.200,0.098,0.5};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}

//enable the GoTOBuildPose for Face button, part 2
if (!$hadFaceSetup)
	AdvancedSkeleton4;

asFaceCtrlBox;
select $sel;
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;

//squashHead
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceMotionSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap")
			select -d $allFaceGeo[$i];
	}

$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
float $pos[3];
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;
createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;
connectAttr squashIKCurveInfoNormalize.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr FaceAttachToHead.sx squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
parent squashIKX1 FaceAttachToHead;
parent SquashControls ControlsSetup;
parentConstraint -mo $headJoint SquashControls;
scaleConstraint $headJoint SquashControls;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;

//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis SquashControls.v;
asUpdateAllSet $allBefore;
select squashTop_M;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

string $allHeadJoints[]=`listRelatives -ad -type joint FaceDeformationSystem`;
$tempString=`listRelatives -ad -type joint $headJoint`;
$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
sets -rm squashFfdSet `ls -sl`;
InvertSelection;
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}

//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeleton4Files")
			break;
		else
			{
			if ($i>0)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton4.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asCheckForUpdates ()
{
if (!`about -win`)
	error "This is only avaiable in Windows. For updates, go to: www.animationstudios.com.au/advancedskeleton/downloads";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton4Files/bin/curl.e";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton4Files/bin/curl.e";
if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeletonBeta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton4/latestVersion.txt")`;
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton4.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton4.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
float $newVersion=$newVersionAsString;
if ($newVersion>4.06)
	asUpdateVersion2;
else
	asUpdateVersion1;
}

global proc asUpdateVersion1 ()
{
waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton4.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton4Files/bin/curl.exe";
string $zip=$sLoc+"/AdvancedSkeleton4Files/bin/7za.exe";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton4Files/newVersions";
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton_v"+$newVersionAsString+".zip";
string $newVersionExtractedFolder=$newVersionFolder+"/AdvancedSkeleton_v"+$newVersionAsString;
string $zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton4/AdvancedSkeleton_v"+$newVersionAsString+".zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeletonBeta/AdvancedSkeleton_v"+$newVersionAsString+".zip";
string $cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
print ("// Starting Download:"+$cmd+";\n");
system ($cmd);
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);
//confirm unzip
if (`file -q -ex $newVersionExtractedFolder`)
	print ("// Unzipped sucessfully:"+$newVersionExtractedFolder+";\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionExtractedFolder+";\n");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton4Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton4Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton4Files") ($sLoc+"/AdvancedSkeleton4Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton4.mel") ($sLoc+"/AdvancedSkeleton4.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+"/AdvancedSkeleton_v"+$newVersionAsString+"\";\n");
asCopyFilesInFolder $sLoc ($newVersionFolder+"/AdvancedSkeleton_v"+$newVersionAsString);
waitCursor -st 0;
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton4.mel\";AdvancedSkeleton4;");
}

global proc asUpdateVersion2 ()
{
waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton4.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton4Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton4Files/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton4Files/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton4.zip";
//string $newVersionExtractedFolder=$newVersionFolder+"/AdvancedSkeleton4";
string $zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton4/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton4.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeletonBeta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton4.zip";
string $cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
print ("// Starting Download:"+$cmd+";\n");
system ($cmd);
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);
//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton4.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton4.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton4.mel;\n");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton4Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton4Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton4Files") ($sLoc+"/AdvancedSkeleton4Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton4.mel") ($sLoc+"/AdvancedSkeleton4.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton4.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton4.zip");
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton4.mel\";AdvancedSkeleton4;");
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="distributes" || `gmatch $fileList[$i] "[.]*"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel")
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file, possible privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"https://db.tt/xGk7E5xU\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	{
	deleteUI -control AdvancedSkeletonDockControl;
	AdvancedSkeleton4;
	}
else if ($dock)
	dockControl -w 296 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
}

global proc asFitSkeletonImport ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeHierarchy;
string $dialog;
string $markers[]=`asGetMarkersSorted`;
if (size($markers))
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "Replace FitSkeleton ?"
		-b "OK" -db "OK"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	}
if ($asFitModeHierarchy)
	asOffFitMode;

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2"};
for ($i=0;$i<size($removeExistingObjs);$i++)
	if (`objExists $removeExistingObjs[$i]`)
		delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton4Files/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
if (`optionMenu -q -ex asAxisLenght` && `attributeExists axisLenght FitSkeleton`)
	optionMenu -e -sl (`getAttr FitSkeleton.axisLenght`+1) asAxisLenght;
asFitSkeletonConnectControl;

/*
string $markers[]=`asGetMarkers`;
for ($i=0;$i<size($markers);$i++)
	asEnsureLimbLocAttrs $markers[$i];
*/

//Rebuild FitSkeleton(as the saved template might not have the latest options)
if (`objExists Visualizers`)
	delete Visualizers;

asEnsureFitBaseStruct;
asEnsureFitSystems;

if ($asFitModeScriptJob1Nr==0)
	asToggleFitMode;
else // ensure renewal of script attached to .trigger attr
	{
	asToggleFitMode;
	asToggleFitMode;
	}
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;

}

global proc asReferenceModelBrowser ()
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
string $topNodesBefore[]=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;
string $topNodesAfter[]=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

//Hi layer
if (`objExists Hi`)
	{
	if(`objectType Hi`=="displayLayer")
		editDisplayLayerMembers -noRecurse Hi `ls -selection`;
	}
else
	{
	createDisplayLayer -name Hi -number 1 -nr;
	setAttr Hi.displayType 1;
	}
select -cl;
}

global proc asFitChangeAxis ()
{
if (!`objExists FitSkeleton`)
	return;
int $lenghtOptionNr=`optionMenu -q -sl asAxisLenght`;
int $frontOptionNr=`optionMenu -q -sl asAxisFront`;
if ($frontOptionNr==$lenghtOptionNr)
	{
	warning "Can not have same Lenght axis and Front axis";
	if ($frontOptionNr<3)
		$frontOptionNr++;
	else
		$frontOptionNr=1;
	optionMenu -e -sl $frontOptionNr asAxisFront;
	}
int $previousLenghtAxis=`getAttr FitSkeleton.axisLenght`;
int $previousFrontAxis=`getAttr FitSkeleton.axisFront`;
setAttr FitSkeleton.axisLenght ($lenghtOptionNr-1);
setAttr FitSkeleton.axisFront ($frontOptionNr-1);
optionVar -iv asLenghtAxis $lenghtOptionNr;
optionVar -iv asFrontAxis $frontOptionNr;
string $restoreScaleCmd;
string $markers[]=`asGetMarkers`;
for ($i=0;$i<size($markers);$i++)
	{
	float $scale[]=`getAttr ($markers[$i]+".s")`;
	float $cs[]=`asConvertScaleAxis $scale $previousLenghtAxis $previousFrontAxis`;
	$restoreScaleCmd+="xform -os -s "+$cs[0]+" "+$cs[1]+" "+$cs[2]+" "+$markers[$i]+";";
	}
asFitRebuild;
eval ($restoreScaleCmd);
}

global proc asFitRebuild ()
{
if (!`objExists Visualizers`)
	return;
//delete all *aim, to trigger rebuild
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
string $restoreRLAcmd;
for ($i=0;$i<size($visualizers);$i++)
	if (`gmatch $visualizers[$i] "*Aim"`)
		{
		if (`getAttr ($visualizers[$i]+".displayLocalAxis")`)
			$restoreRLAcmd+="setAttr "+$visualizers[$i]+".displayLocalAxis 1;";
		delete $visualizers[$i];
//		refresh;
		}
asFitModeSelectionChanged;
if ($restoreRLAcmd!="")
	eval($restoreRLAcmd);
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
int $onOff,$setOnOff;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
duplicate -n FitSkeletonHeight FitSkeleton;
parent FitSkeletonHeight FitSkeleton;
parent -add -s FitSkeletonHeightShape FitSkeleton;
delete FitSkeletonHeight;
move -r 0 10 0 FitSkeletonHeightShape.cv[0:7];
addAttr -k 1 -ln "axisLenght" -at "enum" -en "x:y:z:" FitSkeleton;
addAttr -k 1 -ln "axisFront" -at "enum" -en "x:y:z:" FitSkeleton;
setAttr FitSkeleton.axisFront 1;
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;
addAttr -k 1 -ln "visGeoType" -at "enum" -en "cylinders:boxes" FitSkeleton;
addAttr -k 0 -ln "visCylinders" -at bool FitSkeleton;
addAttr -k 0 -ln "visBoxes" -at bool FitSkeleton;
createNode -n FitSkeletonVisGeoTypeReverse reverse;
connectAttr FitSkeleton.visGeoType FitSkeletonVisGeoTypeReverse.inputX;
connectAttr FitSkeletonVisGeoTypeReverse.outputX FitSkeleton.visCylinders;
connectAttr FitSkeleton.visGeoType FitSkeleton.visBoxes;

addAttr -k 1 -ln "visGap" -at double -dv $gap -min 0 -max 1 FitSkeleton;
addAttr -k 1 -ln "visLocators" -at bool -dv $gap FitSkeleton;
addAttr -k 1 -ln "visGeo" -at bool -dv 1 FitSkeleton;
addAttr -k 1 -ln "visDirections" -at bool -dv 0 FitSkeleton;
addAttr -k 1 -ln "visDirectionFront" -at bool -dv 0 FitSkeleton;
addAttr -k 0 -ln "trigger" -at double -dv 0 FitSkeleton;
createNode -n triggerPlusMinusAverage plusMinusAverage;
//setAttr triggerPlusMinusAverage.input1D[0] 1;
connectAttr FitSkeletonShape.overrideEnabled triggerPlusMinusAverage.input1D[0];
connectAttr triggerPlusMinusAverage.output1D FitSkeleton.trigger;
connectAttr triggerPlusMinusAverage.output1D FitSkeletonShape.overrideVisibility;
addAttr -k 0 -ln poleX -at double -dv 0 FitSkeleton;
addAttr -k 0 -ln poleY -at double -dv 5 FitSkeleton;
addAttr -k 0 -ln poleZ -at double -dv 6 FitSkeleton;

asFitSkeletonConnectControl;

asEnsureFitBaseStruct;
select FitSkeleton;
}

global proc asEnsureFitBaseStruct ()
{
global int $asFitModeScriptJob1Nr;
$scale=`getAttr FitSkeleton.sx`;
if (!`objExists Markers`)
	createNode -n Markers -p FitSkeleton transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeleton transform;
if (!`objExists Visualizers`)
	createNode -n Visualizers -p FitSkeleton transform;
if (!`objExists Aims`)
	createNode -n Aims -p Visualizers transform;
if (!`objExists Directions`)
	createNode -n Directions -p Visualizers transform;
if (!`objExists Surfaces`)
	createNode -n Surfaces -p Visualizers transform;

if (!`objExists DirectionFront`)
	{
	spaceLocator -n DirectionFront;
	parent DirectionFront Directions;
	setAttr -type float3 DirectionFront.s 1 1 1;
	setAttr DirectionFrontShape.overrideEnabled 1;
	setAttr DirectionFrontShape.overrideColor 13;
	connectAttr FitSkeleton.visDirectionFront DirectionFront.v;
	setAttr -type float3 DirectionFront.t `getAttr FitSkeleton.poleX` `getAttr FitSkeleton.poleY` `getAttr FitSkeleton.poleZ`;
//	xform -ws -t (`getAttr FitSkeleton.poleX`*$scale) (`getAttr FitSkeleton.poleY`*$scale) (`getAttr FitSkeleton.poleZ`*$scale) DirectionFront;
//	xform -ws -t `getAttr FitSkeleton.poleX` `getAttr FitSkeleton.poleY` `getAttr FitSkeleton.poleZ` DirectionFront;
	setAttr -l 1 DirectionFront.tx;
	setAttr -k 0 DirectionFront.rx;
	setAttr -k 0 DirectionFront.ry;
	setAttr -k 0 DirectionFront.rz;
	connectAttr -f DirectionFront.worldPosition[0].worldPositionX FitSkeleton.poleX;
	connectAttr -f DirectionFront.worldPosition[0].worldPositionY FitSkeleton.poleY;
	connectAttr -f DirectionFront.worldPosition[0].worldPositionZ FitSkeleton.poleZ;
	}
}

global proc asEnsureFitSystems ()
{
if (!`objExists Systems`)
	return;
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	asEnsureSystem $systems[$i];
}

global proc asFitSkeletonConnectControl ()
{
if (!`objExists FitSkeleton`)
	return;

if(`attributeExists visLocators FitSkeleton`)
	connectControl asVisLocators FitSkeleton.visLocators;
if(`attributeExists visGeo FitSkeleton`)
	connectControl asVisGeo FitSkeleton.visGeo;
if(`attributeExists visGeoType FitSkeleton`)
	connectControl asVisGeoType FitSkeleton.visGeoType;
if(`attributeExists visGap FitSkeleton`)
	connectControl asVisGap FitSkeleton.visGap;
if(`attributeExists visDirections FitSkeleton`)
	connectControl asVisDirections FitSkeleton.visDirections;
if(`attributeExists visDirectionFront FitSkeleton`)
	connectControl asVisDirectionFront FitSkeleton.visDirectionFront;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc string asCreateLimbLoc (string $name, float $pos[], float $scale[],int $rotateOrder)
{
global int $asFitModeHierarchy;
int $isScapula;
if ($name=="Scapula")
	$isScapula=1;
string $tempString[];
//if ($name=="Basic")
//	$name="Basic1";
if (`objExists $name`)
	{
	for ($i=1;$i<999;$i++)
		if (!`objExists ($name+$i)`)
			break;
	$name=($name+$i);
	}

$tempString=`spaceLocator -n $name`;
$tempString=`parent ("|"+$tempString[0]) Markers`;
$name=$tempString[0];

setAttr -type float3 ($name+".s") $scale[0] $scale[1] $scale[2];
setAttr -type float3 ($name+"Shape.localScale") 0 1.5 1.5;
connectAttr FitSkeleton.visLocators ($name+"Shape.v");
setAttr ($name+".t") $pos[0] $pos[1] $pos[2];
if ($isScapula)
	{
	setAttr ($name+"Shape.overrideEnabled") 1;
	setAttr ($name+"Shape.overrideColor") 17;
	}

if (!$asFitModeHierarchy)
	{
	setAttr -k 0 ($name+".rx");
	setAttr -k 0 ($name+".ry");
	setAttr -k 0 ($name+".rz");
	}
setAttr ($name+".rotateOrder") $rotateOrder;

asEnsureLimbLocAttrs $name;
return $name;
}

global proc asEnsureLimbLocAttrs (string $name)
{
if (!`gmatch $name "*End*"`)
	{
	if (!`attributeExists twists $name`)
		{
		addAttr -k 1 -ln twists -at long -min 0 -max 10 $name;
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($name+".twists") triggerPlusMinusAverage.input1D[$na];
		}
	if (!`attributeExists bendCtrls $name`)
		addAttr -k 1 -ln bendCtrls -at bool $name;
	setAttr -l 1 ($name+".bendCtrls");
	if (!`attributeExists "global" $name`)
		addAttr -k 1 -ln "global" -at bool $name;
	if (!`attributeExists child $name`)
		addAttr -ln child -at "message" $name;
	}
if (!`attributeExists otherChildren $name`)
	addAttr -m -indexMatters 0 -ln otherChildren -at "message" $name;
if (!`attributeExists worldUpObject $name`)
	addAttr -ln worldUpObject -at "message" $name;
if (!`attributeExists noMirror $name`)
	addAttr -ln noMirror -at bool $name;
if (!`attributeExists rot $name`)
	{
	addAttr  -k 0 -ln rot -numberOfChildren 3 -at double3 $name;
	addAttr  -p rot -ln rotX -at doubleAngle $name;
	addAttr  -p rot -ln rotY -at doubleAngle $name;
	addAttr  -p rot -ln rotZ -at doubleAngle $name;
	}
}

global proc asEnsureConnectAttr (string $source, string $destination)
{
if (!`isConnected $source $destination`)
	connectAttr -f $source $destination;
}

global proc float[] asConvertScaleAxis (float $s[], int $previousLenghtAxis, int $previousFrontAxis)
{
//Scale always spesified in XdownYup, so convert for other variations
float $cs[]=$s;
int $lenghtAxisNr=`getAttr FitSkeleton.axisLenght`;
int $frontAxisNr=`getAttr FitSkeleton.axisFront`;
if ($previousLenghtAxis==0 && $previousFrontAxis==1)
{
//if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[0];$cs[1]=$s[1];$cs[2]=$s[2];}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
}
if ($previousLenghtAxis==0 && $previousFrontAxis==2)
{
if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
//if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[0];$cs[1]=$s[1];$cs[2]=$s[2];}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
}
if ($previousLenghtAxis==1 && $previousFrontAxis==0)
{
if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
//if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[1];}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
}
if ($previousLenghtAxis==1 && $previousFrontAxis==2)
{
if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
//if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[0];$cs[1]=$s[1];$cs[2]=$s[2];}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
}
if ($previousLenghtAxis==2 && $previousFrontAxis==0)
{
if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
//if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[0];$cs[1]=$s[1];$cs[2]=$s[2];}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
}
if ($previousLenghtAxis==2 && $previousFrontAxis==1)
{
if ($lenghtAxisNr==0 && $frontAxisNr==1){$cs[0]=$s[2];$cs[1]=$s[1];$cs[2]=$s[0];}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$cs[0]=$s[2];$cs[1]=$s[0];$cs[2]=$s[1];}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$cs[0]=$s[1];$cs[1]=$s[2];$cs[2]=$s[0];}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$cs[0]=$s[0];$cs[1]=$s[2];$cs[2]=$s[1];}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$cs[0]=$s[1];$cs[1]=$s[0];$cs[2]=$s[2];}
//if ($lenghtAxisNr==2 && $frontAxisNr==1){$cs[0]=$s[0];$cs[1]=$s[1];$cs[2]=$s[2];}
}
return $cs;
}

global proc asCreateRootLimb ()
{
string $limbType="Basic";
$sl=`asGetLimbLetter $limbType`;
string $locs[];
$locs[0]=`asCreateLimbLoc Root {0.0,5.0,0.0} {1,1,1} 0`;
$locs[1]=`asCreateLimbLoc ($locs[0]+"End") {0.0,7.0,0.0} {1,1,1} 0`;
setAttr -l 1 ($locs[0]+".tx");
setAttr -l 1 ($locs[1]+".tx");

//child connect
connectAttr ($locs[1]+".message") ($locs[0]+".child");

//system connect
$system=`asCreateSystem "Basic" $sl`;
connectAttr ($locs[0]+".message") ($system+".start");
connectAttr ($locs[0]+".message") ($system+".mid");
connectAttr ($locs[1]+".message") ($system+".end");
connectAttr ($locs[1]+".message") ($system+".endEnd");

asEnsureSystem $system;
}

global proc asCreateLimb ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeHierarchy;
string $sel[]=`ls -sl`;

if ($asFitModeScriptJob1Nr==0)
	asToggleFitMode;

if ($asFitModeHierarchy)//For now, just exit HierarchyMode, as we dont know how to preserve this ..yet
	asToggleFitModeHierarchy;

float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
int $middle=`checkBox -q -v asLimbMiddle`;
string $limbType=`optionMenu -q -v asLimbType`;
if (!`objExists FitSkeleton`)
	asCreateFitSkeleton;
string $markers[]=`asGetMarkers`;
string $locs[],$segmentLocs[],$tempString[];
int $isExtendingParent,$systemNr;
float $x;
float $pos[],$posA[],$posB[],$sca[],$parentPos[],$pos2[];
string $parent,$parentSystem,$parentSystemType,$cmd,$system,$sl;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*End*"`)
		$sel[$i]=`substitute "End" $sel[$i] ""`;
	$tempString=`listRelatives -s $sel[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="locator")
			{
			$parent=$sel[$i];
			$parentPos=`getAttr ($parent+".t")`;
			$parentPos[0]=`asRoundOff $parentPos[0] 3`;
			$tempString=`listConnections -s 0 -d 1 ($sel[$i]+".message")`;
			for ($y=0;$y<size($tempString);$y++)
				if(`gmatch $tempString[$y] "*System*"`)
					{
					$parentSystem=$tempString[$y];
					$parentSystemType=`getAttr ($parentSystem+".type")`;
					}
			}
	}

string $worldUpObject="DirectionFront";

if (!$middle)
	$x=-1;

int $sameSideAsParent=1;
if ($middle && $parentPos[0]<$sideTreshold*-1)
	$sameSideAsParent=0;
if (!$middle && $parentPos[0]>$sideTreshold*-1)
	$sameSideAsParent=0;
if (!$sameSideAsParent)
	{
//	$parent="";
	$parentSystem="";
	}

int $isCreatingMiddleRoot=0;
if ($limbType=="Basic" || $limbType=="Spine")
	if ($middle)
		$isCreatingMiddleRoot=1;
if (!`objExists Root` && !$isCreatingMiddleRoot)
	asCreateRootLimb;

if ($limbType=="Basic")
	{
	$sl=`asGetLimbLetter $limbType`;
	if (!`objExists Root` && $middle)
		$name="Root";
	else
		{
		if ($parentSystem!="" && $sameSideAsParent)
			{
			$name="Basic";
			if ($parent=="Root")
				$name="Basic1";
			}
		else
			$name="Basic"+$sl;
		}

	$locs[0]=`asCreateLimbLoc $name {$x,5.0,0.0} {1,1,1} 0`;
	if ($middle)
		$locs[1]=`asCreateLimbLoc ($locs[0]+"End") {$x,7.0,0.0} {1,1,1} 0`;
	else
		$locs[1]=`asCreateLimbLoc ($locs[0]+"End") {$x-2,5.0,0.0} {1,1,1} 0`;

	//child connect
	connectAttr ($locs[1]+".message") ($locs[0]+".child");
	//Are we extending a basicSystem, or appending a basic branching out someWhere e.g. toe
	if ($parent!="")
		{
		//extending a basicSystem
		if (`objExists ($parent+"End")` && $sameSideAsParent && $parentSystemType=="Basic")
			{
			connectAttr -f ($locs[0]+".message") ($parent+".child");
			$pos=`getAttr ($parent+"End.t")`;
			$sca=`getAttr ($parent+"End.s")`;
			$isExtendingParent=1;
			}
		//appending a basic branching out someWhere e.g. toe
		else
			{
			connectAttr -na ($locs[0]+".message") ($parent+".otherChildren");
			$pos=`getAttr ($parent+".t")`;
			//cant be in same spot
			if ($middle)
				$pos[1]=$pos[1]+($scale*0.1);
			else
				$pos[0]=$pos[0]+($scale*-0.1);
			$sca=`getAttr ($parent+".s")`;
			$sca[0]*=0.5;
			}

		setAttr -type float3 ($locs[0]+".t") $pos[0] $pos[1] $pos[2];
		setAttr -type float3 ($locs[0]+".s") $sca[0] $sca[0] $sca[0];
		setAttr -type float3 ($locs[0]+"End.s") $sca[0] $sca[0] $sca[0];
		asStraightEndLoc $locs[0] 1;
		}

	if ($parentSystem!="" && $sameSideAsParent && $parentSystemType=="Basic") 
		{
		connectAttr -f ($locs[0]+".message") ($parentSystem+".end");
		connectAttr -f ($locs[1]+".message") ($parentSystem+".endEnd");
		if ($middle)
			connectAttr DirectionFront.message ($locs[0]+".worldUpObject");
		else
			connectAttr ("Direction"+$parentSystem+".message") ($locs[0]+".worldUpObject");
		asEnsureSystem $parentSystem;
		}
	else
		{
		$system=`asCreateSystem "Basic" $sl`;
		connectAttr ($locs[0]+".message") ($system+".start");
		connectAttr ($locs[0]+".message") ($system+".mid");
		connectAttr ($locs[1]+".message") ($system+".end");
		connectAttr ($locs[1]+".message") ($system+".endEnd");

		asEnsureSystem $system;
		$segmentLocs=`asFitModeNumLocChanged`;//Creates the segmentLocs
		$locs=`stringArrayCatenate $locs $segmentLocs`;
		}
	}
else if ($limbType=="Spine")
	{	
	$sl=`asGetLimbLetter $limbType`;
	if ($middle)
		{
		if (`objExists Root` && !`objExists Chest`) //Delete exisiting `standin root`
			delete Root;

		$locs[0]=`asCreateLimbLoc ("Root"+$sl) {0.0,5.0,0.0} {1.0,0.73,1} 0`;
		$locs[1]=`asCreateLimbLoc ("Spine1"+$sl) {0.0,6.0,0.0} {0.73,0.63,0.73} 0`;
		$locs[2]=`asCreateLimbLoc ("Chest"+$sl) {0.0,7.0,0.0} {0.75,0.78,0.75} 0`;
		$locs[3]=`asCreateLimbLoc ("Chest"+$sl+"End") {0.0,8.0,0.0} {0.92,0.78,0.92} 0`;
		}
	else
		{
		$locs[0]=`asCreateLimbLoc ("Root"+$sl) {$x,5.0,0.0} {1,1,1} 0`;
		$locs[1]=`asCreateLimbLoc ("Spine1"+$sl) {$x-1,5.0,0.0} {1,1,1} 0`;
		$locs[2]=`asCreateLimbLoc ("Chest"+$sl) {$x-2,5.0,0.0} {1,1,1} 0`;
		$locs[3]=`asCreateLimbLoc ("Chest"+$sl+"End") {$x-3,5.0,0.0} {1,1,1} 0`;
		}

	//child connect
	connectAttr ($locs[3]+".message") ($locs[2]+".child");
	connectAttr ($locs[2]+".message") ($locs[1]+".child");
	connectAttr ($locs[1]+".message") ($locs[0]+".child");

	//system connect
	$system=`asCreateSystem "Spine" $sl`;
	connectAttr ($locs[0]+".message") ($system+".start");
	connectAttr ($locs[1]+".message") ($system+".mid");
	connectAttr ($locs[2]+".message") ($system+".end");
	connectAttr ($locs[3]+".message") ($system+".endEnd");

	asStraightEndLoc $locs[2] 1;

	asEnsureSystem $system;
	$segmentLocs=`asFitModeNumLocChanged`;//Creates the segmentLocs
	$locs=`stringArrayCatenate $locs $segmentLocs`;
	}
else if ($limbType=="Neck")
	{
	$sl=`asGetLimbLetter $limbType`;
	$locs[0]=`asCreateLimbLoc ("Neck"+$sl) {$x,8.3,0.0} {0.4,0.3,0.4} 0`;
	$locs[1]=`asCreateLimbLoc ("Head"+$sl) {$x,8.9,0.0} {0.3,0.3,0.3} 0`;
	$locs[2]=`asCreateLimbLoc ("Head"+$sl+"End") {$x,10.0,0.0} {0.3,0.3,0.3} 0`;

	//hide HeadEnd, and make it follow Neck
	setAttr -l 1 ($locs[2]+".v") 0;
	createNode -n ("HeadEndPlusMinusAverage"+$sl) plusMinusAverage;
	connectAttr ($locs[1]+".t") ("HeadEndPlusMinusAverage"+$sl+".input3D[1]");
	setAttr ("HeadEndPlusMinusAverage"+$sl+".input3D[0].input3Dy") 1;
	connectAttr -f ("HeadEndPlusMinusAverage"+$sl+".output3D") ($locs[2]+".t");

	//child connect
	connectAttr ($locs[1]+".message") ($locs[0]+".child");
	connectAttr ($locs[2]+".message") ($locs[1]+".child");
	if (`objExists Chest`)
		connectAttr -na ($locs[0]+".message") Chest.otherChildren;

	//system connect
	$system=`asCreateSystem Neck $sl`;
	connectAttr ($locs[0]+".message") ($system+".start");
	connectAttr ($locs[1]+".message") ($system+".mid");
	connectAttr ($locs[2]+".message") ($system+".end");

	setAttr ($locs[0]+".twists") 2;
	setAttr -l 0 ($locs[0]+".bendCtrls");

	asEnsureSystem $system;
	}
else if ($limbType=="Leg")
	{
	$systemNr=`asGetLimbNr $limbType`;
	$sl=`asGetLimbLetter $limbType`;
	$locs[0]=`asCreateLimbLoc ("Hip"+$sl) {$x*0.5,5.15,$systemNr} {0.5,0.5,0.5} 2`;
	$locs[1]=`asCreateLimbLoc ("Knee"+$sl) {$x*0.5,2.8,0.1+$systemNr} {0.3,0.3,0.3} 2`;
	$locs[2]=`asCreateLimbLoc ("Ankle"+$sl) {$x*0.5,0.5,$systemNr} {0.2,0.2,0.2} 2`;
	$locs[3]=`asCreateLimbLoc ("Ankle"+$sl+"End") {$x*0.5,0.0,$systemNr} {0.3,0.3,0.3} 2`;
	$locs[4]=`asCreateLimbLoc ("Toes"+$sl) {$x*0.5,0.1,0.55+$systemNr} {0.3,0.1,0.3} 0`;
	$locs[5]=`asCreateLimbLoc ("Toes"+$sl+"End") {$x*0.5,0.1,1.05+$systemNr} {0.3,0.1,0.3} 0`;

	//child connect
	connectAttr ($locs[5]+".message") ($locs[4]+".child");
	connectAttr -na ($locs[4]+".message") ($locs[2]+".otherChildren");
	connectAttr ($locs[3]+".message") ($locs[2]+".child");
	connectAttr ($locs[2]+".message") ($locs[1]+".child");
	connectAttr ($locs[1]+".message") ($locs[0]+".child");
	connectAttr -na ($locs[0]+".message") Root.otherChildren;

	//system connect
	$system=`asCreateSystem Leg $sl`;
	connectAttr ($locs[0]+".message") ($system+".start");
	connectAttr ($locs[1]+".message") ($system+".mid");
	connectAttr ($locs[2]+".message") ($system+".end");
	connectAttr ($locs[3]+".message") ($system+".endEnd");
	connectAttr ($locs[4]+".message") ($system+".toes");
	connectAttr ($locs[5]+".message") ($system+".toesEnd");

	setAttr ($locs[0]+".twists") 2;
	setAttr -l 0 ($locs[0]+".bendCtrls");
	
	asEnsureSurface $system;

	asEnsureSystem $system;
	}
else if ($limbType=="Arm")
	{
	$systemNr=`asGetLimbNr $limbType`;
	$sl=`asGetLimbLetter $limbType`;
	$locs[0]=`asCreateLimbLoc ("Shoulder"+$sl) {$x+0.1,8+$systemNr,0} {0.3,0.3,0.3} 1`;
	$locs[1]=`asCreateLimbLoc ("Elbow"+$sl) {$x-1.3,8+$systemNr,-0.1} {0.2,0.2,0.2} 0`;
	$locs[2]=`asCreateLimbLoc ("Wrist"+$sl) {$x-2.75,8+$systemNr,0} {0.1,0.2,0.1} 1`;
	$locs[3]=`asCreateLimbLoc ("Wrist"+$sl+"End") {$x-3.15,8+$systemNr,0} {0.1,0.2,0.1} 1`;

	//child connect
	connectAttr ($locs[3]+".message") ($locs[2]+".child");
	connectAttr ($locs[2]+".message") ($locs[1]+".child");
	connectAttr ($locs[1]+".message") ($locs[0]+".child");
	if (`objExists Chest`)
		connectAttr -na ($locs[0]+".message") Chest.otherChildren;

	//system connect
	$system=`asCreateSystem Arm $sl`;
	connectAttr ($locs[0]+".message") ($system+".start");
	connectAttr ($locs[1]+".message") ($system+".mid");
	connectAttr ($locs[2]+".message") ($system+".end");
	connectAttr ($locs[3]+".message") ($system+".endEnd");

	setAttr ($locs[0]+".twists") 2;
	setAttr ($locs[1]+".twists") 2;
	setAttr -l 0 ($locs[0]+".bendCtrls");
	setAttr -l 0 ($locs[1]+".bendCtrls");

	asEnsureSystem $system;

	//Fingers:
	string $fingers[]={"Index","Middle","Ring","Pinky","Thumb"};
	string $fingerSystem;
	for ($i=0;$i<size($fingers);$i++)
		{
		string $fingerSystemNr=`asGetLimbNr "Finger"`;
		string $sl=`asGetLimbLetter ($fingers[$i]+"Finger")`;
		if ($fingerSystemNr==0)
			$fingerSystemNr="";
		$locs[size($locs)]=`asCreateLimbLoc ($fingers[$i]+"Finger1"+$sl) {$x+-3.2,8+$systemNr,0.18+($i*-0.12)} {0.05,0.05,0.05} 1`;
		$locs[size($locs)]=`asCreateLimbLoc ($fingers[$i]+"Finger2"+$sl) {$x+-3.389,8+$systemNr,0.18+($i*-0.12)} {0.05,0.05,0.05} 1`;
		$locs[size($locs)]=`asCreateLimbLoc ($fingers[$i]+"Finger3"+$sl) {$x+-3.527,8+$systemNr,0.18+($i*-0.12)} {0.05,0.05,0.05} 1`;
		$locs[size($locs)]=`asCreateLimbLoc ($locs[size($locs)-1]+"End") {$x+-3.646,8+$systemNr,0.18+($i*-0.12)} {0.05,0.05,0.05} 1`;

		//child connect
		connectAttr ($locs[size($locs)-1]+".message") ($locs[size($locs)-2]+".child");
		connectAttr ($locs[size($locs)-2]+".message") ($locs[size($locs)-3]+".child");
		connectAttr ($locs[size($locs)-3]+".message") ($locs[size($locs)-4]+".child");
		connectAttr -na ($locs[size($locs)-4]+".message") ($locs[2]+".otherChildren");

		//system connect
		$fingerSystem=`asCreateSystem ($fingers[$i]+"Finger") $sl`;
		connectAttr ($locs[size($locs)-4]+".message") ($fingerSystem+".start");
		connectAttr ($locs[size($locs)-3]+".message") ($fingerSystem+".mid");
		connectAttr ($locs[size($locs)-2]+".message") ($fingerSystem+".end");
		connectAttr ($locs[size($locs)-1]+".message") ($fingerSystem+".endEnd");

		asEnsureSystem $fingerSystem;
		}
	//move thumb into place
	$pos=`getAttr ($locs[2]+".t")`;
	setAttr -type float3 ($locs[size($locs)-4]+".t") ($pos[0]-0.084) ($pos[1]-0.084) ($pos[2]+0.158);
	setAttr -type float3 ($locs[size($locs)-3]+".t") ($pos[0]-0.211) ($pos[1]-0.126) ($pos[2]+0.293);
	setAttr -type float3 ($locs[size($locs)-2]+".t") ($pos[0]-0.361) ($pos[1]-0.179) ($pos[2]+0.398);
	asStraightEndLoc $locs[size($locs)-2] 0.12;
	setAttr -type float3 ("Direction"+$fingerSystem+".t") -0.128 -0.26 -0.098;
//	setAttr ($locs[size($locs)-4]+".dirTwist") -45;
	}
else if ($limbType=="Tail")
	{
	$systemNr=`asGetLimbNr $limbType`;
	$sl=`asGetLimbLetter $limbType`;
	$locs[0]=`asCreateLimbLoc ("Tail1"+$sl) {$x*0.5,4.3+$systemNr,-2} {0.3,0.3,0.3} 0`;
	$locs[1]=`asCreateLimbLoc ("Tail2"+$sl) {$x*0.5,4.3+$systemNr,-2.5} {0.3,0.3,0.3} 0`;
	$locs[2]=`asCreateLimbLoc ("Tail3"+$sl) {$x*0.5,4.3+$systemNr,-4.5} {0.3,0.3,0.3} 0`;
	$locs[3]=`asCreateLimbLoc ("Tail3End"+$sl) {$x*0.5,4.3+$systemNr,-5} {0.3,0.3,0.3} 0`;
/*
	$locs[4]=`asCreateLimbLoc ("Tail5"+$sl) {$x*0.5,4.3+$systemNr,-4} {0.3,0.3,0.3} 0`;
	$locs[5]=`asCreateLimbLoc ("Tail6"+$sl) {$x*0.5,4.3+$systemNr,-4.5} {0.3,0.3,0.3} 0`;
	$locs[6]=`asCreateLimbLoc ("Tail6End"+$sl) {$x*0.5,4.3+$systemNr,-5} {0.3,0.3,0.3} 0`;

	//child connect
	connectAttr ($locs[6]+".message") ($locs[5]+".child");
	connectAttr ($locs[5]+".message") ($locs[4]+".child");
	connectAttr ($locs[4]+".message") ($locs[3]+".child");
*/
	connectAttr ($locs[3]+".message") ($locs[2]+".child");
	connectAttr ($locs[2]+".message") ($locs[1]+".child");
	connectAttr ($locs[1]+".message") ($locs[0]+".child");
	connectAttr -na ($locs[0]+".message") Root.otherChildren;

	//system connect
	$system=`asCreateSystem Tail $sl`;
	connectAttr ($locs[0]+".message") ($system+".start");
	connectAttr ($locs[1]+".message") ($system+".mid");
	connectAttr ($locs[2]+".message") ($system+".end");
	connectAttr ($locs[3]+".message") ($system+".endEnd");

	asEnsureSystem $system;
	$segmentLocs=`asFitModeNumLocChanged`;//Creates the segmentLocs
	$locs=`stringArrayCatenate $locs $segmentLocs`;
	}
else
	error ($limbType+" Not developed yet");

asFitModeSelectionChanged;

//update the $locs[] array
select -cl;
for ($i=0;$i<size($locs);$i++)
	if (`objExists $locs[$i]`)
		select -add $locs[$i];
$locs=`ls -sl`;

//Lock X for middle
if ($middle)
	for ($i=0;$i<size($locs);$i++)
		{
		setAttr -l 1 ($locs[$i]+".tx");	
		if (`objExists ($locs[$i]+"End")`)
			setAttr -l 1 ($locs[$i]+"End.tx");
		}

//Select the new locs
select -cl;
for ($i=size($locs)-1;$i>-1;$i--)
	{
	if (`objExists ($locs[$i]+"End")`)
		select -add ($locs[$i]+"End");
	select -add $locs[$i];
	}
//special case when interactive building of basic`s (just select EndLoc)
if ($isExtendingParent)
	select $locs[size($locs)-1];
//Not to include hidden locs
for ($i=0;$i<size($locs);$i++)
	if (!`getAttr ($locs[$i]+".v")`)
		select -d $locs[$i];

repeatLast -addCommand" asCreateLimb";
}

global proc asCreateDirection (string $system, string $start, string $mid, string $end, int $auto)
{
string $type=`getAttr ($system+".type")`;
string $worldUpObject="Direction"+$system;
string $wuoA=`createNode -p Directions -n ($worldUpObject+"OffsetA") transform`;
connectAttr FitSkeleton.visDirections ($wuoA+".v");
string $wuoB=`createNode -p $wuoA -n ($worldUpObject+"OffsetB") transform`;
$tempString=`spaceLocator -n $worldUpObject`;
$tempString=`parent $tempString[0] $wuoB`;
$worldUpObject=$tempString[0];
setAttr -type float3 ($worldUpObject+".s") 1 1 1;
setAttr ($worldUpObject+"Shape.overrideEnabled") 1;
setAttr ($worldUpObject+"Shape.overrideColor") 13;
setAttr -k 0 ($worldUpObject+".rx");
setAttr -k 0 ($worldUpObject+".ry");
setAttr -k 0 ($worldUpObject+".rz");

pointConstraint $start ($worldUpObject+"OffsetA");
if ($type!="Spine" && $type!="Tail" && $type!="Basic")
	pointConstraint $end ($worldUpObject+"OffsetA");

if ($auto)
	{
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0
		-worldUpType "scene" $end ($worldUpObject+"OffsetA");
	pointConstraint -skip x -skip y $mid ($worldUpObject+"OffsetB");
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0
		-worldUpType "scene" $mid ($worldUpObject+"OffsetB");
	setAttr -l 1 ($worldUpObject+".v") 0;
	}
else
	addAttr -k 0 -ln "twister" -at bool $worldUpObject;
}

global proc string asCreateSystem (string $systemType, string $sl)
{
string $system=$systemType+$sl+"System";
createNode -n $system -p Systems transform;
addAttr -ln start -at "message";
addAttr -ln mid -at "message";
addAttr -ln end -at "message";
addAttr -ln endEnd -at "message";
addAttr -k 0 -ln poleX -at double;
addAttr -k 0 -ln poleY -at double;
addAttr -k 0 -ln poleZ -at double;
if ($systemType=="Leg")
	{
	addAttr -ln toes -at "message";
	addAttr -ln toesEnd -at "message";
	addAttr -k 0 -ln heelX -at double;
	addAttr -k 0 -ln heelZ -at double;
	addAttr -k 0 -ln footRotY -at double;
	}
addAttr -k 0 -ln dirFlip -at bool;
if ($systemType=="Arm" || $systemType=="Leg")
	{
	addAttr -k 0 -ln Scapula -at bool;//upperCase S is the bool
	addAttr -ln scapula -at "message";//lowerCase s is the message
	}
if ($systemType=="Spine" || $systemType=="Tail" || $systemType=="Basic")
	{
	addAttr -m -indexMatters 1 -ln segments -at "message";
	}
addAttr -ln type -dt "string";
setAttr -l 1 -type "string" ($system+".type") $systemType;
addAttr -ln systemLetter -dt "string";
setAttr -l 1 -type "string" ($system+".systemLetter") $sl;
return $system;
}

global proc string[] asGetSystemMarkers (string $system)
{
string $systemMarkers[],$tempString2[];
string $tempString[]=`listConnections -s 1 -d 0 ($system+".start")`;
string $start=$tempString[0];
string $tempString[]=`listConnections -s 1 -d 0 ($system+".end")`;
string $end=$tempString[0];
//use endEnd as end if exists
string $tempString[]=`listConnections -s 1 -d 0 ($system+".endEnd")`;
if ($tempString[0]!="")
	$end=$tempString[0];
//include toes & toesEnd
if (`attributeExists toesEnd $system`)
	{
	string $tempString[]=`listConnections -s 1 -d 0 ($system+".toesEnd")`;
	if ($tempString[0]!="")
		$systemMarkers[size($systemMarkers)]=$tempString[0];
	}
if (`attributeExists toes $system`)
	{
	string $tempString[]=`listConnections -s 1 -d 0 ($system+".toes")`;
	if ($tempString[0]!="")
		$systemMarkers[size($systemMarkers)]=$tempString[0];
	}

string $parent=$end;
int $loopCount;
while($parent!=$start)
	{
	$loopCount++;
	if ($loopCount>99)
		error ("asGetSystemMarkers proc, failed to traverse to parent for system:"+$system+"\n");
	$tempString=`listConnections ($parent+".message")`;
	$tempString2=`listConnections -p 1 ($parent+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$foundParent=0;
		if (`gmatch $tempString2[$y] "*[.]child"`)
			{
			$systemMarkers[size($systemMarkers)]=$parent;
			$parent=$tempString[$y];
			$foundParent=1;
			break;
			}
		}
	}
$systemMarkers[size($systemMarkers)]=$start;
return $systemMarkers;
}

global proc asEnsureSurface (string $system)
{
string $tempString[];
string $xyz[]={"x","y","z"};
string $trs[]={"t","r","s"};
$tempString=`listConnections -s 1 -d 0 ($system+".end")`;
string $end=$tempString[0];
$tempString=`listConnections -s 1 -d 0 ($system+".endEnd")`;
string $endEnd=$tempString[0];
$tempString=`listConnections -s 1 -d 0 ($system+".toes")`;
string $toes=$tempString[0];
$tempString=`listConnections -s 1 -d 0 ($system+".toesEnd")`;
string $toesEnd=$tempString[0];
string $rollComps[]      ={"Heel", "AnkleEnd","Toes","ToesEnd"};
string $rollCompMarkers[]={$endEnd,$endEnd,$toes, $toesEnd};

if (!`objExists ("Surface"+$system)`)
	{
	asFitModeEnsureShaders;
	createNode -n ("Surface"+$system) -p Surfaces transform;
	setAttr ("Surface"+$system+".overrideEnabled") 1;
	setAttr ("Surface"+$system+".overrideDisplayType") 2;
	for ($i=0;$i<size($rollComps);$i++)
		{
		$tempString[0]=`curve -d 1 -p 0 0 -1 -p 0 0 1 -k 0 -k 1`;
		rename $tempString[0] ("Surface"+$system+$rollComps[$i]+"Curve");
		parent ("Surface"+$system+$rollComps[$i]+"Curve") ("Surface"+$system);
		}

	for ($i=1;$i<size($rollComps);$i++)
		{
		if (`objExists $rollCompMarkers[$i]`)
			{
			spaceLocator -n ($rollCompMarkers[$i]+"WsSurfLoc");
			parent ($rollCompMarkers[$i]+"WsSurfLoc") ("Surface"+$system);
			parentConstraint $rollCompMarkers[$i] ($rollCompMarkers[$i]+"WsSurfLoc");
			scaleConstraint $rollCompMarkers[$i] ($rollCompMarkers[$i]+"WsSurfLoc");

			connectAttr ($rollCompMarkers[$i]+"WsSurfLoc.tx") ("Surface"+$system+$rollComps[$i]+"Curve.tx");
			connectAttr ($rollCompMarkers[$i]+"WsSurfLoc.tz") ("Surface"+$system+$rollComps[$i]+"Curve.tz");
			connectAttr ($rollCompMarkers[$i]+".s") ("Surface"+$system+$rollComps[$i]+"Curve.s");
			}
		}

	createNode -n ("Surface"+$system+"AnkleEndAim") -p ("Surface"+$system) transform;
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0
		-worldUpType "scene" ("Surface"+$system+"ToesCurve") ("Surface"+$system+"AnkleEndAim");
	connectAttr ($endEnd+"WsSurfLoc.tx") ("Surface"+$system+"AnkleEndAim.tx");
	connectAttr ($endEnd+"WsSurfLoc.tz") ("Surface"+$system+"AnkleEndAim.tz");

	createNode -n ("Surface"+$system+"ToesAim") -p ("Surface"+$system) transform;
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0
		-worldUpType "scene" ("Surface"+$system+"ToesEndCurve") ("Surface"+$system+"ToesAim");
	connectAttr ($toes+"WsSurfLoc.tx") ("Surface"+$system+"ToesAim.tx");
	connectAttr ($toes+"WsSurfLoc.tz") ("Surface"+$system+"ToesAim.tz");

	orientConstraint ("Surface"+$system+"AnkleEndAim") ("Surface"+$system+"AnkleEndCurve");
	orientConstraint ("Surface"+$system+"AnkleEndAim") ("Surface"+$system+"HeelCurve");
	orientConstraint ("Surface"+$system+"ToesAim") ("Surface"+$system+"ToesCurve");
	orientConstraint ("Surface"+$system+"ToesAim") ("Surface"+$system+"ToesEndCurve");

	spaceLocator -n ("Surface"+$system+"HeelLocator");
	setAttr -l 1 ("Surface"+$system+"HeelLocator.v") 0;
	parent ("Surface"+$system+"HeelLocator") ("Surface"+$system+"HeelCurve");
	parent ("Surface"+$system+"HeelCurve") ("Surface"+$system+"AnkleEndCurve");
	xform -os -t 0 0 0 -ro 0 0 0 -s 0.3 0.3 0.3 ("Surface"+$system+"HeelCurve");
	setAttr -type float3 ("Surface"+$system+"HeelCurve.t") -1.5 0 0;

	$tempString=`loft -ch 1 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true
		("Surface"+$system+"HeelCurveShape") ("Surface"+$system+"AnkleEndCurveShape")
			("Surface"+$system+"ToesCurve") ("Surface"+$system+"ToesEndCurve")`;
	rename $tempString[0] ("Surface"+$system+"LoftedSurface");
	rename $tempString[1] ("Surface"+$system+"Loft");
	asLockAttr ("Surface"+$system+"LoftedSurface") 1 1 1 0;
	parent ("Surface"+$system+"LoftedSurface") ("Surface"+$system);
	setAttr -l 1 ("Surface"+$system+"LoftedSurface.inheritsTransform") 0;
	evalDeferred -lp ("if (`objExists Surface"+$system+"LoftedSurface`)sets -e -forceElement asRedSG Surface"+$system+"LoftedSurface");

	asEnsureConnectAttr ("Surface"+$system+"HeelLocator.worldPosition[0].worldPositionX") ($system+".heelX");
	asEnsureConnectAttr ("Surface"+$system+"HeelLocator.worldPosition[0].worldPositionZ") ($system+".heelZ");
	asEnsureConnectAttr ("Surface"+$system+"AnkleEndAim.ry") ($system+".footRotY");
	}
}

global proc asEnsureSystem (string $system)
{
if (`gmatch $system "DS_*"`)
	return;
int $systemMarkersSkipWorldUp[];
string $systemMarkers[]=`asGetSystemMarkers $system`;
$scale=`getAttr FitSkeleton.sx`;
float $polePos[3];
$polePos[0]=`getAttr ($system+".poleX")`;
$polePos[1]=`getAttr ($system+".poleY")`;
$polePos[2]=`getAttr ($system+".poleZ")`;
string $tempString[]=`listConnections -s 1 -d 0 ($system+".start")`;
string $start=$tempString[0];
string $tempString[]=`listConnections -s 1 -d 0 ($system+".mid")`;
string $mid=$tempString[0];
string $tempString[]=`listConnections -s 1 -d 0 ($system+".end")`;
string $end=$tempString[0];
string $type=`getAttr ($system+".type")`;
if (`attributeExists toes $system`)
	for ($i=0;$i<size($systemMarkers);$i++)
		if (`isConnected ($systemMarkers[$i]+".message") ($system+".toes")` || `isConnected ($systemMarkers[$i]+".message") ($system+".toesEnd")`)
			$systemMarkersSkipWorldUp[$i]=1;

if (`objExists ($start+"Shape")`)
	{
	setAttr ($start+"Shape.overrideEnabled") 1;
	setAttr ($start+"Shape.overrideColor") 6;
	}

//do not continue without start,mid,end
if (!`objExists $start` || !`objExists $mid` || !`objExists $end`)
	return;

float $segments=4;
float $fkCtrls=3;
float $ikCtrls=3;
float $min=3;
int $numSystemMarkers=size($systemMarkers);
if ($type=="Tail") $segments=6;
if ($type=="Basic") {$segments=$numSystemMarkers-1;$fkCtrls=$numSystemMarkers-1;$ikCtrls=0;$min=1;}
if ($segments<1)
	$segments=1;
if ($fkCtrls<1)
	$fkCtrls=1;
if ($type=="Spine" || $type=="Tail" || $type=="Basic")
	{
	if (!`attributeExists segments $start`)
		{
		addAttr -k 1 -ln segments -at long -dv $segments -min $min -max 100 $start;
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($start+".segments") triggerPlusMinusAverage.input1D[$na];
		}
	if (!`attributeExists fkCtrls $start`)
		addAttr -k 1 -ln fkCtrls -at long -dv $fkCtrls -min 1 -max 100 $start;
	if (!`attributeExists ikCtrls $start`)
		addAttr -k 1 -ln ikCtrls -at long -dv $ikCtrls -min 0 -max 100 $start;
	//And hide .twists .bend .global, from locs in these systems, for simpler and less option
	string $hideAttrs[]={"twists","bendCtrls","global"};
	for ($i=0;$i<size($systemMarkers);$i++)
		for ($y=0;$y<size($hideAttrs);$y++)
			if (`attributeExists $hideAttrs[$y] $systemMarkers[$i]`)
				setAttr -k 0 ($systemMarkers[$i]+"."+$hideAttrs[$y]);
	}

if (`attributeExists fkCtrls $start`)
	{
	float $tempFloat[]=`attributeQuery -node $start -max fkCtrls`;
	if ($tempFloat[0]!=($numSystemMarkers-1))
		{
		//Update when number of segements change, via the attribte or creating of new `basic` locs
		//update .segments & .fkCtrls & .ikCtrls 
		setAttr ($start+".segments") ($numSystemMarkers-1);
		addAttr -e -maxValue `getAttr ($start+".segments")` ($start+".fkCtrls");
		setAttr ($start+".fkCtrls") ($numSystemMarkers-1);
		setAttr -l 0 ($start+".ikCtrls");
		if (($numSystemMarkers-1)<3)
			{
			setAttr ($start+".ikCtrls") 0;
			setAttr -l 1 ($start+".ikCtrls");
			}
		}
	}

//Delete, and recreate the .segments attribute, to keep the "Size" of the attribute correct,
//This happens both in asEnsureSystem & in asFitModeNumLocChanged, 
//as cause might be change .segments attribute, or new Basic Loc appended to end of chain
if (`attributeExists segments $system`)
	deleteAttr ($system+".segments");
addAttr -m -indexMatters 1 -ln segments -at "message" $system;
int $connectNr=0;
	for ($y=size($systemMarkers)-2;$y>-1;$y--)
		{
		connectAttr -f ($systemMarkers[$y]+".message") ($system+".segments["+$connectNr+"]");
		$connectNr++;
		}

int $auto=1;
if ($type=="Spine" || $type=="Neck" || `gmatch $type "*Finger"` || $type=="Basic" || $type=="Tail")
	$auto=0;

if (`getAttr ($start+".tx")`>-0.001 && `getAttr ($start+".tx")`<0.001)//	if (`gmatch $system "Spine*System*"` || `gmatch $system "Neck*System*"`)
	{
	for ($i=0;$i<size($systemMarkers);$i++)
		if (!$systemMarkersSkipWorldUp[$i])
			asEnsureConnectAttr DirectionFront.message ($systemMarkers[$i]+".worldUpObject");
	asEnsureConnectAttr DirectionFront.tx ($system+".poleX");
	asEnsureConnectAttr DirectionFront.ty ($system+".poleY");
	asEnsureConnectAttr DirectionFront.tz ($system+".poleZ");

//	if (!$auto && ($polePos[0]+$polePos[1]+$polePos[2])!=0)
//		xform -ws -t $polePos[0] $polePos[1] $polePos[2] DirectionFront;
	}
else if (!`objExists ("Direction"+$system)`)
	{
	asCreateDirection $system $start $mid $end $auto;
	float $temp[3]=`getAttr ($start+".t")`;
	float $temp2[3]=`getAttr ($end+".t")`;
	float $ddl=`mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	if ($ddl==0)
		$ddl=3;
	setAttr -type float3 ("Direction"+$system+"Shape.localScale") ($ddl/10.0) ($ddl/10.0) ($ddl/10.0);

//	if (!`attributeExists dirVis $start`)
//		addAttr -k 1 -ln dirVis -at bool -dv 1 $start;
//	asEnsureConnectAttr ($start+".dirVis") ("Direction"+$system+"OffsetA.v");
	if ($auto)
		{
		if (!`attributeExists dirLenght $start`)
			addAttr -k 1 -ln dirLenght -at double -dv $ddl $start;
		asEnsureConnectAttr ($start+".dirLenght") ("Direction"+$system+".tz");

		if (!`attributeExists dirFlip $start`)
			addAttr -k 1 -ln dirFlip -at bool $start;
		asEnsureConnectAttr ($start+".dirFlip") ($system+".dirFlip");
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($start+".dirFlip") triggerPlusMinusAverage.input1D[$na];

		if (`attributeExists twister ("Direction"+$system)`)
			{
			if (!`attributeExists dirTwist $start`)
				addAttr -k 1 -ln dirTwist -at double -dv 0 $start;
			asEnsureConnectAttr ($start+".dirTwist") ("Direction"+$system+"OffsetB.rz");
			}
		}
	if (($type=="Arm" || $type=="Leg") && !`attributeExists Scapula $start`)
		{
		addAttr -k 1 -ln Scapula -at bool $start;
		asEnsureConnectAttr ($start+".Scapula") ($system+".Scapula");
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($start+".Scapula") triggerPlusMinusAverage.input1D[$na];
		}
	if (($type=="Arm" || $type=="Leg") && !`attributeExists FKInIK $start`)
		addAttr -k 1 -ln FKInIK -at bool $start;
	else if (`gmatch $type "*Finger"`)
		setAttr ("Direction"+$system+".ty") ($ddl*-1);
	else if (!$auto)
		setAttr ("Direction"+$system+".tz") $ddl;
	if (`attributeExists skipAim $end`)
		setAttr ($end+".skipAim") 1;
	for ($i=0;$i<size($systemMarkers);$i++)
		if (!$systemMarkersSkipWorldUp[$i])
			{
			asEnsureConnectAttr ("Direction"+$system+".message") ($systemMarkers[$i]+".worldUpObject");
			//Ankle`s upVec is toes
			if (`attributeExists toes $system` && $systemMarkers[$i]==$end)
				{
				$tempString=`listConnections -s 1 -d 0 ($system+".toes")`;
				if ($tempString[0]!="")
					asEnsureConnectAttr ($tempString[0]+".message") ($systemMarkers[$i]+".worldUpObject");
				}
			}

	if ($auto)//Auto poleVectors are stored in WSpace, non-auto in OSpace
		{
		asEnsureConnectAttr ("Direction"+$system+".worldPosition[0].worldPositionX") ($system+".poleX");
		asEnsureConnectAttr ("Direction"+$system+".worldPosition[0].worldPositionY") ($system+".poleY");
		asEnsureConnectAttr ("Direction"+$system+".worldPosition[0].worldPositionZ") ($system+".poleZ");
		}
	else
		{
		asEnsureConnectAttr ("Direction"+$system+".tx") ($system+".poleX");
		asEnsureConnectAttr ("Direction"+$system+".ty") ($system+".poleY");
		asEnsureConnectAttr ("Direction"+$system+".tz") ($system+".poleZ");
		}
	if (!$auto && ($polePos[0]+$polePos[1]+$polePos[2])!=0)
		setAttr -type float3 ("Direction"+$system+".t") $polePos[0] $polePos[1] $polePos[2];
//		xform -ws -t ($polePos[0]*$scale) ($polePos[1]*$scale) ($polePos[2]*$scale) ("Direction"+$system);
//		xform -ws -t $polePos[0] $polePos[1] $polePos[2] ("Direction"+$system);
/*
	//annotation arrows missing, this can be if new directionSystem has been made, but CreateRigCyl has not ran
	//basically directionSystem got deleted. Delete all Aims, to ensure arrows via CreateRigCyl
	if (!`objExists ($start+"Direction")` || !`objExists ($mid+"Direction")` || !`objExists ($end+"Direction")`)
		{
		delete Aims;
		asFitModeSelectionChanged;
		}
*/
	if ($type=="Leg")
		asEnsureSurface $system;
	}
}

global proc string asGetLimbLetter (string $limbType)
{
string $limbLetter;
int $systemNumber=`asGetLimbNr $limbType`;
if ($systemNumber>0)
	$limbLetter=`asNrToLetter $systemNumber`;
return $limbLetter;
}

global proc int asGetLimbNr (string $limbType)
{
//Remove any unused systems first (doing here rather then `selChange` to keep it faster
string $systems[]=`listRelatives -c -type transform Systems`;
int $systemInUse;
for ($i=0;$i<size($systems);$i++)
	{
	if (`gmatch $systems[$i] "DS_*"`)
		continue;
	$systemInUse=0;
	string $uAttrs[]=`listAttr -ud $systems[$i]`;
	for ($y=0;$y<size($uAttrs);$y++)
		if (`getAttr -type ($systems[$i]+"."+$uAttrs[$y])`=="message")
			{
			$tempString=`listConnections ($systems[$i]+"."+$uAttrs[$y])`;
			if (size($tempString[0]))
				{
				$systemInUse=1;
				break;
				}
			}
	if (!$systemInUse)
		delete $systems[$i];
	}

for ($systemNr=0;$systemNr<99;$systemNr++)
	{
	if ($systemNr==0)
		$system=$limbType+"System";
	else
		$system=$limbType+`asNrToLetter $systemNr`+"System";
	if (!`objExists $system`)
		break;
	}
return $systemNr;
}

global proc asToggleFitModeHierarchy ()
{
global int $asFitModeHierarchy;
global int $asFitModeSkip;
$asFitModeSkip=1;
string $sel[]=`ls -sl`;
$asFitModeHierarchy=!$asFitModeHierarchy;
string $markers[],$tempString[];
int $z;
int $markerMiddle[];
if (!`objExists FitSkeleton`)
	return;

if ($asFitModeHierarchy) //Enter Hierarchy Mode
	{
	headsUpDisplay -e -l "Fit Mode(hierarchy)" HUDFitMode;
	$markers=`asGetMarkers`;
	for ($z=0;$z<size($markers);$z++)
		{
		$markerMiddle[$z]=`getAttr -l $markers[$z] ($markers[$z]+".tx")`;
		setAttr -k 1 ($markers[$z]+".rx");setAttr -k 1 ($markers[$z]+".ry");setAttr -k 1 ($markers[$z]+".rz");
		if (`objExists ($markers[$z]+"_orientConstraint1")`)
			delete ($markers[$z]+"_orientConstraint1");
		}
	for ($z=0;$z<size($markers);$z++)
		if (!`objExists ($markers[$z]+"ParentConstraint")`)
			{
			setAttr -l 0 ($markers[$z]+".tx");;
			asCreateHierarchyConstraint $markers[$z];
			if ($markerMiddle[$z])
				{
				setAttr -l 1 ($markers[$z]+".tz");
				setAttr -l 1 -k 0 ($markers[$z]+".rx");
				setAttr -l 1 -k 0 ($markers[$z]+".ry");
				}
			}
	}
else //Exit Hierarchy Mode
	{
	headsUpDisplay -e -l "Fit Mode" HUDFitMode;
	string $markersChildren[]=`listRelatives -c Markers`;
	for ($z=0;$z<size($markers);$z++)
		$markerMiddle[$z]=`getAttr -l $markers[$z] ($markers[$z]+".tx")`;
	for ($i=0;$i<size($markersChildren);$i++)
		if (`gmatch $markersChildren[$i] "*ParentConstraint"`)
			{
			$tempString=`listRelatives -c $markersChildren[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				if (`gmatch $tempString[$y] "*ParentConstraint_*Constraint*"`)
					delete $tempString[$y];
				else
					{
					$markers[$z]=$tempString[$y];
					setAttr -l 0 -k 0 ($markers[$z]+".rx");setAttr -l 0 -k 0 ($markers[$z]+".ry");setAttr -l 0 -k 0 ($markers[$z]+".rz");
					setAttr -l 0 ($markers[$z]+".tz");
					//parenting with non-uniform scale has sideEffects
					float $scale[]=`getAttr ($markers[$z]+".s")`;
					setAttr -type float3 ($markers[$z]+".s") 1 1 1;
					parent $markers[$z] Markers;
					setAttr -type float3 ($markers[$z]+".s") $scale[0] $scale[1] $scale[2];
					$z++;
					}
				}
			delete $markersChildren[$i];
			}

	for ($z=0;$z<size($markers);$z++)
		{
		if ($markerMiddle[$z])
			setAttr -l 1 ($markers[$z]+".tx");
		if (`objExists ($markers[$z]+"Aim")`)
			orientConstraint ($markers[$z]+"Aim") $markers[$z];
		else
			{
			string $endParent=`substitute "End" $markers[$z] ""`;
			if (`objExists ($endParent+"Aim")`)
				orientConstraint ($endParent+"Aim") $markers[$z];
			}
		}
	}
select $sel;
$asFitModeSkip=0;
asFitModeSelectionChanged;
}

global proc asEnsureOffHierarchyMode ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeHierarchy;
if (!`objExists Markers`)
	return;
int $wasInFitMode=0;
if ($asFitModeScriptJob1Nr)
	$wasInFitMode=1;
string $markerChildren[]=`listRelatives -type transform -c Markers`;
for ($i=0;$i<size($markerChildren);$i++)
	if (`gmatch $markerChildren[$i] "*ParentConstraint"`)
		{
		if (!$wasInFitMode)
			asToggleFitMode;
		asToggleFitModeHierarchy;
		asToggleFitModeHierarchy;
		if (!$wasInFitMode)
			asToggleFitMode;
		break;
		}
$asFitModeHierarchy=0;
}

global proc asUpdateButtonEnables ()
{
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;

//Body
checkBox -e -m $hasBodySetup asRebuildConnections;
button -e -m $hasBodySetup asToggleFitSkeletonButton;
string $buildLabel="Build AdvancedSkeleton";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
button -e -l $buildLabel asBuildAdvancedSkeletonButton;

//Face
button -e -m $hasFaceSetup asToggleFitFaceButton;
rowLayout -e -m $hasFaceSetup asFaceRebuildKeepBSRowLayout;
string $buildLabel="Build AdvancedFace";
if ($hasFaceSetup)
	$buildLabel="ReBuild AdvancedFace";
button -e -l $buildLabel asBuildAdvancedFaceButton;

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;

//Live
if (`asHaveMeshCenterSnap`)
	{
	string $liveText="Right click";
	string $tempString[]=`ls -live`;
	if (size($tempString))
		{
		$tempString=`listRelatives -p $tempString[0]`;
		$liveText=$tempString[0];
		}
	else
		{
		string $lastLiveGeometry=`optionVar -q asLiveGeometry`;
		if (`objExists $lastLiveGeometry`)
			$liveText=$lastLiveGeometry;
		}
	textField -e -tx $liveText asMakeLiveObjectText;
	if (`snapMode -q -meshCenter`)
		iconTextCheckBox -e -v 1 asMeshCenterSnapButton;		
	}
}

global proc asSceneOpened ()
{
global int $asFitModeScriptJob3Nr;
$asFitModeScriptJob3Nr=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

asUpdateButtonEnables;
asFitSkeletonConnectControl;
asFaceUpdateInfo 1;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeScriptJob2Nr;
global int $asFitModeHierarchy;
$asFitModeHierarchy=0;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJob1Nr` && $asFitModeScriptJob1Nr!=0)
	{
	scriptJob -kill $asFitModeScriptJob1Nr;
	$asFitModeScriptJob1Nr=0;
	}
if (`scriptJob -ex $asFitModeScriptJob2Nr` && $asFitModeScriptJob2Nr!=0)
	{
	scriptJob -kill $asFitModeScriptJob2Nr;
	$asFitModeScriptJob2Nr=0;
	}
}

global proc asToggleFitMode ()
{
global int $asFitModeScriptJob1Nr;
global int $asFitModeScriptJob2Nr;
global int $asFitModeHierarchy;
global int $asFitModePreMoveMode;

if (`objExists Main`) //confirmDialog if Main control != 0
	{
	float $t[3]=`getAttr Main.t`;
	float $r[3]=`getAttr Main.r`;
	float $s[3]=`getAttr Main.s`;
	if ($t[0]!=0 || $t[1]!=0 || $t[2]!=0 || $r[0]!=0 || $r[1]!=0 || $r[2]!=0 || $s[0]!=1 || $s[1]!=1 || $s[2]!=1)
		if (!`headsUpDisplay -q -ex HUDFitMode`)
			if (`confirmDialog -t "Warning"
				-m "\"Main\" controller is not in defail pose, entering FitMode now could cause undesired results"
				-b "OK" -db "OK"
				-b "Cancel" -ds "Cancel"`!="OK")
					return;
	}

if (`headsUpDisplay -q -ex HUDFitMode`)
	{
	asEnsureOffHierarchyMode;
	manipMoveContext -e -mode $asFitModePreMoveMode "Move";
	headsUpDisplay -rem HUDFitMode;
	if (`scriptJob -ex $asFitModeScriptJob1Nr` && $asFitModeScriptJob1Nr!=0)
		scriptJob -kill $asFitModeScriptJob1Nr;
	if (`scriptJob -ex $asFitModeScriptJob2Nr` && $asFitModeScriptJob2Nr!=0)
		scriptJob -kill $asFitModeScriptJob2Nr;
	button -e -en 0 asHierarchyButton;
	checkBox -e -en 0 asVisGeoSelectable;
	button -e -l FitMode asToggleFitSkeletonButton;
	$asFitModeScriptJob1Nr=0;
	asToggleFitAdvanced 0;
	asSelectableGeo 0;
	}
else
	{
	$asFitModeHierarchy=0;
	if (!`objExists FitSkeleton`)
		asCreateFitSkeleton;
	asEnsureFitBaseStruct;
	asEnsureFitSystems;
	$asFitModePreMoveMode=`manipMoveContext -q -mode "Move"`;
	manipMoveContext -e -mode 2 "Move";
	string $hudLabel="Fit Mode";
	headsUpDisplay -s 2 -b 0 -bs "medium" -l $hudLabel -lfs "large" HUDFitMode;
	$asFitModeScriptJob1Nr=`scriptJob -compressUndo 1 -e SelectionChanged asFitModeSelectionChanged`;
	$asFitModeScriptJob2Nr=`scriptJob -compressUndo 1 -ac FitSkeletonShape.overrideVisibility asFitModeNumLocChanged`;
	button -e -en 1 asHierarchyButton;
	checkBox -e -en 1 asVisGeoSelectable;
	button -e -l Cancel asToggleFitSkeletonButton;
	asFitModeSelectionChanged;
	asToggleFitAdvanced 1;
	if (`optionVar -q asSelectableGeo`)
		asSelectableGeo 1;
	asFitModeNumLocChanged;
	}
}

global proc asToggleFitModeFace ()
{
if (`headsUpDisplay -q -ex HUDFitModeFace`)
	{
	headsUpDisplay -rem HUDFitModeFace;
	button -e -l FitMode asToggleFitFaceButton;
	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 0;
	catchQuiet (`setAttr FaceMotionSystem.v 1`);
	catchQuiet (`setAttr FaceDeformationSystem.v 1`);
	}
else
	{
	string $hudLabel="Fit Mode (Face)";
	int $nextFreeBlock=`headsUpDisplay -nextFreeBlock 2`;
	headsUpDisplay -s 2 -b $nextFreeBlock -bs "medium" -l $hudLabel -lfs "large" HUDFitModeFace;
	button -e -l Cancel asToggleFitFaceButton;
	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 1;
	setAttr FaceMotionSystem.v 0;
	setAttr FaceDeformationSystem.v 0;
	}
}

global proc asSelectableGeo (int $selectable)
{
int $displayType=0;
if (!$selectable)
	$displayType=2;
//Not make selectable if using snapToCenter
if (`asHaveMeshCenterSnap`)
	if (`snapMode -q -meshCenter`)
		$displayType=2;
string $shape;
string $geoTypes[]={"Box","Cyl"};
string $markers[]=`asGetMarkers`;
for ($i=0;$i<size($markers);$i++)
	{
	for ($a=0;$a<size($geoTypes);$a++)
		{
		$shape=$markers[$i]+$geoTypes[$a]+"Shape";
		if (`objExists $shape`)
			setAttr ($shape+".overrideDisplayType") $displayType;
		for ($y=1;$y<99;$y++)
			{
			$shape=$markers[$i]+"Part"+$y+$geoTypes[$a]+"Shape";
			if (`objExists $shape`)
				setAttr ($shape+".overrideDisplayType") $displayType;
			else
				break;
			}
		}
	}
}

global proc asToggleFitAdvanced (int $onOff)
{
if (!`objExists DeformationSystem`)
	return;
if ($onOff && !`objExists Visualizers`)
	{
	asEnsureFitBaseStruct;
	}
if (!$onOff && `objExists Visualizers`)
	delete Visualizers;
	
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v $onOff;
setAttr MainShape.v (!$onOff);
setAttr MotionSystem.v (!$onOff);
setAttr DeformationSystem.v (!$onOff);

if ($onOff && `objExists DrivingSystem`)
	asUpdateDrivingSystemsToFitSkeleton;
}

global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asUpdateDrivingSystemsToFitSkeleton ()
{
string $sel[]=`ls -sl`;
//Remove ewxisting FitSkeltonDrivingSystems first
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		delete $systems[$i];
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$ds="DS_"+$drivingSystems[$i];
	createNode -n $ds -p "Systems" transform;
	string $uAs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($uAs);$y++)
		{
		$dsd=$ds+"_"+$uAs[$y];
		createNode -n $dsd -p $ds transform;
		asLockAttr $dsd 1 1 1 1;
		addAttr -k 1 -ln $uAs[$y] -at double $ds;
		asCopyAttrProperties ($drivingSystems[$i]+"."+$uAs[$y]) ($ds+"."+$uAs[$y]);
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$uAs[$y])`;
		for ($z=0;$z<size($tempString);$z++)
			{
			duplicate -n ("Fit_"+$tempString[$z]) $tempString[$z];
			if (`sets -im AllSet ("Fit_"+$tempString[$z])`)
				sets -rm AllSet ("Fit_"+$tempString[$z]);
			addAttr -k 1 -ln ("standinAttr"+$z) -at double $dsd;
			connectAttr ("Fit_"+$tempString[$z]+".output") ($dsd+".standinAttr"+$z);
			}
		}
	}
select $sel;
}

global proc string[] asFitModeNumLocChanged ()
{
global int $asFitModeSkip;
global int $asFitSkeletonTriggerPrevious;
string $newLocs[];
int $trigger=`getAttr FitSkeleton.trigger`;
if ($trigger==$asFitSkeletonTriggerPrevious)
	return{};
$asFitSkeletonTriggerPrevious=$trigger;
int $twists,$systemNr,$mid,$dirFlip,$useScapula,$segNum,$rotateOrder;
float $upV[3];
float $pos[3];
string $name,$parent,$end,$endEnd,$limbType,$ms,$newEnd,$newEndEnd,$newMid;
string $sel[]=`ls -sl`;
string $markers[]=`asGetMarkers`;
string $rootGeos[],$tempString[],$tempString2[],$systemMarkers[],$otherChildren[],$restoreOtherChildrenCmds[];
for ($i=0;$i<size($markers);$i++)
	{
	//twists
	if (`attributeExists twists $markers[$i]`)
		{
		$twists=`getAttr ($markers[$i]+".twists")`;
		$rootGeos=`ls ($markers[$i]+"Part*Geo*")`;
		if ($twists!=size($rootGeos))
			{
			catchQuiet (`delete $rootGeos`);
			catchQuiet (`delete ($markers[$i]+"Geo*")`);
			setAttr -l 0 ($markers[$i]+".bendCtrls");
			if ($twists==0)
				setAttr -l 1 ($markers[$i]+".bendCtrls") off;
			}
		}
	//segments
	if (`attributeExists segments $markers[$i]`)
		{
		$segments=`getAttr ($markers[$i]+".segments")`;
		$ms=`asGetMarkerSystem $markers[$i]`;
		string $type=`getAttr ($ms+"System.type")`;
//		if ($type=="Basic") // Not able to "re-sample" segments of Basic ..yet
//			return {};
		$sl=`getAttr ($ms+"System.systemLetter")`;
		$tempString=`listConnections ($ms+"System.end")`;
		$end=$tempString[0];
		if ($type=="Spine" || $type=="Basic")
			{
			$tempString=`listConnections ($ms+"System.endEnd")`;
			$end=$tempString[0];
			}

		clear $systemMarkers;
		$systemMarkers=`asGetSystemMarkers ($ms+"System")`;

		if ($segments!=size($systemMarkers)-1)
			{
			$mid=`getAttr -l ($markers[$i]+".tx")`;
			$asFitModeSkip=1;
//			float $posStart[3]=`xform -q -ws -t $markers[$i]`;
//			float $posEnd[3]=`xform -q -ws -t $end`;
			$rotateOrder=`getAttr ($markers[$i]+".rotateOrder")`;
			float $posStart[3]=`getAttr ($markers[$i]+".t")`;
			float $posEnd[3]=`getAttr ($end+".t")`;
			float $sca[3]=`xform -q -r -s $markers[$i]`;
			for ($y=0;$y<size($systemMarkers)-1;$y++)
				{
				$otherChildren=`listConnections ($systemMarkers[$y]+".otherChildren")`;
				for ($z=0;$z<size($otherChildren);$z++)
					$restoreOtherChildrenCmds[size($restoreOtherChildrenCmds)]="connectAttr -na "+$otherChildren[$z]+".message "+$systemMarkers[$y]+".otherChildren;";
//				catchQuiet (`delete $systemMarkers[$y]`);
				asDeleteIfFaultyMarker $systemMarkers[$y] 1;
				delete $systemMarkers[$y];
				}

			//Delete, and recreate the .segments attribute, to keep the "Size" of the attribute correct,
			//This happens both in asEnsureSystem & in asFitModeNumLocChanged, 
			//as cause might be change .segments attribute, or new Basic Loc appended to end of chain
			if (`attributeExists segments ($ms+"System")`){
				deleteAttr ($ms+"System.segments");
}
			addAttr -m -indexMatters 1 -ln segments -at "message" ($ms+"System");
			connectAttr -f ($markers[$i]+".message") ($ms+"System.segments[0]");

			for ($y=2;$y<$segments+2;$y++)
				{
				$pos[0]=$posStart[0]+((($posEnd[0]-$posStart[0])/$segments))*($y-1);
				$pos[1]=$posStart[1]+((($posEnd[1]-$posStart[1])/$segments))*($y-1);
				$pos[2]=$posStart[2]+((($posEnd[2]-$posStart[2])/$segments))*($y-1);
				$segNum=$y;
				if ($type=="Spine" || $type=="Basic")
					$segNum=$y-1;				
				$name=$ms+$segNum;
				if ($y==2)
					$parent=$markers[$i];
				else
					$parent=$ms+($segNum-1);				
				if ($y>2 && $y==$segments+1)
					{
					$name=$ms+($segNum-1)+"End";
					$parent=$ms+($segNum-1);
					}
				if ($type=="Spine" && $y==$segments)
					$name="Chest"+$sl;
				if ($type=="Spine" && $y==$segments+1)
					{
					$name="Chest"+$sl+"End";
					$parent="Chest"+$sl;
					}
				if ($segments==1)
					$name=$markers[$i]+"End";
				asCreateLimbLoc $name {$pos[0],$pos[1],$pos[2]} {$sca[0],$sca[1],$sca[2]} $rotateOrder;
				connectAttr -f ($name+".message") ($ms+"System.segments["+($segNum-1)+"]");
				$newLocs[size($newLocs)]=$name;
				connectAttr -f ($name+".message") ($parent+".child");
				if ($mid)
					setAttr -l 1 ($name+".tx") 0;
				}
			if ($type=="Spine")
				{
				$newEnd="Chest"+$sl;
				$newEndEnd="Chest"+$sl+"End";
				$newMid=$ms+(($segments+0)/2);
				}
			else if ($type=="Tail")
				{
				$newEnd=$ms+$segments;
				$newEndEnd=$ms+$segments+"End";
				$newMid=$ms+(($segments+1)/2);
				}
			else if ($type=="Basic" && $segments==1)
				{
				$newEnd=$markers[$i]+"End";
				$newEndEnd=$markers[$i]+"End";
				$newMid=$markers[$i]+"End";
				}
			else if ($type=="Basic" && $segments>1)
				{
				$newEnd=$ms+($segments-1);
				$newEndEnd=$ms+($segments-1)+"End";
				$newMid=$ms+(($segments+1)/2);
				}

			connectAttr -f ($newEnd+".message") ($ms+"System.end");
			connectAttr -f ($newEndEnd+".message") ($ms+"System.endEnd");
			connectAttr -f ($newMid+".message") ($ms+"System.mid");

			//RestoreChildrendInfo
			for ($z=0;$z<size($restoreOtherChildrenCmds);$z++)
					catchQuiet(`eval $restoreOtherChildrenCmds[$z]`);
			string $direction="Direction"+$ms+"System"+"OffsetA";
			if (`objExists $direction`)
				delete $direction;//so asEnsureSystem rebuilds direction, where all joints have worldUpObject connected
			asEnsureSystem ($ms+"System");
			$asFitModeSkip=0;
			}
		}
	//dirFlip
	if (`attributeExists dirFlip $markers[$i]`)
		{
		$dirFlip=`getAttr ($markers[$i]+".dirFlip")`;
		$upV={0,1,0};
		if ($dirFlip)
			$upV={0,-1,0};
		//Flip upVec for some Limbs, to make them `point forward`
		if (`gmatch $markers[$i] "*Elbow*"` || `gmatch $markers[$i] "*Shoulder*"` || `gmatch $markers[$i] "*Wrist*"`)
			{$upV[0]*=-1;$upV[1]*=-1;$upV[2]*=-1;}
		$ms=`asGetMarkerSystem $markers[$i]`;
		string $type=`getAttr ($ms+"System.type")`;
		clear $systemMarkers;
		$systemMarkers=`asGetSystemMarkers ($ms+"System")`;
		for ($y=0;$y<size($systemMarkers);$y++)
			{
			string $aimConstraint=$systemMarkers[$y]+"Aim_aimConstraint1";			
			if (`objExists $aimConstraint`)
				{
				//skip if worldUpObject !Direction*  e.g skip Ankle
				$tempString=`listConnections ($aimConstraint+".worldUpMatrix")`;
				if (!`gmatch $tempString[0] "*Direction*"`)
					continue;
				setAttr -type float3 ($aimConstraint+".upVector") $upV[0] $upV[1] $upV[2];
				}
			}
		}
	//scapula
	if (`attributeExists Scapula $markers[$i]`)
		{
		$ms=`asGetMarkerSystem $markers[$i]`;
		$useScapula=`getAttr ($markers[$i]+".Scapula")`;
		$tempString=`listConnections ($ms+"System.scapula")`;
		string $scapula=$tempString[0];
		$tempString=`listConnections ($ms+"System.start")`;
		string $shoulder=$tempString[0];
		$tempString=`listConnections ($shoulder+".worldUpObject")`;
		string $shoulderWorldUpObject=$tempString[0];

		if(!$useScapula && `objExists $scapula`)
			delete $scapula;
		if($useScapula && !`objExists $scapula`)
			{
			$pos=`xform -q -ws -t $shoulder`;
			$pos[0]=$pos[0]/4.0;
			$scale=`xform -q -r -s $shoulder`;
			$scapula=`asCreateLimbLoc "Scapula" $pos $scale 4`;
			$newLocs[size($newLocs)]=$scapula;
			transformLimits -tx -1 0.01 -etx 0 1 $scapula;
			connectAttr ($scapula+".message") ($ms+"System.scapula");
			connectAttr -na ($scapula+".message") ($shoulder+".otherChildren");
			connectAttr ($shoulderWorldUpObject+".message") ($scapula+".worldUpObject");
			}
		}
	}
//asFitModeSelectionChanged;
select -cl;
for ($i=0;$i<size($sel);$i++)
	catchQuiet(`select -add $sel[$i]`);
return $newLocs;
}

global proc int asDeleteIfFaultyMarker (string $marker, int $force)
{
global int $asFitModeHierarchy;
string $requiredVizComps[]={"Aim","Cyl","Box","Distance","GapBlenderA","GapBlenderB","Flare","FlareHandle",
	"Aim_pointConstraint1"};//"End_orientConstraint1" might not be there
//if (!$asFitModeHierarchy)
	$requiredVizComps[size($requiredVizComps)]="Aim_aimConstraint1";
int $faulty=0;
for ($y=0;$y<size($requiredVizComps);$y++)
	{
	if (!`objExists ($marker+$requiredVizComps[$y])`)
		{
		$faulty=1;
		break;
		}
	}
if ($faulty || $force)
	for ($y=0;$y<size($requiredVizComps);$y++)
		if (`objExists ($marker+$requiredVizComps[$y])`)
			delete ($marker+$requiredVizComps[$y]);
return $faulty;
}

global proc asDeleteIncompleteSystems ()
{
//detects if a locator has been deleted, and removes the rest of the system
int $faultySystem;
string $udAttrs[],$connections[],$systemLocators[];
if (!`objExists Systems`)
	return;
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	{
	$faultySystem=0;
	clear $systemLocators;
	$udAttrs=`listAttr -ud $systems[$i]`;
	if (`attributeExists segments $systems[$i]`)
		{
		$udAttrs=`stringArrayRemove {"segments"} $udAttrs`;
		for ($y=0;$y<`getAttr -s ($systems[$i]+".segments")`;$y++)
			$udAttrs[size($udAttrs)]="segments["+$y+"]";
		}
	for ($y=0;$y<size($udAttrs);$y++)
		{
		if (`getAttr -type ($systems[$i]+"."+$udAttrs[$y])`=="message")
			{
			$connections=`listConnections ($systems[$i]+"."+$udAttrs[$y])`;
			if ($connections[0]=="")
				{
				if ($udAttrs[$y]!="scapula" && $udAttrs[$y]!="endEnd")
					{
					print ("// Missing Locator connected to: "+$systems[$i]+"."+$udAttrs[$y]+"\n");
					$faultySystem=1;
					}
				}
			else
				$systemLocators[size($systemLocators)]=$connections[0];
			}
		}
	if ($faultySystem)
		{
		print ("// Deleting inclomplete system: "+$systems[$i]+"\n");
		delete $systems[$i];
		for ($y=0;$y<size($systemLocators);$y++)
			if (`objExists $systemLocators[$y]`)
				delete $systemLocators[$y];

		//Ensure Root
		if (!` objExists "Root"`)
			asCreateRootLimb;
		}
	}
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeSkip;
global int $asFitModeHierarchy;
global string $asFitModePreviousSelected[];
if ($asFitModeSkip)
	return;
string $sel[]=`ls -sl`;
string $tempString[],$redirectSel[];

//redirect selection to Loc
if (`optionVar -q asSelectableGeo`)
	{
	for ($i=0;$i<size($sel);$i++)
		{
		$tempString=`listRelatives -p $sel[$i]`;
		if (`gmatch $tempString[0] "*Geo"`)
			{
			select -cl;
			string $loc=`substitute "Box" $sel[$i] ""`;
			$loc=`substitute "Cyl" $loc ""`;
			$loc=`substitute "Part[0-9]" $loc ""`;
			if (`objExists $loc`)
				$redirectSel[size($redirectSel)]=$loc;
			}	
		}
	//also include locs that were selected e.g. end locs
	if (size($redirectSel))
		for ($i=0;$i<size($sel);$i++)
			if (!`stringArrayCount $sel[$i] $redirectSel`)
				{
				$tempString=`listRelatives -s $sel[$i]`;
				if ($tempString[0]!="")
					if (`objectType $tempString[0]`=="locator")
						$redirectSel[size($redirectSel)]=$sel[$i];
				}
	if (size($redirectSel))
		{
		select $redirectSel;
		$sel=`ls -sl`;
		}
	}

if (!`objExists FitSkeleton`)
	{
	evalDeferred asToggleFitMode;
	return;
	}

asEnsureFitBaseStruct;
if (!$asFitModeSkip)
	asDeleteIncompleteSystems;

int $continueCyl,$rotateOrder;
int $faultyMarkers[],$skipVis[];
string $connections[];
string $child,$previousSelected,$locator,$cyl;
float $pos[3],$sca[3],$parentedLocatorPos[3];
//check all
string $tempString[],$tempString2[],$tempString3[],$parents[];
string $markers[]=`asGetMarkers`;
string $systems[]=`listRelatives -c Systems`;
string $vizAims[]=`listRelatives -c -type transform Aims`;
string $vizDirections[]=`listRelatives -c -type transform Directions`;
string $vizSurfaces[]=`listRelatives -c -type transform Surfaces`;
string $vizXforms[]=`stringArrayCatenate $vizAims $vizDirections`;
string $children[];

//make sure locator have basic attributes, as this might have been a generic loc parented in.
for ($i=0;$i<size($markers);$i++)
	if (!`attributeExists worldUpObject $markers[$i]`)
		asEnsureLimbLocAttrs $markers[$i];

for ($i=0;$i<size($markers);$i++)
	if (`attributeExists child $markers[$i]`)
		{
		$connections=`listConnections -s 1 -d 0 ($markers[$i]+".child")`;
		$children[$i]=$connections[0];
		}

//Remove limbComponents that have no $matchingLoc (e.g. marker got deleted)
for ($z=0;$z<size($vizXforms);$z++)
	if (`gmatch $vizXforms[$z] "*Aim"`)
		{
		int $numLetters=`size $vizXforms[$z]`;
		string $matchingLoc=`substring $vizXforms[$z] 1 ($numLetters-3)`;
		if (!`objExists $matchingLoc`)
			asDeleteIfFaultyMarker $matchingLoc 1;
		}
//Remove all limbComponents, if any limbComponents are missing (hence ensuring all limbComponents)
for ($i=0;$i<size($markers);$i++)
if (!`gmatch $markers[$i] "*End"`)
	$faultyMarkers[$i]=`asDeleteIfFaultyMarker $markers[$i] 0`;

//find $parents[], and skipVis[]
for ($i=0;$i<size($markers);$i++)
	{
	if (!`objExists $markers[$i]`)
		continue;
	$tempString =`listConnections -s 0 -d 1 -p 0 ($markers[$i]+".message")`;
	$tempString2=`listConnections -s 0 -d 1 -p 1 ($markers[$i]+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString2[$y] "*[.]child"` || `gmatch $tempString2[$y] "*[.]otherChildren*"`)
			$parents[$i]=$tempString[$y];
		if (`gmatch $tempString2[$y] "*[.]scapula"`)
			$skipVis[$i]=1;
		}
	}

//System checks (ensure every (non-mid) system have Directions & Surfaces)
for ($i=0;$i<size($systems);$i++)
	{
	if (`gmatch $systems[$i] "DS_*"`)
		continue;
//	if (!`objExists ("Direction"+$systems[$i]+"SystemOffsetA")`)
//		if (`getAttr ($systems[$i]+".poleX")`!=0)
			asEnsureSystem $systems[$i];
	}

for ($i=0;$i<size($markers);$i++)
	{
	if (!`objExists $markers[$i]` || $skipVis[$i])
		continue;
	$locator=$markers[$i];
	$isEnd=!`attributeExists child $markers[$i]`;
	$pos=`xform -q -ws -t $locator`;
	$pos[0]=`asRoundOff $pos[0] 3`;
	if (!`attributeExists child $locator` && !$isEnd)
		addAttr -ln child -at "message" $locator;
	$child=$children[$i];
	int $rebuild=0;
	int $madeEndLoc=0;

	//Ensure only 1 topNode
	if ($parents[$i]=="" && $locator!="Root")
		{
		string $topNode="Root";
		if (!`objExists $topNode`)
			for ($y=0;$y<size($markers);$y++)
				if (`gmatch $markers[$y] "Root*"` && `attributeExists child $markers[$i]`)
					if (`getAttr ($markers[$y]+".tx")`==0)
						$topNode=$markers[$y];
		if (!`objExists $topNode`)
			for ($y=0;$y<size($markers);$y++)
				if ($parents[$y]=="" && `attributeExists child $markers[$y]`)
					if (`getAttr ($markers[$y]+".tx")`==0)
						$topNode=$markers[$y];
		if (!`objExists $topNode`)
			asCreateRootLimb;
		if ($locator!=$topNode)
			connectAttr -na ($locator+".message") ($topNode+".otherChildren");
		}

/*function removed, as it will cause a single leg rig, to have root aimed at leg
	//If have no child, but have otherChild, upgrade otherChild[0] to child, (can happen if a endLoc is deleted)
	if (!`objExists $child`)
		{
		$tempString=`listConnections -c 1 ($locator+".otherChildren")`;
		if (size($tempString))
			{
			$child=$tempString[1];
			connectAttr ($child+".message") ($locator+".child");
			}
		}
*/
	//Make End loc for `child-less` locs, unless have a `otherChild` to make new child
	if (!`objExists $child` && !$isEnd)
		{
		$sca=`getAttr ($locator+".s")`;
		float $lenght=`getAttr ($locator+".sx")`*2*`getAttr FitSkeleton.sx`;
		$child=$locator+"End";
		$rotateOrder=`getAttr ($locator+".rotateOrder")`;
		asCreateLimbLoc $child {$pos[0],($pos[1]+$lenght),$pos[2]} {$sca[0],$sca[1],$sca[2]} $rotateOrder;
		connectAttr ($child+".message") ($locator+".child");
		if (`getAttr ($child+".tx")`==0)
			setAttr -l 1 ($child+".tx");

		$rebuild=1;
		$madeEndLoc=1;
		}

	//Name-match the End loc (the parent might have been renamed)
	if (`objExists $child`)
		if (`gmatch $child "*End"` && $child!=$locator+"End")
			rename $child ($locator+"End");

	//Rebuild RigBall
	if(!$isEnd)
		if (!`objExists ($locator+"Aim")` || $faultyMarkers[$i])
			$rebuild=1;

	if ($rebuild)
		{
		asFitModeCreateRigCyl $locator;
		if ($madeEndLoc)
			asStraightEndLoc $locator 0;
		}

	//Parenting (catching Markers that are been `real` parented)
	string $parentedLocs[]=`listRelatives -c -type transform $locator`;
	int $numParentedLocs=`size($tempString)`;
	string $parentedToLoc=$locator;//this will change if parented to a endLoc
	for ($y=0;$y<size($parentedLocs);$y++)
		{
		$tempString2=`listRelatives -s $parentedLocs[$y]`;
		if (!size($tempString2))
			continue;
		if (`objectType $tempString2[0]`!="locator")
			continue;
		string $parentedLocator=$parentedLocs[$y];
		if ($isEnd)
			$parentedToLoc=$parents[$i];
		$parentedLocatorPos=`xform -q -ws -t $parentedLocator`;
		$parentedLocatorPos[0]=`asRoundOff $parentedLocatorPos[0] 3`;
		int $txLocked=`getAttr -l ($parentedLocator+".tx")`;
		if ($txLocked) setAttr -l 0 ($parentedLocator+".tx");
		parent $parentedLocator Markers;
		if ($txLocked) setAttr -l 1 ($parentedLocator+".tx");
		int $alreadyParented=0;
		if (`attributeExists child $parentedToLoc`)
			if (`isConnected ($parentedLocator+".message") ($parentedToLoc+".child")`)
				$alreadyParented=1;
		int $numOtherChildren=`getAttr -size ($parentedToLoc+".otherChildren")`;
		for ($z=0;$z<$numOtherChildren;$z++)
			if (`isConnected ($parentedLocator+".message") ($parentedToLoc+".otherChildren["+$z+"]")`)
				$alreadyParented=1;
		if ($alreadyParented)
			continue;

		//Might have taken $parentedLocator from other parent, they now might need endLoc
		for ($z=0;$z<size($children);$z++)
			if ($parentedLocator==$children[$z])
				{
				deleteAttr ($markers[$z]+".child");
				asFitModeSelectionChanged;
				}

		//Continue Cylinder or CreateExtraChildVis
		$continueCyl=1;
		if ($pos[0]==0 && $parentedLocatorPos[0]!=0)//branch to side
			$continueCyl=0;
		if ($pos[0]!=0 && $parentedLocatorPos[0]==0)//back to middle(unusual but allowed)
			$continueCyl=0;
		if ($numParentedLocs>1)//More than 1 child
			$continueCyl=0;
		if (`attributeExists skipAim $parentedToLoc`)//.skipAim
				$continueCyl=0;
		$tempString=`listConnections -s 1 -d 0 ($parentedToLoc+".child")`;
		if (`attributeExists child $tempString[0]`)//Already have `Main` child
			$continueCyl=0;
		if ($continueCyl)
			{
			connectAttr -f ($parentedLocator+".message") ($parentedToLoc+".child");
			asFitModeCreateRigCyl $parentedToLoc;
			}
		else
			{
			//first remove all existing "otherChildren" connections (and delete old parenting annotations)
			$tempString =`listConnections -s 0 -d 1($parentedLocator+".message")`;
			$tempString2=`listConnections -s 0 -d 1 -p 1 ($parentedLocator+".message")`;
			for ($z=0;$z<size($tempString);$z++)
				if (`attributeExists otherChildren $tempString[$z]`)
					if (`isConnected ($parentedLocator+".message") $tempString2[$z]`)
						{
						disconnectAttr ($parentedLocator+".message") $tempString2[$z];
						if(`objExists ($tempString[$z]+"_"+$parentedLocator)`)
							delete ($tempString[$z]+"_"+$parentedLocator);
						}
			connectAttr -na ($parentedLocator+".message") ($parentedToLoc+".otherChildren");
			}
		}

	//Remove unused End Locators
	for ($z=0;$z<size($markers);$z++)
		if (!`attributeExists child $markers[$z]` && `objExists $markers[$z]`)
			{
			int $endLocIsChild=0;
			$tempString=`listConnections -p 1 ($markers[$z]+".message")`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] "*[.]child"`)
					$endLocIsChild=1;
			if (!$endLocIsChild)
				{
				delete $markers[$z];
				if (`objExists ($markers[$z]+"ParentConstraint")`)
					delete ($markers[$z]+"ParentConstraint");
				}
			}

	//CreateExtraChildVis for otherChildren
	if (`attributeExists otherChildren $parentedToLoc`)
		{
		string $otherChildren[]=`listConnections ($parentedToLoc+".otherChildren")`;
		for ($z=0;$z<size($otherChildren);$z++)
			if (!`objExists ($parentedToLoc+"_"+$otherChildren[$z])`)
				if (`objExists ($otherChildren[$z]+"Aim")`)
					asFitModeCreateExtraChildVis $otherChildren[$z] $parentedToLoc;
		}

	//Ensure locators have parentConstraint in Hierarchy mode
//	print ($markers[$i]+"\n");
	if ($asFitModeHierarchy)
		{
		$tempString =`listRelatives -p $locator`;
		if ($tempString[0]=="Markers")
			asCreateHierarchyConstraint $locator;
		}
	}

//look for newly created (from duplication)
string $selObjects[]=`ls -sl -o -l`;
for ($i=0;$i<size($selObjects);$i++)
	{
	if (`attributeExists child $selObjects[$i]` && `attributeExists child $selObjects[$i]`)
		{
		$connections=`listConnections -s 1 -d 0 ($selObjects[$i]+".child")`;
		$child=$connections[0];
		if($child=="")
			asFitModeDuplicate $selObjects[$i] $asFitModePreviousSelected;
		}
	}

//System checks (remove non name-matching Direction & Surfaces)
for ($i=0;$i<size($vizDirections);$i++)
	{
	if ($vizDirections[$i]=="DirectionFront")
		continue;
	if (!`objExists $vizDirections[$i]`)
		continue;
	string $systemFromDirection=`substitute "OffsetA" $vizDirections[$i] ""`;
	$systemFromDirection=`substitute "Direction" $systemFromDirection ""`;
	if (!`stringArrayCount $systemFromDirection $systems`)
		delete $vizDirections[$i];
	}
for ($i=0;$i<size($vizSurfaces);$i++)
	{
	string $systemFromSurface=`substitute "Surface" $vizSurfaces[$i] ""`;
	if (!`stringArrayCount $systemFromSurface $systems`)
		delete $vizSurfaces[$i];
	}
//cleanup left-behind annotations
string $anns[]=`ls -type annotationShape`;
for ($i=0;$i<size($anns);$i++)
	{
	$tempString=`listConnections ($anns[$i]+".dagObjectMatrix[0]")`;
	if ($tempString[0]=="")
		delete `listRelatives -p $anns[$i]`;
	}

$asFitModePreviousSelected=$sel;
catchQuiet(`select $sel`);
}

global proc asCreateHierarchyConstraint (string $marker)
{
createNode -n ($marker+"ParentConstraint") -p Markers transform;
string $tempString[]=`listConnections -s 0 -d 1 ($marker+".message")`;
string $tempString2[]=`listConnections -s 0 -d 1 -p 1 ($marker+".message")`;
string $parent;
for ($y=0;$y<size($tempString);$y++)
	if (`gmatch $tempString2[$y] "*[.]child"` || `gmatch $tempString2[$y] "*[.]otherChildren*"`)
		$parent=$tempString[$y];
if (`objExists $parent`)
	{
	parentConstraint $parent ($marker+"ParentConstraint");
//	scaleConstraint $parent ($marker+"ParentConstraint");
	}
else
	delete `parentConstraint Root ($marker+"ParentConstraint")`;
parent $marker ($marker+"ParentConstraint");
}

global proc string asGetMarkerSystem (string $marker)
{
string $ms;
string $parentStartInSystem="";
string $childEndInSystem="";
string $tempString[],$tempString2[];
int $foundParent;

$tempString=`listConnections ($marker+".message")`;
$tempString2=`listConnections -p 1 ($marker+".message")`;
for ($y=0;$y<size($tempString);$y++)
	if (`gmatch $tempString2[$y] "*[.]start"` || `gmatch $tempString2[$y] "*[.]mid"` || `gmatch $tempString2[$y] "*[.]end"`
	 || `gmatch $tempString2[$y] "*[.]endEnd"` || `gmatch $tempString2[$y] "*[.]toes"` || `gmatch $tempString2[$y] "*[.]toesEnd"`
	 || `gmatch $tempString2[$y] "*[.]scapula"`)
		$ms=`substitute "System" $tempString[$y] ""`;
if ($ms!="")
	return $ms;
string $parent=$marker;

while($parent!="Root")
	{
	if ($parent=="") break;
	$tempString=`listConnections ($parent+".message")`;
	$tempString2=`listConnections -p 1 ($parent+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$foundParent=0;
		if (`gmatch $tempString2[$y] "*[.]child"`)
			{
			$parent=$tempString[$y];
			$foundParent=1;
			break;
			}
		}
	if(!$foundParent) break;
	$tempString=`listConnections ($parent+".message")`;
	$tempString2=`listConnections -p 1 ($parent+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString2[$y] "*[.]start"`)
			{
			$parentStartInSystem=$tempString[$y];
			break;
			}
		}
	}

$child=$marker;
while($child!="")
	{
	if(!`attributeExists child $child`)
		break;
	$tempString=`listConnections ($child+".child")`;
	$child=$tempString[0];
	if ($child=="") break;
	$tempString=`listConnections ($child+".message")`;
	$tempString2=`listConnections -p 1 ($child+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString2[$y] "*[.]end"`)
			{
			$childEndInSystem=$tempString[$y];
			break;
			}
		}
	}

if ($parentStartInSystem==$childEndInSystem)
	if ($ms=="")
		$ms=`substitute "System" $parentStartInSystem ""`;

return $ms;
}

global proc asFitModeCreateRigCyl (string $locator)
{
global int $asFitModeHierarchy;
asFitModeEnsureShaders;
string $tempString[]=`listRelatives -c -type transform $locator`;
if (size($tempString))
	delete $tempString;
if (`objExists ($locator+"Aim")`)
	delete ($locator+"Aim");
createNode -n ($locator+"Aim") -p Aims transform;

int $twists=`getAttr ($locator+".twists")`;
string $box,$cyl,$part;
string $ms=`asGetMarkerSystem $locator`;
string $geoObjs[];
for ($i=0;$i<$twists+1;$i++)
	{
	$part="";
	if ($i>0)
		$part="Part"+$i;
	createNode -n ($locator+$part+"Geo") -p ($locator+"Aim") transform;
	if (`objExists ($locator+"End")`)
	if (!`getAttr ($locator+"End.v")`)
		setAttr -l 1 ($locator+$part+"Geo.v") 0;

	//box
	$tempString=`polyCube -n ($locator+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$box=$tempString[0];
	$geoObjs[size($geoObjs)]=$box;
	move -r 0 0.5 0 ($box+".vtx[0:7] ");
	sets -e -forceElement asRedSG ($box+".f[1]");
	sets -e -forceElement asRed2SG ($box+".f[3]");
	sets -e -forceElement asGreenSG ($box+".f[5]");
	sets -e -forceElement asGreen2SG ($box+".f[4]");
	sets -e -forceElement asBlueSG ($box+".f[0]");
	sets -e -forceElement asBlue2SG ($box+".f[2]");
	connectAttr FitSkeleton.visBoxes ($box+".v");
	connectAttr FitSkeleton.visGeo ($box+".lodVisibility");
	setAttr ($box+"Shape.overrideEnabled") 1;
	if (`optionVar -q asSelectableGeo`==0)
		setAttr ($box+"Shape.overrideDisplayType") 2;
	parent $box ($locator+$part+"Geo");
	setAttr -type float3 ($box+".s") 1 1 1;
	
	//cylinder
	$tempString=`cylinder -n ($locator+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
	$cyl=$tempString[0];
	$geoObjs[size($geoObjs)]=$cyl;
	move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
	sets -e -forceElement asBlueSG ($cyl+".sf[0][1:2]");
	sets -e -forceElement asGreenSG ($cyl+".sf[0][3:4]");
	sets -e -forceElement asBlue2SG ($cyl+".sf[0][5:6]");
	sets -e -forceElement asGreen2SG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");
	connectAttr FitSkeleton.visCylinders ($cyl+".v");
	connectAttr FitSkeleton.visGeo ($cyl+".lodVisibility");
	setAttr ($cyl+"Shape.overrideEnabled") 1;
	if (`optionVar -q asSelectableGeo`==0)
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
	parent $cyl ($locator+$part+"Geo");
	setAttr -type float3 ($cyl+".s") 1 1 1;
	}

pointConstraint $locator ($locator+"Aim");
if (!$asFitModeHierarchy)
	{
	$tempString=`orientConstraint ($locator+"Aim") $locator`;
	setAttr ($tempString[0]+".lockOutput") 1;
	string $orientConstraint=$tempString[0];
	parent $orientConstraint ($locator+"Aim");
	if (`objExists ($locator+"End")`)
		{
		$tempString=`orientConstraint ($locator+"Aim") ($locator+"End")`;
		setAttr ($tempString[0]+".lockOutput") 1;
		string $orientConstraint=$tempString[0];
		parent $orientConstraint ($locator+"Aim");
		}
	}

xform -os -s 1 1 1 ($locator+"Aim");
string $connections[]=`listConnections -s 1 -d 0 ($locator+".child")`;
string $child=$connections[0];
int $aimV[3],$upV[3];
int $lenghtAxisNr=`getAttr FitSkeleton.axisLenght`;
if ($lenghtAxisNr==0) $aimV={1,0,0};
if ($lenghtAxisNr==1) $aimV={0,1,0};
if ($lenghtAxisNr==2) $aimV={0,0,1};
int $frontAxisNr=`getAttr FitSkeleton.axisFront`;
if ($frontAxisNr==0) $upV={1,0,0};
if ($frontAxisNr==1) $upV={0,1,0};
if ($frontAxisNr==2) $upV={0,0,1};
if ($lenghtAxisNr==$frontAxisNr) // this should not happen
	{
	setAttr FitSkeleton.axisLenght 0;
	setAttr FitSkeleton.axisFront 1;
	}
for ($i=0;$i<$twists+1;$i++)
	{
	$part="";
	if ($i>0)
		$part="Part"+$i;

	if ($lenghtAxisNr==0 && $frontAxisNr==1){setAttr ($locator+$part+"Geo"+".rz") -90;};
	if ($lenghtAxisNr==0 && $frontAxisNr==2){setAttr ($locator+$part+"Geo"+".rz") -90;setAttr ($locator+$part+"Geo"+".ry") 90;};
	if ($lenghtAxisNr==1 && $frontAxisNr==0){setAttr ($locator+$part+"Geo"+".ry") 180;};
	if ($lenghtAxisNr==1 && $frontAxisNr==2){setAttr ($locator+$part+"Geo"+".ry") 90;};
	if ($lenghtAxisNr==2 && $frontAxisNr==0){setAttr ($locator+$part+"Geo"+".rx") 90;setAttr ($locator+$part+"Geo"+".rz") 180;};
	if ($lenghtAxisNr==2 && $frontAxisNr==1){setAttr ($locator+$part+"Geo"+".rx") 90;setAttr ($locator+$part+"Geo"+".rz") -90;};
	}

//Flip upVec for some Limbs, to make them `point forward`
if (`gmatch $locator "*Elbow*"` || `gmatch $locator "*Shoulder*"` || `gmatch $locator "*Wrist*"`)
	{$upV[0]*=-1;$upV[1]*=-1;$upV[2]*=-1;}
//if (`gmatch $locator "*Finger*"` || `gmatch $locator "*Toe*"`)
if (`gmatch $locator "*Finger*"`)
	{
	if ($lenghtAxisNr==0 && $frontAxisNr==1) $upV={0,0,-1};
	if ($lenghtAxisNr==0 && $frontAxisNr==2) $upV={0,1,0};
	if ($lenghtAxisNr==1 && $frontAxisNr==0) $upV={0,0,1};
	if ($lenghtAxisNr==1 && $frontAxisNr==2) $upV={-1,0,0};
	if ($lenghtAxisNr==2 && $frontAxisNr==0) $upV={0,-1,0};
	if ($lenghtAxisNr==2 && $frontAxisNr==1) $upV={1,0,0};
	}

string $worldUpObject;
clear $tempString;
if (`attributeExists worldUpObject $locator`)
	$tempString=`listConnections -s 1 -d 0 ($locator+".worldUpObject")`;
for ($i=0;$i<size($tempString);$i++)
	$worldUpObject=$tempString[$i];

if (`attributeExists dirFlip ($ms+"System")`)
	if (`getAttr ($ms+"System.dirFlip")`)
		//skip if worldUpObject !Direction*  e.g skip Ankle
		if (`gmatch $tempString[0] "*Direction*"`)
			{$upV[0]*=-1;$upV[1]*=-1;$upV[2]*=-1;}

if (`objExists $worldUpObject`)
	aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV[0] $upV[1] $upV[2]
		-worldUpType "object" -worldUpObject $worldUpObject $child ($locator+"Aim");
else
	aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV[0] $upV[1] $upV[2]
		-worldUpType "scene" $child ($locator+"Aim");

connectAttr ($locator+"Aim.r") ($locator+".rot");
connectAttr ($locator+".rotateOrder") ($locator+"Aim.rotateOrder");

//$tempString=`orientConstraint ($locator+"Aim") $child`;
//setAttr ($tempString[0]+".lockOutput") 1;
//select $tempString[0] $child;
//parent $tempString[0] ($locator+"Aim");

//annotation arrow
//print ($locator+" : "+$worldUpObject+":"+`objExists $worldUpObject`+"\n");
if (`objExists $worldUpObject`)
	{
	$tempString[0]=`createNode annotationShape`;
	$tempString=`listRelatives -p $tempString[0]`;
	string $direction=`rename $tempString[0] ($locator+"Direction")`;
	setAttr ($direction+"Shape.overrideEnabled") 1;
	setAttr ($direction+"Shape.overrideDisplayType") 1;
	if ($worldUpObject=="DirectionFront")
		connectAttr FitSkeleton.visDirectionFront ($direction+".v");
	else
		connectAttr FitSkeleton.visDirections ($direction+".v");
	parent $direction ($locator+"Aim");
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
	connectAttr ($worldUpObject+"Shape.worldMatrix[0]") ($locator+"DirectionShape.dagObjectMatrix[0]");
	}

//Flare
select $geoObjs;
$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
string $flare=`rename $tempString[0] ($locator+"Flare")`;
string $flareHandle=`rename $tempString[1]  ($locator+"FlareHandle")`;
parent $flareHandle ($locator+"Aim");
setAttr -type float3 ($flareHandle+".s") 1 1 1;
setAttr -type float3 ($flareHandle+".t") 0 0 0;
setAttr -type float3 ($flareHandle+".r") 0 0 -90;
delete `pointConstraint $locator $flareHandle`;
setAttr -l 1 ($flareHandle+".v") 0;
string $s1,$s2,$d1,$d2;
if ($lenghtAxisNr==0 && $frontAxisNr==1){$s1="y";$d1="X";$s2="z";$d2="Z";}
if ($lenghtAxisNr==0 && $frontAxisNr==2){$s1="y";$d1="Z";$s2="z";$d2="X";}
if ($lenghtAxisNr==1 && $frontAxisNr==0){$s1="x";$d1="X";$s2="z";$d2="Z";}
if ($lenghtAxisNr==1 && $frontAxisNr==2){$s1="x";$d1="Z";$s2="z";$d2="X";}
if ($lenghtAxisNr==2 && $frontAxisNr==0){$s1="x";$d1="X";$s2="y";$d2="Z";}
if ($lenghtAxisNr==2 && $frontAxisNr==1){$s1="x";$d1="Z";$s2="y";$d2="X";}

connectAttr ($locator+".s"+$s1) ($flare+".startFlare"+$d1);
connectAttr ($locator+".s"+$s2) ($flare+".startFlare"+$d2);

//Gap
string $gapBlenderA=`createNode -n ($locator+"GapBlenderA") blendTwoAttr`;
string $gapBlenderB=`createNode -n ($locator+"GapBlenderB") blendTwoAttr`;
connectAttr FitSkeleton.visGap ($gapBlenderA+".attributesBlender");
connectAttr FitSkeleton.visGap ($gapBlenderB+".attributesBlender");
connectAttr ($locator+".s"+$s1) ($gapBlenderA+".input[0]");
connectAttr ($locator+".s"+$s2) ($gapBlenderB+".input[0]");
connectAttr ($child+".s"+$s1) ($gapBlenderA+".input[1]");
connectAttr ($child+".s"+$s2) ($gapBlenderB+".input[1]");
connectAttr ($gapBlenderA+".output") ($flare+".endFlare"+$d1);
connectAttr ($gapBlenderB+".output") ($flare+".endFlare"+$d2);

//Distance
createNode -n ($locator+"Distance") distanceBetween;
connectAttr ($locator+".worldMatrix[0]") ($locator+"Distance.inMatrix1");
connectAttr ($child+".worldMatrix[0]") ($locator+"Distance.inMatrix2");
createNode -n ($locator+"ScaleYMultiDiv1") multiplyDivide;
setAttr ($locator+"ScaleYMultiDiv1.operation") 2;
connectAttr ($locator+"Distance.distance") ($locator+"ScaleYMultiDiv1.input1Y");
connectAttr FitSkeleton.sx ($locator+"ScaleYMultiDiv1.input2Y");
createNode -n ($locator+"ScaleYMultiDiv2") multiplyDivide;
connectAttr ($locator+"ScaleYMultiDiv1.outputY") ($locator+"ScaleYMultiDiv2.input1Y");
connectAttr FitSkeleton.visGap ($locator+"ScaleYMultiDiv2.input2Y");
createNode -n ($locator+"ScaleYMultiDiv3") multiplyDivide;
connectAttr ($locator+"ScaleYMultiDiv2.outputY") ($locator+"ScaleYMultiDiv3.input1Y");
setAttr ($locator+"ScaleYMultiDiv3.operation") 2;
setAttr ($locator+"ScaleYMultiDiv3.input2Y") ($twists+1);

//twists
for ($i=0;$i<$twists+1;$i++)
	{
	$part="";
	if ($i>0)
		{
		$part="Part"+$i;
		createNode -n ($locator+"ScaleYMultiDiv4_"+$i) multiplyDivide;
		connectAttr ($locator+"ScaleYMultiDiv1.outputY") ($locator+"ScaleYMultiDiv4_"+$i+".input1Y");
		setAttr ($locator+"ScaleYMultiDiv4_"+$i+".input2Y") ($i*(1.0/($twists+1)));
		connectAttr ($locator+"ScaleYMultiDiv4_"+$i+".outputY") ($locator+$part+"Geo"+".tx");	
		}
	connectAttr ($locator+"ScaleYMultiDiv3.outputY") ($locator+$part+"Geo"+".sy");
	}

connectAttr ($locator+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");
}

global proc asFitModeCreateExtraChildVis (string $parentedLocator, string $locator)
{
string $tempString[];
$tempString[0]=`createNode annotationShape`;
$tempString=`listRelatives -p $tempString[0]`;
string $extraChildVis=$tempString[0];
$extraChildVis=`rename $extraChildVis ($locator+"_"+$parentedLocator)`;
$tempString=`parent $extraChildVis Visualizers`;
$extraChildVis=$tempString[0];
$tempString=`listRelatives -s $extraChildVis`;
string $extraChildVisShape=$tempString[0];
$extraChildVisShape=`rename $extraChildVisShape ($extraChildVis+"Shape")`;
setAttr ($extraChildVis+"Shape.overrideEnabled") 1;
setAttr ($extraChildVis+"Shape.overrideDisplayType") 1;
parent $extraChildVis ($locator+"Aim");
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $extraChildVis;
//connectAttr ($locator+".t") ($extraChildVis+".t");
$tempString=`listRelatives -s $parentedLocator`;
string $parentedLocatorShape=$tempString[0];
//remove any existing $extraChildVis
$tempString=`listConnections -sh 1 ($parentedLocatorShape+".worldMatrix[0]")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="annotationShape")
		delete $tempString[$i];
connectAttr ($parentedLocatorShape+".worldMatrix[0]") ($extraChildVisShape+".dagObjectMatrix[0]");
//addAttr -ln parent -at "message" $parentedLocator;
//connectAttr ($locator+".message") ($parentedLocator+".parent");
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack"};
float $rs[]={1,1,0,1,0,0,1,0};
float $gs[]={0,0,1,1,0,1,1,0};
float $bs[]={0,1,0,0,1,1,1,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFitModeDuplicate (string $new, string $old[])
{
print ("// Duplicate "+$new+" from "+$old[0]+";\n");
}

global proc string[] asGetMarkers ()
{
string $markers[],$tempString[];
if (`objExists Markers`)
	$tempString=`listRelatives -ad -type transform Markers`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $tempString2[]=`listRelatives -s $tempString[$i]`;
	if (size($tempString2))
		if (`objectType $tempString2[0]`=="locator")
			$markers[size($markers)]=$tempString[$i];
	}
return $markers;
}

global proc string[] asGetMarkersSorted ()
{
string $markers[],$tempString[],$sortedMarkers[];
if (`objExists Markers`)
	$tempString=`listRelatives -ad -type transform Markers`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $tempString2[]=`listRelatives -s $tempString[$i]`;
	if (size($tempString2))
		if (`objectType $tempString2[0]`=="locator")
			$markers[size($markers)]=$tempString[$i];
	}
//Preferred sorting
//start root, and it`s systemMarkers
if (`stringArrayCount "Root" $markers`)
	{
	$sortedMarkers[size($sortedMarkers)]="Root";
	$tempString=`listConnections Root.message`;
	if (`gmatch $tempString[0] "*System"`)
		{
		$tempString=`asGetSystemMarkers $tempString[0]`;
		for ($i=size($tempString)-1;$i>-1;$i--)
			if (!`stringArrayCount $tempString[$i] $sortedMarkers`)
				$sortedMarkers[size($sortedMarkers)]=$tempString[$i];
		}
	}
//next _middle markers, and their systemMarkers
for ($i=0;$i<size($markers);$i++)
	{
	if (`getAttr ($markers[$i]+".tx")`>-0.001)
		{
		if (!`stringArrayCount $markers[$i] $sortedMarkers`)
			{
			//first if in System, order system-wise
			$tempString=`listConnections ($markers[$i]+".message")`;
			if (`gmatch $tempString[0] "*System"`)
				{
				$tempString=`asGetSystemMarkers $tempString[0]`;
				for ($y=size($tempString)-1;$y>-1;$y--)
					if (!`stringArrayCount $tempString[$y] $sortedMarkers`)
						$sortedMarkers[size($sortedMarkers)]=$tempString[$y];
				}
			//else `system-less` middlemarkers
			if (!`stringArrayCount $markers[$i] $sortedMarkers`)
				$sortedMarkers[size($sortedMarkers)]=$markers[$i];			
			}
		}
	}
//next scapulas, and their systemMarkers
for ($i=0;$i<size($markers);$i++)
	if (`gmatch $markers[$i] "Scapula*"`)
		if (!`stringArrayCount $markers[$i] $sortedMarkers`)
			{
			$sortedMarkers[size($sortedMarkers)]=$markers[$i];
			$tempString=`listConnections ($markers[$i]+".message")`;
			if (`gmatch $tempString[0] "*System"`)
				{
				$tempString=`asGetSystemMarkers $tempString[0]`;
				for ($y=size($tempString)-1;$y>-1;$y--)
					if (!`stringArrayCount $tempString[$y] $sortedMarkers`)
						$sortedMarkers[size($sortedMarkers)]=$tempString[$y];
				}
			}
			
//next the rest, by their systemMarkers
for ($i=0;$i<size($markers);$i++)
	{
	if (!`stringArrayCount $markers[$i] $sortedMarkers`)
		{
			$tempString=`listConnections ($markers[$i]+".message")`;
			if (`gmatch $tempString[0] "*System"`)
				{
				$tempString=`asGetSystemMarkers $tempString[0]`;
				for ($y=size($tempString)-1;$y>-1;$y--)
					if (!`stringArrayCount $tempString[$y] $sortedMarkers`)
						$sortedMarkers[size($sortedMarkers)]=$tempString[$y];
				}
		}
	}
//next the rest , even non-system markers
for ($i=0;$i<size($markers);$i++)
	{
	if (!`stringArrayCount $markers[$i] $sortedMarkers`)
		$sortedMarkers[size($sortedMarkers)]=$markers[$i];
	}
return $sortedMarkers;
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*End_?"`)
		select -d $sel[$i];
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 0
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeleton4Files/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
if (!`gmatch $fkControl "FK*"`)
	error "No FK control selected";
float $pos[];
float $scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

string $deformJoint=`substitute "FK" $fkControl ""`;
if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asDeleteCutUp ()
{
delete `listConnections CutUp.drawInfo`;
delete CutUp;
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
sets -em -n SkinLoopSpine;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			duplicate -n ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if (!$haveSkinCluster)
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;
		for ($x=1;$x<99;$x++)
			{
			tokenize $deformJoints[$y] "_" $tempString;
			if (`objExists ($tempString[0]+"Part"+$x+"_"+$tempString[1])`)
				$twistJoints[$y]=$x;
			else
				break;
			}
		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;
		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					}
				refresh;
				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						{
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
						if (`gmatch $deformJoints[$y] "Spine[1-9]*"` || $deformJoints[$y]=="Chest_M" || $deformJoints[$y]=="Root_M")
							sets -add SkinLoopSpine `ls -sl`;
						}
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					duplicate -n $cutName $sel[$i];
					asLockAttr $cutName 0 0 0 0;
					$tempString2=`listRelatives -s $cutName`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					
					parent $cutName $deformJoints[$y];
					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					InvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;

						parent $cutName $deformJoints[$y];
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}
	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
			select -d $tempString2;
			weightHammerVerts;
			}
		//Extra hammer Spine
		select SkinLoopSpine;
		$tempString=`ls -sl`;
		if (size($tempString))
			weightHammerVerts;
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted SkinLoopSpine;
select -cl;
catchQuiet (`select $sel`);
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose ()
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
string $m;
string $deformJointsList[]=`sets -q DeformSet`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
			$numNonDef++;
			}
		if ($numNonDef>$maxTextLines)
			{
			$m+="...And more..\n\n";
			$y=999;
			$i=999;
			}
		}
if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed" || $dialog=="Just Proceed")
		$proceed=1;
	else
		$proceed=0;
	}
return $proceed;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asCreateSkeleton ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists SkeletonGeometry`)
	error "SkeletonGeometry already exists";
createNode -n SkeletonGeometry transform;
parent SkeletonGeometry Geometry;
if (!`objExists Skeleton`)
	{
	createDisplayLayer -e -name Skeleton;
	setAttr Skeleton.color 2;
	setAttr Skeleton.displayType 2;
	editDisplayLayerMembers -noRecurse Skeleton SkeletonGeometry;
	}
float $charHeight=`asgetCharHeight`;
//work off height to Root, morefair considering quadpeds
float $pos[]=`xform -q -ws -t Root`;
$charHeight=$pos[1]*2;
float $scalar=7.0;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
string $poly;
float $temp[],$temp2[];
int $sideFactor;
vector $childVec;
string $boneSkipJoints[]={"Spine*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*","*Hip_*","Neck_*",
	"*Elbow_*","*Finger[0-9]*","*Wrist*","*Cup*","*Ankle*","*Toe*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton4Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

string $bones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($bones);$i++)
	{
	setAttr -type float3 ($bones[$i]+".s") ($charHeight/$scalar) ($charHeight/$scalar) ($charHeight/$scalar);
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $bones[$i]`);
	}

parent Skeleton_Pelvis SkeletonGeometry;
parentConstraint Root_M Skeleton_Pelvis;
scaleConstraint Root_M Skeleton_Pelvis;

if (`objExists Head_M`)
	{
	parent Skeleton_Skull SkeletonGeometry;
	parentConstraint Head_M Skeleton_Skull;
	scaleConstraint Head_M Skeleton_Skull;
	}
if (`objExists Jaw_M`)
	{
	parent Skeleton_Jaw SkeletonGeometry;
	parentConstraint Jaw_M Skeleton_Jaw;
	scaleConstraint Jaw_M Skeleton_Jaw;;
	}
/*
else
	{
	parent Skeleton_Jaw SkeletonGeometry;
	parentConstraint Head_M Skeleton_Jaw;
	scaleConstraint Head_M Skeleton_Jaw;;
	}
*/
for ($i=0;$i<size($deformJointsList);$i++)
	{
	refresh;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($children))
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	$childJoint=$children[0];
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}

	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	if (`gmatch $deformJointsList[$i] "*Hip_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Femur`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
		setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		//and repos pelvis (if !scapula)
		$tempString=`listRelatives -p $deformJointsList[$i]`;
		if (!`gmatch $tempString[0] "Scapula*"`)
			{
			delete Skeleton_Pelvis_parentConstraint1;
			float $pos[]=`xform -q -ws -t $deformJointsList[$i]`;
			xform -ws -t 0 $pos[1] $pos[2] Skeleton_Pelvis;
			parentConstraint -mo Root_M Skeleton_Pelvis;
			}
		}
	if (`gmatch $deformJointsList[$i] "*Elbow_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Forearm`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
		setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Finger[0-9]*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Digit`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
		setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Ankle`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
		$temp=`xform -q -ws -t $deformJointsList[$i]`;
		$temp2=`xform -q -ws -t $childJoint`;
		$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
		setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
		setAttr ($poly+".sy") (1.2/($charHeight/$scalar)*$lenght);
		delete `parentConstraint $deformJointsList[$i] $poly`;
		setAttr ($poly+".ty") 0;
		parentConstraint -mo $deformJointsList[$i] $poly;
		
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Toe*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_MiddleToe`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
//		$tempString=`listRelatives -p -type joint $deformJointsList[$i]`;
//		$temp=`xform -q -ws -t $tempString[0]`;
//		setAttr ($poly+".sx") $temp[1];
		delete `parentConstraint $deformJointsList[$i] $poly`;
		setAttr ($poly+".ty") 0;
		setAttr ($poly+".sy") (1.2/($charHeight/$scalar)*$lenght);
		parentConstraint -mo $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		}

	if (`gmatch $deformJointsList[$i] "*Wrist*"`)
		{
		$children=`listRelatives -c -type joint $deformJointsList[$i]`;
		if (`stringArrayCount "Cup_R" $children`)
			{
			$tempString=`listRelatives -c -type joint Cup_R`;
			$children=`stringArrayCatenate $children $tempString`;
			}
		if (`stringArrayCount "Cup_L" $children`)
			{
			$tempString=`listRelatives -c -type joint Cup_L`;
			$children=`stringArrayCatenate $children $tempString`;
			}
		for ($y=0;$y<size($children);$y++)
			{
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone"+$y) Skeleton_Digit`;
			$poly=$tempString[0];
			parent $poly SkeletonGeometry;
			pointConstraint $deformJointsList[$i] $poly;
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $deformJointsList[$i] $children[$y] $poly;
			$temp=`xform -q -ws -t $deformJointsList[$i]`;
			$temp2=`xform -q -ws -t $children[$y]`;
			$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
			setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
			catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
			scaleConstraint $deformJointsList[$i] $poly;
			}
		}
	int $skipMe=0;
	for ($y=0;$y<size($boneSkipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $boneSkipJoints[$y]`)
			$skipMe=1;

	if (!$skipMe)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Bone`;
		$poly=$tempString[0];
		parent $poly SkeletonGeometry;
		setAttr ($poly+".sx") (1.0/($charHeight/$scalar)*$lenght);
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			{
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($deformJointsList[$i]+"_Bone");
			}
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($deformJointsList[$i]+"_BoneShape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	}

//Spine
int $foundHeadToRoot=1;
string $parent="Head_M";
string $parents[];
string $headToRoots[]={$parent};
if (`objExists Head_M`)
	for ($i=0;$i<99;$i++)
		{
		$parents=`listRelatives -parent -type joint $parent`;
		if(size($parents)==0)
			break;
		$parent=$parents[0];
		$headToRoots[size($headToRoots)]=$parent;
		if ($parent=="Root_M")
			{
			$foundHeadToRoot=1;
			break;
			}
		}

//Neck
int $foundHeadToChest=1;
string $parent="Head_M";
string $parents[];
string $headToChests[]={$parent};
if (`objExists Head_M` && `objExists Chest_M`)
	for ($i=0;$i<99;$i++)
		{
		$parents=`listRelatives -parent -type joint $parent`;
		if(size($parents)==0)
			break;
		$parent=$parents[0];
		$headToChests[size($headToChests)]=$parent;
		if ($parent=="Chest_M")
			{
			$foundHeadToChest=1;
			break;
			}
		}

if (`objExists Root_M` && `objExists Neck_M` && `objExists Head_M` && $foundHeadToRoot)
	{
	parent Skeleton_Spine SkeletonGeometry;
//	delete `pointConstraint Root_M Skeleton_Spine`;
	float $pos[]=`xform -q -ws -t Skeleton_PelvisShape.vtx[1462]`;
	xform -ws -t 0 $pos[1] $pos[2] Skeleton_Spine;
	if(`objExists Neck_M`)
		delete `orientConstraint Root_M Skeleton_Spine`;
	$temp=`xform -q -ws -t Skeleton_Spine`;
	$temp2=`xform -q -ws -t Neck_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Spine.sx (1.0/($charHeight/$scalar)*$lenght);
	select $headToRoots;
	select -add Skeleton_Spine;
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
if (`objExists Neck_M` && `objExists Head_M` && $foundHeadToChest)
	{
	parent Skeleton_Neck SkeletonGeometry;
	delete `parentConstraint Neck_M Skeleton_Neck`;
	$temp=`xform -q -ws -t Neck_M`;
	$temp2=`xform -q -ws -t Head_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Neck.sx (1.2/($charHeight/$scalar)*$lenght);
	select $headToChests;
	select -add Skeleton_Neck;
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
if (`objExists Root_M` && `objExists Chest_M`)
	{
	parent Skeleton_Ribs SkeletonGeometry;
	$temp=`xform -q -ws -t Root_M`;
	$temp2=`xform -q -ws -t Chest_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Ribs.sx (1.0/($charHeight/$scalar)*$lenght);
	//hacky way to see if it`s a quadped, in which case cons to parent of "Chest_M"
	$temp=`xform -q -ws -ro Chest_M`;
	$tempString=`listRelatives -type joint -p Chest_M`;
	if ($temp[1]<-45)
		parentConstraint $tempString[0] Skeleton_Ribs;
	else
		parentConstraint Chest_M Skeleton_Ribs;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 Skeleton_Ribs`);
	scaleConstraint Chest_M Skeleton_Ribs;
	}

//include twist, if exists
for ($i=0;$i<size($deformJointsList);$i++)
	{
	tokenize $deformJointsList[$i] "_" $tempString;
	if (`objExists ($tempString[0]+"Part1_"+$tempString[1])`)
		if (`objExists ($deformJointsList[$i]+"_Bone_parentConstraint1")`)
			{
			for ($y=99;$y>-1;$y--)
				{
				string $twister="Twister"+$tempString[0]+$y+"_"+$tempString[1];
				if (`objExists $twister`)
					{
					connectAttr ($twister+".rx") ($deformJointsList[$i]+"_Bone_parentConstraint1.target[0].targetOffsetRotateX");
					break;
					}
				}
			}
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
string $deleteObjs[]={"wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (!`objExists MannequinGeometry`)
		if (`objExists $deleteObjs[$i]`)
			delete $deleteObjs[$i];


print ("Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","Skeleton_Geometry","Skeleton"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreatePolyBoxes ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`objExists BoxesGeometry`)
	error "\"BoxesGeometry\" Alread exists";
if (`objExists PolyBoxes`)
	error "\"PolyBoxes\" Alread exists";
if (!`objExists BoxesGeometry`)
	createNode -n BoxesGeometry -p Geometry transform;
if (!`objExists PolyBoxes`)
	{
	createDisplayLayer -e -name "PolyBoxes";
	setAttr PolyBoxes.color 14;
	}
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
int $isInFitMode=`getAttr FitSkeleton.v`;
int $visGeo=`getAttr FitSkeleton.visGeo`;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
if (!$isInFitMode)
	asToggleFitMode;
setAttr FitSkeleton.visGeo 1;
setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh; 

//setAttr FitSkeleton.visGeo 0;
string $locator;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] "*Box*"`)
		{
		$locator=`substitute "Box" $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($locator+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse PolyBoxes ($aimsAD[$i]+$side);
//			sets -e -forceElement initialShadingGroup ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
//			setAttr ($aimsAD[$i]+$side+".doubleSided") 0;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
//				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p BoxesGeometry transform;
			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;
			parentConstraint -mo ($locator+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			scaleConstraint  -mo ($locator+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
			refresh;
			}
		}
setAttr FitSkeleton.visGeo $visGeo;
setAttr FitSkeleton.visGap $visGap;
if (!$isInFitMode)
	asToggleFitMode;
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}


string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".visibility") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] $bool;
		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
			parent $bool $joint;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Bool`)
	delete Bool;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//round ends
/*
		select ($warpBox+".vtx[25]") ($warpBox+".vtx[70:73]") ($warpBox+".vtx[94:97]");
		polyAverageVertex -i 10 -ch 0;polyAverageVertex -i 10 -ch 0;
		if (!`gmatch $warpBox "Ankle*"`)
			move -r -os -wd (`getAttr ($warpBox+".sz")`*-0.5*$sideFactor) 0 0 ;
		polyAverageVertex -i 10 -ch 0;
		select ($warpBox+".vtx[24]") ($warpBox+".vtx[66:69]") ($warpBox+".vtx[90:93]");
		polyAverageVertex -i 10 -ch 0;polyAverageVertex -i 10 -ch 0;
		if (!`gmatch $warpBox "Ankle*"` && !$isEndJoint)
			move -r -os -wd (`getAttr ($warpBox+".sz")`*0.5*$sideFactor) 0 0 ;
		polyAverageVertex -i 10 -ch 0;
		select $warpBox;
		DeleteHistory;
*/
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Warp`)
	delete Warp;
}

global proc asCreateMannequin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}
float $charHeight=`asgetCharHeight`;

string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton4Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`objExists ($deformJointsList[$i]+"_Ball")`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($children))
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	$childJoint=$children[0];
	if ($deformJointsList[$i]=="Chest_M")
		if (`stringArrayCount "Neck_M" $children`)
			$childJoint="Neck_M";
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "Spine[0-9]*"` || `gmatch $deformJointsList[$i] "Chest*"` || `gmatch $deformJointsList[$i] "Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
		parentConstraint $deformJointsList[$i] $poly;
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		scaleConstraint $deformJointsList[$i] $poly;
		refresh;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "MiddleToe*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		if (`gmatch $deformJointsList[$i] "*_L"`)
			move -r -os -wd 0 0 ($lenght/4.0) $poly;
		else
			move -r -os -wd 0 0 ($lenght/-4.0) $poly;
		parentConstraint -mo $deformJointsList[$i] $poly;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		scaleConstraint $deformJointsList[$i] $poly;
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
		parentConstraint $deformJointsList[$i] $poly;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
		scaleConstraint $deformJointsList[$i] $poly;
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

	parentConstraint $deformJointsList[$i] $poly;
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
	scaleConstraint $deformJointsList[$i] $poly;
	refresh;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}

global proc asMirrorPolyBoxes (int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $allCyls[]=`listRelatives -type transform -c "BoxesGeometry"`;
string $matchBox;
float $scale[3],$pos[3];
int $mirrorVtxNr;
int $vs[];
for ($i=0;$i<size($allCyls);$i++)
	{
	if ($L2R)
		$matchBox=`substitute "_L" $allCyls[$i] "_R"`;
	else
		$matchBox=`substitute "_R" $allCyls[$i] "_L"`;

	if ($allCyls[$i]==$matchBox || `gmatch $allCyls[$i] "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($allCyls[$i]+".scale")`;
	setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $allCyls[$i]`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($allCyls[$i]+".vtx["+$y+"]")`;
		if ($y==0) $mirrorVtxNr=6;
		if ($y==1) $mirrorVtxNr=7;
		if ($y==2) $mirrorVtxNr=4;
		if ($y==3) $mirrorVtxNr=5;
		if ($y==4) $mirrorVtxNr=2;
		if ($y==5) $mirrorVtxNr=3;
		if ($y==6) $mirrorVtxNr=0;
		if ($y==7) $mirrorVtxNr=1;
		if ($y==7) $mirrorVtxNr=1;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$mirrorVtxNr+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}
select $sel;
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
float $scale=`floatField -q -v ScaleCCFloatField`;
string $controlObjects[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	$controlObjects=`sets -q "ControlSet"`;
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$tempString=`listRelatives -s $controlObjects[$i]`;
	if (!size($tempString))
		continue;
	select -cl;
	refresh;
	select -cl;
	for ($y=0;$y<100;$y++)
		select -add ($tempString[0]+".cv["+$y+"]");
	scale -r $scale $scale $scale;
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asCreateMoCap ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
if (`objExists "MoCap"`)
	error "MoCap skeleton already exists !";
if (!`objExists "Main"`)
	error "No AdvancedSKeleton In Scene!";
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
string $keyDeformJoints[],$tempString[],$parent[],$names[],$extra[];
string $extr;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr="FKExtra"+$tempString[0]+"_"+$tempString[1];
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=$tempString[0]+"_MoCap_"+$tempString[1];
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=$name;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" RootExtraX_M 1 0 0 0;
		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ("RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists $extra[$i]`)
		connectAttr ($names[$i]+"_blendColor.output") ($extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asSetAllFK ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;
}

global proc float asGetSceneFps () 
{
float $fps;
string $fpsName=`currentUnit -q -time`;
if ($fpsName=="game") $fps=15;
if ($fpsName=="film") $fps=24;
if ($fpsName=="pal") $fps=25;
if ($fpsName=="ntsc") $fps=30;
if ($fpsName=="show") $fps=48;
if ($fpsName=="palf") $fps=50;
if ($fpsName=="ntscf") $fps=60;
if ($fpsName=="millisec") $fps=1000;
if ($fpsName=="sec") $fps=1;
if ($fpsName=="min") $fps=0.0166667;
if ($fpsName=="hour") $fps=0.000277778;
if (`gmatch $fpsName "*fps"`)
	$fps=`substitute "fps" $fpsName ""`;
return $fps;
}

global proc asReadBVH ()
{
global string $gMainProgressBar;
string $filename=`fileDialog -dm "*.bvh"`;
if (!`file -q -ex $filename`)
	return;

if (!`objExists bvhFile`)
	createNode -n bvhFile transform;

select -cl;
string $topNodesBefore[]=`ls -as`;

int $i=-1;
int $x,$lineNum,$frameNr,$motionBegin,$motionHasBegun;
int $jointNum,$chNum;
int $numChannels[];
float $offsetX,$offsetY,$offsetZ,$value;
float $rot[];
$fileId=`fopen $filename "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionBegin)
		$lineNum++;
	$nextLine = `fgetline $fileId`;
	}
$motionBegin=0;
fclose $fileId;
$fileId=`fopen $filename "r"`;
$nextLine = `fgetline $fileId`;
string $joints[],$buffer[],$channels[],$localChannels[];
float $currentTime=`currentTime -q`;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
currentTime -e -20;

progressBar -e -st "AdvancedSkeleton" -bp -ii 1 -min 0 -max ($lineNum+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
while ( size( $nextLine ) > 0 )
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		fclose $fileId;
		}

	tokenize $nextLine $buffer;
	if (`gmatch $nextLine "*}*"`)
		pickWalk -d up;
	if (`gmatch $nextLine "*JOINT*"` || `gmatch $nextLine "*ROOT*"` || `gmatch $nextLine "*End Site*"`)
		{
		$i++;
		$joints[$i]=$buffer[1];
		if ($joints[$i]=="Site")
			$joints[$i]=$joints[$i]+$i;
		joint -n ("MoCap"+$joints[$i]);
		setAttr ("MoCap"+$joints[$i]+".rotateOrder") 2;
		if (`gmatch $nextLine "*JOINT*"`)
			setKeyframe ("MoCap"+$joints[$i]+".rotate");
		}
	if (`gmatch $nextLine "*OFFSET*"`)
		{
		$offsetX=$buffer[1];
		$offsetY=$buffer[2];
		$offsetZ=$buffer[3];
		setAttr -type float3 ("MoCap"+$joints[$i]+".translate") $offsetX $offsetY $offsetZ;
		}
	if (`gmatch $nextLine "*CHANNELS*"`)
		{
		$numChannels[$i]=$buffer[1];
		for ($x=2;$x<size($buffer);$x++)
			$channels[$i]=$channels[$i]+`asReWord $buffer[$x]`+";";
		}

	if ($motionBegin)
		$motionHasBegun=1;
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionHasBegun)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$jointNum=0;
		tokenize $channels[$jointNum] ";" $localChannels;
		$chNum=-1;
		for ($y=0;$y<size($buffer);$y++)
			{
			$chNum++;
			if ($chNum>$numChannels[$jointNum]-1)
				{
				$jointNum++;
				if (`gmatch $joints[$jointNum] "Site*"`)
					$jointNum++;
				tokenize $channels[$jointNum] ";" $localChannels;
				$chNum=0;
				}
			$value=$buffer[$y];
//			currentTime -e ($frameNr+1);
			if (`gmatch $localChannels[$chNum] "*rotate*"`)
				{
				if ($localChannels[$chNum]=="rotateX")
					$rot[0]=$value;
				if ($localChannels[$chNum]=="rotateY")
					$rot[1]=$value;
				if ($localChannels[$chNum]=="rotateZ")
					$rot[2]=$value;
				if ($chNum==2 || $chNum==5)
					{
					asSetMoCapRot ("MoCap"+$joints[$jointNum]) $rot;
					setKeyframe -t $frameNr ("MoCap"+$joints[$jointNum]+".rotate");
					}
				}
			else
				setKeyframe -v $value -t $frameNr ("MoCap"+$joints[$jointNum]+"."+$localChannels[$chNum]);
			}
		$frameNr++;
		}
	$nextLine = `fgetline $fileId`;
	}
progressBar -e -ep $gMainProgressBar;
currentTime -e $currentTime;
autoKeyframe -state $autoKeyframe;
fclose $fileId;

string $topNodesAfter[]=`ls -as`;
string $moCapTopNode;
for ($i=0;$i<size($topNodesAfter);$i++)
	{
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$moCapTopNode=$topNodesAfter[$i];
		parent $moCapTopNode bvhFile;
		}
	}

//clean statics
string $bhvJoints[]=`listRelatives -ad -type joint bvhFile`;
select $bhvJoints;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;

//Scale to match Root height
string $tempString[]=`listConnections -scn 1 ($moCapTopNode+".ty")`;
if ($tempString[0]!="")
	{
	$tyAnimCurve=$tempString[0];
	string $tempString[]=`listRelatives -c -type joint DeformationSystem`;
	string $root=$tempString[0];
	float $rootHeigh=`getAttr ($root+".ty")`;
	float $keyValues[]=`keyframe -in 0 -q -vc $tyAnimCurve`;
	float $scaleFactor=$rootHeigh/$keyValues[0];
	setAttr -type float3 bvhFile.s $scaleFactor $scaleFactor $scaleFactor;
/*
	$tempString=`listConnections -scn 1 ($moCapTopNode+".tx")`;
	$txAnimCurve=$tempString[0];
	$tempString=`listConnections -scn 1 ($moCapTopNode+".tz")`;
	$tzAnimCurve=$tempString[0];
	selectKey -add -k -t "0:99999" $txAnimCurve $tyAnimCurve $tzAnimCurve;
	scaleKey -iub false -ts 1 -tp 69 -fs 1 -fp 69 -vs $scaleFactor -vp 0 -animation keys ;
*/
	}
//Scale keys to match frameRate
float $bvhFps=`floatField -q -v asBVHfps`;
float $sceneFps=`asGetSceneFps`;
float $scaleTime=$sceneFps/$bvhFps;
string $animCurves[];
select -cl;
for ($i=0;$i<size($bhvJoints);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bhvJoints[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		selectKey -add -k -t "0:99999" $animCurves[$y];
	}
scaleKey -iub false -ts $scaleTime -tp 0 -fs $scaleTime -fp 0 -vs 1 -vp 0 -animation keys ;

playbackOptions -min 0 -ast 0 -max ($frameNr*$scaleTime) -aet ($frameNr*$scaleTime);
currentTime 0;

select -cl;
}

global proc asDeleteMocap ()
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asDeleteBHV ()
{
if (`objExists bvhFile`)
	delete bvhFile;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asAutoMapMocap ()
{
float $charHeight=`asgetCharHeight`;
string $tempString[]=`listRelatives -c -type joint bvhFile`;
string $bvhTopJoint=$tempString[0];
string $tempString[]=`listRelatives -c -type joint CenterOffset`;
string $moCapTopJoint=$tempString[0];
$tempString=`pointConstraint $bvhTopJoint $moCapTopJoint`;
setAttr ($tempString[0]+".offsetZ") ($charHeight/3);

catch (`orientConstraint -mo $bvhTopJoint $moCapTopJoint`);

catch (`orientConstraint -mo MoCapRightUpLeg Hip_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftUpLeg Hip_MoCap_L`);
catch (`orientConstraint -mo MoCapRightLeg Knee_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftLeg Knee_MoCap_L`);
catch (`orientConstraint -mo MoCapRightFoot Ankle_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftFoot Ankle_MoCap_L`);
catch (`orientConstraint -mo MoCapRightToeBase Toes_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftToeBase Toes_MoCap_L`);

catch (`orientConstraint -mo MoCapLowerBack Root_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine Spine1_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine1 Chest_MoCap_M`);
catch (`orientConstraint -mo MoCapRightShoulder Scapula_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftShoulder Scapula_MoCap_L`);
catch (`orientConstraint -mo MoCapRightArm Shoulder_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftArm Shoulder_MoCap_L`);
catch (`orientConstraint -mo MoCapRightForeArm Elbow_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftForeArm Elbow_MoCap_L`);
catch (`orientConstraint -mo MoCapRightHand Wrist_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftHand Wrist_MoCap_L`);

catch (`orientConstraint -mo MoCapRThumb ThumbFinger2_MoCap_R`);
catch (`orientConstraint -mo MoCapLThumb ThumbFinger2_MoCap_L`);

catch (`orientConstraint -mo MoCapNeck1 Neck_MoCap_M`);
catch (`orientConstraint -mo MoCapHead Head_MoCap_M`);
}

global proc asDeleteMocapMap ()
{
delete `listRelatives -ad -type constraint MoCap`;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asSetMoCapRot (string $obj, float $rot[])
{
setAttr -type float3 ($obj+".rotate") 0 0 0;
float $rotX=$rot[0];
float $rotY=$rot[1];
float $rotZ=$rot[2];
rotate -r -os 0 0 $rotZ $obj;
rotate -r -os $rotX 0 0 $obj;
rotate -r -os 0 $rotY 0 $obj;
}

global proc string asReWord (string $bvhWord)
{
if ($bvhWord=="Xposition")
	return "translateX";
if ($bvhWord=="Yposition")
	return "translateY";
if ($bvhWord=="Zposition")
	return "translateZ";
if ($bvhWord=="Xrotation")
	return "rotateX";
if ($bvhWord=="Yrotation")
	return "rotateY";
if ($bvhWord=="Zrotation")
	return "rotateZ";
return "";
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asPopulateSnapToLivePopupMenu ()
{
int $skip;
string $tempString[],$tempString2[],$menuGeos[];
string $allPolyShapes[]=`ls -type mesh`;
string $allNurbsShapes[]=`ls -type nurbsSurface`;
string $allGesoShapes[]=`stringArrayCatenate $allPolyShapes $allNurbsShapes`;
string $skipParents[]={"FitSkeleton","FaceFitSkeleton","MotionSystem","Cages","MeshGeometry","NurbsGeometry","SkeletonGeometry","BoxesGeometry","MannequinGeometry"};
for ($i=0;$i<size($allGesoShapes);$i++)
	{
	$tempString=`ls -l $allGesoShapes[$i]`;
	tokenize $tempString[0] "|" $tempString2;
	$skip=0;
	for ($y=0;$y<size($skipParents);$y++)
		if (`stringArrayCount $skipParents[$y] $tempString2`)
			{
			$skip=1;
			break;
			}
	if ($skip)
		continue;
	if (`getAttr ($allGesoShapes[$i]+".intermediateObject")`)
		continue;
	$tempString=`listRelatives -p $allGesoShapes[$i]`;
	$menuGeos[size($menuGeos)]=$tempString[0];
	}

string $existingMenuItems[]=`popupMenu -q -ia asSnapToLivePopupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;

for ($i=0;$i<size($menuGeos);$i++)
	{
	//$menu1s
	setParent -menu asSnapToLivePopupMenu;
	menuItem -c ("asMakeLive "+$menuGeos[$i]) -l $menuGeos[$i];
	}
}

global proc asMakeLive (string $object)
{
string $sel[]=`ls -sl`;
select $object;
makeLive;
textField -e -tx $object asMakeLiveObjectText;
snapMode -meshCenter 1;
iconTextCheckBox -e -v 1 asMeshCenterSnapButton;
optionVar -sv asLiveGeometry $object;
select $sel;
}

global proc asSnapMode (int $onOff)
{
string $sel[]=`ls -sl`;
snapMode -meshCenter $onOff;
string $liveObjectText=`textField -q -tx asMakeLiveObjectText`;
if ($onOff)
	{
	if (`objExists $liveObjectText`)
		{
		select $liveObjectText;
		makeLive;
		}
	}
else
	makeLive -none;

asSelectableGeo (!$onOff);
select $sel;
}

global proc asPopulateDrivingSystemsPopupMenu (string $action)
{
string $popupMenu="as"+$action+"DrivingSystemsPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$delete;
if ($action=="Delete") $delete=1;
float $keyValues[];
string $cmd,$animCurve;
string $drivingSystems[],$tempString[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	//$menu1s
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph") $sm=0;
	$lev1Menu=`menuItem -sm $sm -l $drivingSystems[$i]`;
	if ($action=="Graph")
		{
		string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
		$cmd="select ";
		for ($attr in $udAttrs)
			{
			$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attr)`;
			for ($node in $tempString)
				$cmd+=$node+" ";
			}
		$cmd+=";GraphEditor;";
		menuItem -e -c $cmd $lev1Menu;
		continue;
		}

	//$menu2s
	$attrs=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		setParent -menu $lev1Menu;
		$lev2Menu=`menuItem -sm $sm -l $attrs[$y]`;
	
		//$menu3s
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attrs[$y])`;
		$animCurve=$tempString[0];
		$numKeys=`keyframe -q -keyframeCount $animCurve`;
		for ($x=0;$x<$numKeys;$x++)
			{
			$keyValues=`keyframe -in $x -q -fc $animCurve`;
			$keyValues[0]=`asRoundOff $keyValues[0] 3`;
			if($keyValues[0]==0)
				continue;
			$cmd="asEditDrivingSystem "+$delete+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[0];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[0] -c $cmd`;
			}
		}
	}
}

global proc asAutoFindAndEditDrivingSystem ()
{
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($udAttrs);$y++)
		{
		float $value=`getAttr ($drivingSystems[$i]+"."+$udAttrs[$y])`;
		$value=`asRoundOff $value 3`;
		if ($value!=0)
			{
			asEditDrivingSystem 0 $drivingSystems[$i] $udAttrs[$y] $value;
			return;
			}
		}
	}
}

global proc asEditDrivingSystem (int $delete, string $obj, string $attr, float $value)
{
int $numDriven;
float $drivenValues[];
string $stripName;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[];
string $tempString2[];
string $tempString[]=`listConnections -scn 1 ($obj+"."+$attr)`;
setAttr ($obj+"."+$attr) $value;
for ($i=0;$i<size($tempString);$i++)
	if (size(`ls -type animCurve $tempString[$i]`))	
		{
		tokenize $tempString[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}
		$stripName=`substring $tempString[$i] 5 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
			}
		$drivenAttrs[$numDriven]=$tempString2[size($tempString2)-1];
		$drivenValues[$numDriven]=`getAttr ($drivenSdkNode[$numDriven]+"."+$drivenAttrs[$numDriven])`;
		$numDriven++;
		}

asGoToBuildPose bodySetup;

if ($delete)
	{
	//remove entry in buildPose
	string $buildPoseCmd=`getAttr buildPose.udAttr`;
	tokenize $buildPoseCmd ";" $tempString;
	string $newBuildPoseCmd="";
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] ("setAttr "+$obj+"."+$attr+"*")`)
			$newBuildPoseCmd+=$tempString[$i]+";";
	setAttr -type "string" buildPose.udAttr $newBuildPoseCmd;
	//remove associated SdkXforms (that dont have another drivers driving them as well)
	$tempString=`listConnections -scn 1 -s 0 -d 1 ($obj+"."+$attr)`;
	for ($i=0;$i<size($tempString);$i++)
		if (size(`ls -type animCurve $tempString[$i]`))
			{
			$tempString2=`listConnections -scn 1 -s 0 -d 1 ($tempString[$i]+".output")`;
			$SdkXform=$tempString2[0];
			$tempString2=`listConnections -scn 1 -s 1 -d 0 $SdkXform`;
			if(size($tempString2)==1)
				{
				parent `listRelatives -c $SdkXform` `listRelatives -p $SdkXform`;
				delete $SdkXform;
				}
			}
	//remove attr
	deleteAttr ($obj+"."+$attr);
	//remove controller if there`s no attributes left
	$tempString=`listAttr -ud $obj`;
	if (!size($tempString))
		delete $obj;
	return;
	}

for ($i=0;$i<size($drivenObjs);$i++)
	setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
rowLayout -e -en 1 asDSEditChoicesRowLayout;

//select one of the drivenControls, to hint what to modify
select $drivenObjs;
}

global proc asDrivingSystemEditCancel ()
{
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
asGoToBuildPose bodySetup;
}

global proc asDrivingSystemEditApply ()
{
asCreateDrivingSystem;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
}

global proc asCreateDrivingSystemLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
string $tempString[];
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0;
columnLayout -adj 0;
	text -l $asDSMessage;
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0 asDSInputsColumnLayout;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		textField -w 80 asDSObjNameTextField;
		setParent..;
	rowLayout -en 0 -nc 4 asDSUseControlRowLayout; 
	    separator -w 5 -st none;
	    checkBox -w 95 -l "Use Control:"
	    	-onc "optionMenu -e -en 1 asDSObjNameOptionMenu;rowLayout -e -en 0 asDSControlNameRowLayout;"
	    	-ofc "optionMenu -e -en 0 asDSObjNameOptionMenu;rowLayout -e -en 1 asDSControlNameRowLayout;"
	    	asDSUseControlCheckBox;
    	optionMenu -en 0 asDSObjNameOptionMenu;
		setParent..;
	if ($asDSAltPivot!="")
		{
		rowLayout -en 1 -nc 4 asDSAltPivotRowLayout; 
		    separator -w 5 -st none;
		    text -l "Alt Pivot:";
	    	textField -ed 0 -tx $asDSAltPivot asDSAltPivotTextField;
			setParent..;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 3 asDSMirrorRowLayout;
			text -w 100 -l "Mirror:";
    	checkBox -l "" -v 1 asDSMirrorCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asCreateDrivingSystemGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (size($drivingSystems))
	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;
for ($i=0;$i<size($drivingSystems);$i++)
	menuItem -l $drivingSystems[$i];

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
}

global proc string asCreateSDKXform (string $drivenObj)
{
global string $asDSAltPivot;
string $tempString[]=`listRelatives -p $drivenObj`;
string $parent=$tempString[0];
string $child=$drivenObj;
string $sdkXform;
if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}
for ($y=1;$y<99;$y++)
	{
	$sdkXform="SDK"+$y+$drivenObj;
	if (!`objExists $sdkXform`)
		break;
	}
createNode -n $sdkXform -p $parent transform;
sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

//$asDSAltPivot
// could be _R, but should be _L
if (`gmatch $drivenObj "*_L"` && `gmatch $asDSAltPivot "*_R"`)
	$asDSAltPivot=`substitute "_R" $asDSAltPivot "_L"`;
if ($asDSAltPivot!="" && `objExists $asDSAltPivot`)
	{
	createNode -n ($sdkXform+"AltPivotOffset1") transform;
	createNode -n ($sdkXform+"AltPivotOffset2") transform;
	sets -add AllSet ($sdkXform+"AltPivotOffset1") ($sdkXform+"AltPivotOffset2");
	asAlign ($sdkXform+"AltPivotOffset1") $asDSAltPivot 1 1 0 1;
	asAlign ($sdkXform+"AltPivotOffset2") $sdkXform 1 1 0 0;
	asAlign $sdkXform $asDSAltPivot 1 1 0 1;
	$tempString=`listRelatives -p $sdkXform`;
	parent ($sdkXform+"AltPivotOffset1") $tempString[0];
	parent $sdkXform ($sdkXform+"AltPivotOffset1");
	parent ($sdkXform+"AltPivotOffset2") $sdkXform;
	parent $child ($sdkXform+"AltPivotOffset2");
	}
else
	parent $child $sdkXform;
return $sdkXform;
}

global proc asCreateDrivingSystemGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSMirror;
int $result;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`rowLayout -q -en asDSControlNameRowLayout`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
}

global proc asCreateDrivingSystem ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSMirror;

int $modifier=`getModifiers`;
string $sel[]=`ls -sl`;

int $isEditing,$reusingSdkXform;
float $runValues[],$pos[],$drivenValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale;
string $parent,$child,$obj,$drivenObj,$drivenAttr,$m,$controllerName,$sdkXform,$side,$oppositeSide;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
string $existingSdkXforms[];
float $driverValue=10;
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
$asDSObjName="";

//Do we come from EditDrivingSystemMode ?
int $comeFromEDSMode=0;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] "[:]" $tempString;
	$tempString[1]=`strip $tempString[1]`;
	tokenize $tempString[1] "=" $tempString;
	$driverValue=$tempString[1];
	tokenize $tempString[0] "[.]" $tempString;
	$asDSObjName=$tempString[0];
	$asDSAttrName=$tempString[1];
	$comeFromEDSMode=1;
	}

//Find driven attribute(s)
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
	{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				$tempString2=`listRelatives -p $obj`;
				if ($tempString2[0]=="DrivingSystem")
					error ("Found \""+$checkObjAttr[$z]+"\", which is a DrivingSystem attribute. To modify this right>click on the \"Edit\" button");
				else
					{
					//Creating new DrivingSystem
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				}
			}
		}
	}
if (size($drivens)==0)
	error ("Found no driven attributes, all controls are in Build-Pose");

if ($comeFromEDSMode)
	{
	$isEditing=1;
	$m="Edit:  "+$asDSObjName+"."+$asDSAttrName+"="+$driverValue+"\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";	
		}
	}
else
	{
	$m="Create system to drive these attributes?\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";
		}
	$asDSAttrName="";
	$asDSAttrName="";
	}

$asDSMessage=$m;

$asDSAltPivot="";
if ($modifier==4 && $sel[0]!="")
	$asDSAltPivot=$sel[0];

string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateDrivingSystemLayout`;
if ($dialogResult!="OK")
	return;

string $side="_M";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_R"`) $side="_R";
	if (`gmatch $drivenObjs[$i] "*_L"`) $side="_L";
	if ($side!="_M") break;
	}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $side=="_M")
		continue;
	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	string $controllerName=$asDSObjName+$side;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$side;
			if (!`objExists $controllerName`)
				break;
			}
	string $attrName=$asDSAttrName;
	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}


//	if ($b==-1){$side=$oppositeSide;if ($side=="_R") $oppositeSide="_L";if ($side=="_L") $oppositeSide="_R";}
	if (`objExists $asDSObjName`) //use-existing-Control
		{
		$controllerName=$asDSObjName;
		if ($b==-1) $controllerName=`substitute $oppositeSide $controllerName $side`;
		}
	else
		asCreateDrivingSystemController $controllerName $drivenObjs;

	if (!`attributeExists $attrName $controllerName`)
		addAttr -k 1 -ln $attrName -at double -hasSoftMinValue 1 -softMinValue 0 -hasSoftMaxValue 1 -softMaxValue 10 $controllerName;
	else
		{
		if ($driverValue<0)
			addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
		else if ($driverValue>10)
			addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
		}

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$reusingSdkXform=0;
		if ($drivenObj!=$tempString[0])//first attr in new obj
			{
			$drivenObj=$tempString[0];
			
			//See if there is a existing SDKXfrom for this driver/target combo
			$existingSdkXforms=`ls ("SDK*"+$drivenObj)`;
			for ($y=0;$y<size($existingSdkXforms);$y++)
				{
				$tempString2=`listConnections -scn 1 -s 1 -d 0 $existingSdkXforms[$y]`;
				for ($z=0;$z<size($tempString2);$z++)
					{
					$tempString3=`listConnections -scn 1 -s 1 -d 0 -p 1 $tempString2[$z]`;
					if ($tempString3[0]==$controllerName+"."+$attrName)
						{
						$sdkXform=$existingSdkXforms[$y];
						$reusingSdkXform=1;
						}
					}
				}
			if (!$reusingSdkXform)
				$sdkXform=`asCreateSDKXform $drivenObj`;
			$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
			}
		$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
		}
	
	if ($b==1)
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;

	if ($b==-1)	//use asMirror to get mirrorValues
		{
		string $restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $driverValue -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	string $restorePoseCmd=`asGetRestorePoseCmd`;
	asGoToBuildPose bodySetup;
	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v `getAttr $drivens[$i]` -dv 0 -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	eval($restorePoseCmd);
	if (!$isEditing)
		setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	//AltPivot attribute
	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		if ($asDSAltPivot=="")
			continue;
		$tempString=`listConnections $sdkDrivens[$i]`;
		addAttr -ln altPivot -dt "string" $tempString[0];
		setAttr -type "string" ($tempString[0]+".altPivot") $asDSAltPivot;
		}
	}
select -cl;
asGoToBuildPose bodySetup;
}

global proc asCreateDrivingSystemController (string $objName, string $drivenObjs[])
{
float $height=`getAttr "Main.height"`;
int $isChildOfOtherDriven;
string $tempString[],$tempString2[];
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 1 0 -sw 180 -r (0.05*$height) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;

//position the controller centered to driven ctrls (use pos from parent, as this is likely in correct pos)
tokenize $objName "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
if (`gmatch $drivenObjs[0] "*Finger*"` && `objExists ("MiddleFinger2"+$side)`) //center Finger related systems to MiddleFinger
	pointConstraint ("MiddleFinger2"+$side) $objName;
else
	for ($i=0;$i<size($drivenObjs);$i++)
		{
		$tempString=`listRelatives -p $drivenObjs[$i]`;
		pointConstraint $tempString[0] $objName;
		}

if (`gmatch $objName "*_L"`)
	scale -r -1 1 1 ($objName+".cv[0:10]");
if (`gmatch $objName "*_M"`)
	rotate -r -os 0 90 0 ($objName+".cv[0:10]");


if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	sets -add AllSet DrivingSystem;
	}
parent $objName DrivingSystem;

for ($i=0;$i<size($drivenObjs);$i++)
	{
	$isChildOfOtherDriven=0;
	$tempString=`ls -l $drivenObjs[$i]`;
	tokenize $tempString[0] "|" $tempString2;
	for ($y=0;$y<size($tempString2);$y++)
		if ($tempString2[$y]!=$drivenObjs[$i])
			if (`stringArrayCount $tempString2[$y] $drivenObjs`)
				$isChildOfOtherDriven=1;
	if (!$isChildOfOtherDriven)
		{
		if (`gmatch $drivenObjs[$i] "FK*"`)
			{
			string $deformJoint=`substitute "FK" $drivenObjs[$i] ""`;
			if (`objExists $deformJoint`)
				{
				$tempString=`listRelatives -p -type joint $deformJoint`;
				if (`objExists $tempString[0]`)
					{
					$constraintTo=$tempString[0];
					break;
					}
				}
			}
		if (`gmatch $drivenObjs[$i] "IK*"`)
			{
			string $ms=`substitute "IK" $drivenObjs[$i] ""`;
			int $numLetters=`size($ms)`;
			$ms=`substring $ms 1 ($numLetters-2)`;
			string $side=`substring $drivenObjs[$i] ($numLetters+1) 99`;
			if (`objExists ($ms+"System")`)
				{
				$tempString=`listConnections ($ms+"System.end")`;
				string $start=$tempString[0];
				if (`objExists ($start+$side)`)
					{
					$tempString=`listRelatives -p -type joint ($start+$side)`;
					if (`objExists $tempString[0]`)
						$constraintTo=$tempString[0];
					}
				}
			}
		}
	}

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
if (`objExists ($objName+"_pointConstraint1")`)
	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	createNode -n AngleSystem -p MotionSystem transform;

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;
	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	$previousOutput=($mpd+".outputX");
	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
string $drivers[];
float $dvs[];
int $connectedToMultDiv=1;
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
		{
		$connectedToMultDiv=1;
		$plug=$nodeA+".input1.input1X";
		}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			{
			tokenize $setDriver "[.]" $tempString;
			string $driverObj=$tempString[0];
			string $driverAttr=$tempString[1];
			asSetRotationFromAngle $driverObj $driverAttr $dvs[$i];
			}
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc string asCreateCorrectiveShape ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl -o`;
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
string $tempString[]=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[]=`sets -q ControlSet`;
string $tempString[],$tempString2[];
//As below v3.9.7 had bug where EyeOrientOffset_L was in FaceControlSet
if (`objExists FaceControlSet`)
	if (`objExists EyeOrientOffset_L`)
		if (`sets -im FaceControlSet EyeOrientOffset_L`)
			sets -rm FaceControlSet EyeOrientOffset_L;

if (`objExists Main`)
	{
	float $version=`getAttr Main.version`;
	if ($version<=3.97)
		warning ("This rig was build with AdvancedSkeleton version:"+$version
			+", Corrective Shapes with version 3.97 or below can cause unpredictable results");
	}

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`objExists ("TwistBalancer"+$driverObj)`) //$idv special case if RX from a twist-system
				{
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";
		asCreateBlendedAttribute $drivers;
		asCreateCorrectiveShape;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
duplicate -n $attrCode $source;
asLockAttr $attrCode 0 0 0 0;
string $tempString[]=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];

rowLayout -e -en 1 asCorrectiveEditChoicesRowLayout;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asEditCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
setAttr "Group.v" 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" "Group"`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" "Group";
	setAttr -type "string" "Group.correctiveShapeModeHidden" $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

string $history[]=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}
duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $deformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $deformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;

string $history[]=`listHistory $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}
select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];
DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};
string $history[];

//get current FKIK blend values
string $controlSetMembers[]=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;

if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

if (`gmatch $driverAttr "angleX*"`)
	setAttr ($FKDriverObj+".rx") $idv;
else if (`gmatch $driverAttr "angleY*"`)
	setAttr ($FKDriverObj+".ry") $idv;
else if (`gmatch $driverAttr "angleZ*"`)
	setAttr ($FKDriverObj+".rz") $idv;
else if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)
	asSetBlendedAttribute $FKDriverObj $driverAttr $dv 0;
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;

$tempString=`listRelatives -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
	if (`objectType $history[$i]`=="blendShape" && $history[$i]!="asFaceBS")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS"
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $deformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $deformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $deformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;
//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "0", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}
delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe 														-v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe 														-v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
select $deformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
rowLayout -e -en 0 asCorrectiveEditChoicesRowLayout;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asEditCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

if (`attributeExists "correctiveShapeModeHidden" "Group"`)
	setAttr (`getAttr "Group.correctiveShapeModeHidden"`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$menu="asCorrectiveMenu_"+$action+$driverObj;
		if(`stringArrayCount $menu $menu2s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverObj $menu;
			$menu2s[size($menu2s)]=$menu;
			}

		//$menu3s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr;
		if(`stringArrayCount $menu $menu3s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverAttr $menu;
			$menu3s[size($menu3s)]=$menu;
			}

		//$menu4s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr+"_"+$posNeg;
		if(`stringArrayCount $menu $menu4s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $posNeg $menu;
			$menu4s[size($menu4s)]=$menu;
			}
		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			setParent -menu $menu;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;
if (!`getAttr -settable ($driverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK;
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShape`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrectiveShape;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[]=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
	}

return $restorePoseCmd;
}

global proc asJointVis (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCruves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCruves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCruves1);$i++)
	{
	tokenize $skinCruves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCruves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCruves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCruves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>1)
				$weight=1;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asCreateSkinCage ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
softSelect -e -softSelectEnabled 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
	asAnalyzeChainJoints $topNodes[0];
$tempString=`asListChildren $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "Spine*_M"`)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asAnalyzeChainJoints $tempString[$i];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}

//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
string $cylinders[]=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
string $markers[]=`asGetMarkersSorted`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$markerSide[$i]="_R";
		$pos=`xform -q -ws -t $markers[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$markerSide[$i]="_M";

		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$markers[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			float $sca[3]=`getAttr ($markers[$i]+".s")`;
//			setAttr -type float3 ($profileCurve+".s") $sca[0] $sca[1] $sca[2];
//			setAttr ($profileCurve+".sx") $scale;
			setAttr ($profileCurve+".sy") ($sca[1]*$scale);
			setAttr ($profileCurve+".sz") ($sca[2]*$scale);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;

select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
float $charHeight=`asgetCharHeight`;
string $ankleProfileEnds[]=`ls -type nurbsCurve "*Ankle*_*endProfileShape"`;
string $tempString[];
string $ankle,$heel,$transform;
int $numLetters,$b;
int $cvs[],$oppositeCvs[];
float $pos[3],$existingPos[3],$transformPos[3],$offset[3];
float $averageZ,$heelX,$heelZ;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	$foundHeelPos=0;
	$tempString=`listRelatives -p $ankleProfileEnds[$i]`;
	$transform=$tempString[0];
	$transformPos=`xform -q -ws -t $transform`;
	$ankle=`substitute "endProfileShape" $ankleProfileEnds[$i] ""`;
	$numLetters=size($ankle);
	$ankle=`substring $ankle 1 ($numLetters-3)`;
	$tempString=`listConnections -s 0 -d 1 ($ankle+".message")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`attributeExists heelX $tempString[$y]`)
			{
			$foundHeelPos=1;
			$heelX=`getAttr ($tempString[$y]+".heelX")`;
			$heelZ=`getAttr ($tempString[$y]+".heelZ")`;
			$pos={$heelX,0.0,$heelZ};
			}
	if (!$foundHeelPos)
		continue;
	$b=1;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		$cvs={0,1,4};
	else
		{
		$cvs={2,3};
		$b=-1;
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -os -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		move -r -os 0 0 $existingPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]"); 
		}
	}
string $toeProfileMiddle[]=`ls -type nurbsCurve "*Toes*ProfileShape"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$tempString=`listRelatives -p $toeProfileMiddle[$i]`;
	$transform=$tempString[0];
	$transformPos=`xform -q -ws -t $transform`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{$cvs={0,1,4};$oppositeCvs={2,3};}
	else
		{$cvs={2,3};$oppositeCvs={0,1,4};}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}
	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 0.5 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}
	}
}

global proc asCreateSliders ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") 0.3;
		if ($skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") -0.3;
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		float $pos[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		float $pos[]=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
if (`attributeExists Scapula $tempString[0]`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Slider[0-9]","Slide50","Cup_","ThumbFinger1_","PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	if (`attributeExists noMiddleCurve $tempString[$i]`)
		{
		$skip=1;
		$skipChildrenToo=1;
		}
	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$result[size($result)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","ThumbFinger1_","PinkyToe_","BigToe_","Jaw_","Eye_","_50","Float","Part[0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;
	if (!$skip)
		$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];
while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;
	refresh;
	}

//Twistcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		$joint=$twistJoint;
		if (`gmatch $joint "*Part[0-9]_*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=`getAttr ($twistJoint+".twistAmount")`*0.8;
			pointConstraint -mo -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -mo -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
int $sortedNr[],$closestParentCvs[],$closestChildCvs[],$furthestParentCvs[],$furthestChildCvs[];
int $tempInt;
string $parentCurve,$firstChild,$nextChild;
string $tempString[],$tempString2[],$children[],$childrenCurves[],$sortedChildren[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
float $pos[3],$pos2[3],$childPos[3],$deltaPos[3],$spreadMostVector[3],$cubePos[3],$temp[3],$temp2[3];
float $Xs[],$Ys[],$Zs[],$sortValues[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$tempString=`asListChildren $joints[$i]`;
	if (size($tempString)<2) // branching only with 2 or more children
		continue;

	//find $children
	clear $children;
	clear $sortedChildren;
	clear $childrenCurves;
	for ($y=0;$y<size($tempString);$y++) // child with no child of it`s own, is not a branch
		{
		$tempString2=`asListChildren $tempString[$y]`;
		if (size($tempString2))
			$children[size($children)]=$tempString[$y];
		}
	//For the Root, pick the first *_M child as parent, and drop it as child
	string $rootParent="";
	if ($joints[$i]=="Root_M")
		{
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "_M"`)
				$rootParent=$children[$y];
		if ($rootParent=="")
			$rootParent=$children[0];
		$children=`stringArrayRemove {$rootParent} $children`;
		}

	//find $spreadMostVector
	$minX=99;$minY=99;$minZ=99;
	$maxX=-99;$maxY=-99;$maxZ=-99;
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		if ($temp[0]<$minX) $minX=$temp[0];
		if ($temp[0]>$maxX) $maxX=$temp[0];
		if ($temp[1]<$minY) $minY=$temp[1];
		if ($temp[1]>$maxY) $maxY=$temp[1];
		if ($temp[2]<$minZ) $minZ=$temp[2];
		if ($temp[2]>$maxZ) $maxZ=$temp[2];
		}
	$xDif=$maxX-$minX;$yDif=$maxY-$minY;$zDif=$maxZ-$minZ;
	if ($xDif>$yDif && $xDif>$zDif) $spreadMostVector={1,0,0}; //e.g. chest/root
	if ($yDif>$xDif && $yDif>$zDif) $spreadMostVector={0,1,0}; //e.g. dinospikes (could be chest if neck.ty>shoulder.tx
	if ($zDif>$xDif && $zDif>$yDif) $spreadMostVector={0,0,1}; //e.g. wrist

	//sort children (by distance between themselves)
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		$Xs[$y]=$temp[0];$Ys[$y]=$temp[1];$Zs[$y]=$temp[2];
		}
	$min=999;
	if ($spreadMostVector[0]) $sortValues=$Xs;
	if ($spreadMostVector[1]) $sortValues=$Ys;
	if ($spreadMostVector[2]) $sortValues=$Zs;
	for ($y=0;$y<size($children);$y++)
		if ($sortValues[$y]<$min)
			{
			$firstChild=$children[$y];
			$min=$sortValues[$y];
			}
	$sortedChildren[0]=$firstChild;
	$nextChild=$firstChild;
	for ($a=0;$a<size($children);$a++)
		{
		$min=999;
		$checkChild=$nextChild;
		$pos=`xform -q -ws -t $checkChild`;
		for ($y=0;$y<size($children);$y++)
			{
			if ($children[$y]==$checkChild || `stringArrayCount $children[$y] $sortedChildren`)
				continue;
			$dist=`mag<<$Xs[$y]-$pos[0],$Ys[$y]-$pos[1],$Zs[$y]-$pos[2]>>`;
			if ($dist<$min)
				{
				$nextChild=$children[$y];
				$min=$dist;
				}
			}
		if(!`stringArrayCount $nextChild $sortedChildren`)
			$sortedChildren[size($sortedChildren)]=$nextChild;
		}

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");
//		$parentCurve=($joints[$i]+"_middleCurve");
	if ($joints[$i]=="Root_M")
		$parentCurve=$rootParent+"_middleCurve";

	//find $childrenCurves
	for ($y=0;$y<size($sortedChildren);$y++)
		{
		if (`objExists ($sortedChildren[$y]+"_startCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_startCurve";
		else if (`objExists ($sortedChildren[$y]+"_middleCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_middleCurve";
		}

	//aimed $childrenCurves
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		duplicate -n ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		parent -w ($childrenCurves[$y]+"TempAimed");
		float $aimVec[]={-1,0,0};
		if (`gmatch $sortedChildren[$y] "*_L"`)
			$aimVec={1,0,0};
		string $aimAt=$joints[$i];
		if ($joints[$i]=="Root_M")
			$aimAt=$parentCurve;
		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $childrenCurves[$y] $aimAt ($childrenCurves[$y]+"TempAimed")`;
		delete $tempString[0];
		}

	//Find $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[0]=$a;
				$closestChildCvs[0]=$b;
				$min=$dist;
				}
			}
		}
	//Find second $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		if($a==$closestParentCvs[0])
			continue;
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			if ($b==$closestChildCvs[0])
				continue;
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[1]=$a;
				$closestChildCvs[1]=$b;
				$min=$dist;
				}
			}
		}

	//sideFace1
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$pos2=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$pos3=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
	$pos4=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
	string $polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchStart -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[0] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchStart");

	//child2childFace`s
	int $childACv[]=`asCvFlip $closestChildCvs`;
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		if (`gmatch $sortedChildren[$y+1] "*_L"` && !`gmatch $sortedChildren[$y] "*_L"`)//first `mirrored`
			{
			$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			}
		string $polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branch"+$y+" -ch 0 -tx 1 -s 1";
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
		$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
		eval ($polyCreateFacetCmd);
		if (`gmatch $sortedChildren[$y] "*_L"` && `gmatch $joints[$i] "*_L"`)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branch"+$y);
		}

	//sideFace2
	int $childACv2[]=`asCvFlip $closestParentCvs`;
	int $lastChildNr=size($childrenCurves)-1;
	$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
	$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
		{
		$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
		}
	$pos3=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$pos4=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	string $polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchEnd -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchEnd");

	//backFace n-sided
	string $polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchBack -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);

	//frontFace n-sided
	string $polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchFront -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);
	polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchFront");

	//polyUnite branch-bits
	select ($joints[$i]+"_branchStart") ($joints[$i]+"_branchEnd") ($joints[$i]+"_branchFront") ($joints[$i]+"_branchBack");
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		select -add ($joints[$i]+"_branch"+$y);
	polyUnite -n ($joints[$i]+"_branch") -ch 0 -mergeUVSets 1;

	//wireDeform into place
	wire -n ($joints[$i]+"_branchWire") -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch");
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		select ($childrenCurves[$y]+"TempAimed");
		select -add ($joints[$i]+"_branch");
		AddWire;
		setAttr ($joints[$i]+"_branchWire.dropoffDistance["+$y+"]") 0.001;
		}
	for ($y=0;$y<size($childrenCurves);$y++)
		orientConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");

	//cleanup
	select ($joints[$i]+"_branch");
	DeleteHistory;
	for ($y=0;$y<size($childrenCurves);$y++)
		delete ($childrenCurves[$y]+"TempAimed") ($childrenCurves[$y]+"TempAimedBaseWire");
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asWrapExlude ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
InvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
	CreateWrap;
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]_*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];
parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;
if ($jointOrient)
	{
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc asCreateController (string $type, string $name, string $side, string $marker)
{
string $sel[]=`ls -sl`;
select -cl;
int $rotOrder=`getAttr ($marker+".rotateOrder")`;
if ($type=="FK")
	joint -n ($type+"Offset"+$name+$side);
else
	{
	createNode -n ($type+"Offset"+$name+$side) transform;
	parent ($type+"Offset"+$name+$side) "IKHandle";
	}
setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
setAttr ($type+$name+$side+".rotateOrder") $rotOrder;
float $sca[]=`xform -q -r -s $marker`;
$sca=`mulitplyWithFitSkeletonScale $sca`;
string $shapes[]=`listRelatives -s ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
parent ($type+$name+$side) ($type+"Extra"+$name+$side);

float $pos[]=`xform -q -ws -t ($marker+$side)`;
float $rot[]=`xform -q -ws -ro ($marker+$side)`;
//float $b=1;
//if ($side=="_L")
//	$b=-1;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);
select $sel;
}

global proc asCreateUnTwister (string $marker, string $side, string $twistParent, string $twistParentSide, string $ms, int $b, int $IkUnTwister, string $ikFollow)
{
float $scale=`getAttr FitSkeleton.sx`;
string $tempString[];
string $parentMs;
//find $parentMs
if (`objExists ($twistParent+$twistParentSide)`)
	{
	$tempString=`listConnections ($twistParent+".message")`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "*System"`)
			{
			$parentMs=`substitute "System" $tempString[$i] ""`;
			break;
			}
	}

createNode -n ("TwistFollow"+$marker+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$marker+$side) -p TwistSystem transform;
setAttr -l 1 ("TwistFollow"+$marker+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$marker+$side+".v") 0;


if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$marker+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$marker+$side);;
	}
else
	{
	asConstraintToFKIK "parent" $ms ("FKX"+$marker+$side) ("IKX"+$marker+$side) ("TwistFollow"+$marker+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		asConstraintToFKIK "parent" $parentMs ("FKX"+$twistParent+$twistParentSide) ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$marker+$side);
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$marker+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$marker+$side) ("TwistFollowParent"+$marker+$side);
//setAttr ("TwistFollow"+$marker+$side+"_parentConstraint1.interpType") 2;

//stabalize contrstraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$marker+$side) -p ("TwistFollow"+$marker+$side) transform;
createNode -n ("TwistFollowParentOffset"+$marker+$side) -p ("TwistFollowParent"+$marker+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$marker+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$marker+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$marker+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$marker+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$marker+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$marker+$side) TwistSystem;
parent ("TwistFollow"+$marker+$side) ("TwistFollowOffset"+$marker+$side);
parent ("TwistFollowParent"+$marker+$side) ("TwistFollowParentOffset"+$marker+$side);

select ($marker+$side);
joint -n ("UnTwist"+$marker+$side);
joint -n ("UnTwistEnd"+$marker+$side);
parent ("UnTwist"+$marker+$side) ("TwistFollowParent"+$marker+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$marker+$side);
else
	asConstraintToFKIK "point" $ms ("FKX"+$marker+$side) ("IKX"+$marker+$side) ("UnTwist"+$marker+$side);

setAttr ("UnTwistEnd"+$marker+$side+".translateX") ($b*$scale);
ikHandle -n ("UnTwistIK"+$marker+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$marker+$side) -ee ("UnTwistEnd"+$marker+$side);
parent ("UnTwistIK"+$marker+$side) ("TwistFollow"+$marker+$side);
poleVectorConstraint ("UnTwist"+$marker+$side) ("UnTwistIK"+$marker+$side);

select ("UnTwist"+$marker+$side);
joint -n ("TwistBalancer"+$marker+$side);
setAttr ("TwistBalancer"+$marker+$side+".rotateOrder") 5;
if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$marker+$side);
else
	asConstraintToFKIK "parent" $ms ("FKX"+$marker+$side) ("IKX"+$marker+$side) ("TwistBalancer"+$marker+$side);
//setAttr ("TwistBalancer"+$marker+$side+"_parentConstraint1.interpType") 2;
}

global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
float $temp[]=`xform -q -ws -t $driven`;
createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint -mo ($driven+"Static") $target $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$target+"W1");
}

global proc asConstraintToFKIK (string $type, string $ms, string $fk, string $ik, string $target)
{
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
$tempString=`eval ($contraintCmd)`;
string $constraint=$tempString[0];
if (`objExists $ik` && `objExists ("FKIKBlend"+$ms+"Reverse"+$side)`)
	{
	connectAttr ("FKIKBlend"+$ms+"Reverse"+$side+".outputX") ($constraint+"."+$fk+"W0");
	connectAttr ("FKIKBlend"+$ms+"UnitConversion"+$side+".output") ($constraint+"."+$ik+"W1");
	}
//if ($type=="orient" || $type=="parent")
//	setAttr ($constraint+".interpType") 2;
}

global proc float[] mulitplyWithFitSkeletonScale (float $scale[])
{
float $fitSkelSca[]=`xform -q -r -s FitSkeleton`;
float $newScale[3]={$scale[0]*$fitSkelSca[0],$scale[1]*$fitSkelSca[1],$scale[2]*$fitSkelSca[2]};
return $newScale;
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
}

global proc asPrunAllClusters ()
{
string $sel[]=`ls -sl`;
string $clusters[]=`ls -type cluster`;
for ($i=0;$i<size($clusters);$i++)
	{
	select $clusters[$i];
	PruneCluster;
	}
select $sel;
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}


global proc asReBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global int $asFitModeScriptJob1Nr;
global string $gMainProgressBar;

if (!`asConfirmIfNotInBuildPose`)
	return;

if (!`objExists "Group"`)
	{
	asBuildAdvancedSkeleton;//First build
	if (`checkBox -q -ex asRebuildConnections`)
		checkBox -e -m 1 asRebuildConnections;
	if (`button -q -ex asToggleFitSkeletonButton`)
		button -e -m 1 asToggleFitSkeletonButton;
	if (`button -q -ex asBuildAdvancedSkeletonButton`)
		button -e -l "ReBuild AdvancedSkeleton" asBuildAdvancedSkeletonButton;
	return;
	}
if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if ($asFitModeScriptJob1Nr==0)
	{
	//Rebuild FitSkeleton first
	asToggleFitMode;
	asToggleFitMode;
	}
if ($asFitModeScriptJob1Nr!=0)
	asToggleFitMode;
string $allSet="AllSet";
string $controlSet="ControlSet";
string $allSetMembers[]=`sets -q $allSet`;

int $rebuildConnections=`checkBox -q -v asRebuildConnections`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";
parent -w FitSkeleton;

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size($allSetMembers)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$skinCluster;
string $charSet,$objectType,$tr,$xyz,$runCmd,$target;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;


//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
string $constraintParent;
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
			continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"`)
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		//Run
		if (`attributeExists run FitSkeleton`)
			{
			$runCmd=`getAttr FitSkeleton.run`;
			if ($runCmd!="")
				{
				$addAttrCmds[size($addAttrCmds)]="setAttr -type \"string\" FitSkeleton.run \""+`encodeString $runCmd`+"\";";
				}
			}
		}
	}


//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}
	if (!$rebuildConnections)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}

	//transformLimits
	if (`objectType $allSetMembers[$i]`=="joint")
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			$xyz="x";
			for ($z=0;$z<3;$z++)
				{
				if ($z==1)
					$xyz="y";
				if ($z==2)
					$xyz="z";
				$e=`eval ("transformLimits -q -e"+$tr+$xyz+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild CurveShapes
string $controlSetMembers[]=`sets -q $controlSet`;
//add HipSwingerOffset_M, so placement of this is maintained in ReBuild
if (`objExists "HipSwingerOffset_M"`)
	$controlSetMembers[size($controlSetMembers)]="HipSwingerOffset_M";
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		$curveShape=$tempString[0];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes inorde to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;


progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
asBuildAdvancedSkeleton;
$asRebuilding=0;


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}


for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

if ($runCmd!="")
	evalEcho $runCmd;

eval ("dgdirty -a");

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		delete $allSetMembers[$i];

select Main;
}

global proc asBuildAdvancedSkeleton ()
{
global int $asFitModeScriptJob1Nr;
global int $asRebuilding;
global string $asDSAltPivot;
global string $gSelect;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeleton4Files/div/asIcons.ma";

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";

setToolTo $gSelect;
int $numLetters;
int $markerTwists[],$markerUpTwists[],$markerBendControls[],$markerUpBendControls[],$markerBend[],$markerRotOrder[],$markerInIK[];
int $markerIsEndJoint[],$msNic[],$msNfc[],$msBfc[],$msSfc[],$msUfc[],$msFKInIK[],$isScapula[],$markerGlobal[],$markerFirstAfterIK[],$markerNoMirror[];
float $scale=`getAttr FitSkeleton.sx`;
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3];
float $markerLenght[],$footRotY[],$msLenght[];
float $sideTreshold=0.0001*$scale;
string $side,$childSide,$joint,$multipleDivide,$parentMs;
string $markerSide[],$markerParent[],$markerParentSide[],$markerChild[],$markerChildSide[],$tempString[],$tempString2[],$systemMarkers[];
string $messageConnections[],$messageConnectionsWithPlug[],$msUfcWhich[];
string $ms[],$msType[],$msSolver[],$msStart[],$msMid[],$msEnd[],$msEndEnd[],$msToes[],$msToesEnd[],$msScapula[],$msComponent[];
string $allBefore[]=`ls`;
string $D=`getAttr -as FitSkeleton.axisLenght`;
string $U=`getAttr -as FitSkeleton.axisFront`;

if ($asFitModeScriptJob1Nr!=0)
	asToggleFitMode;

asEnsureOffHierarchyMode;

if (`objExists Visualizers`)
	delete Visualizers;

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;
duplicate -n Main Main_icon;
parent Main "Group";
xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];

//--3rd level transforms--//
parent FitSkeleton Main;
createNode -n MotionSystem transform;
createNode -n DeformationSystem transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	}
parent MotionSystem DeformationSystem Main;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
//createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;	
setAttr BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;

//--6th level transforms--//
createNode -n IKRootConstraint -p IKHandle transform;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
connectAttr -f Main.fkIkVis FKIKSystem.v;
//addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
//connectAttr -f Main.aimVis AimSystem.v;
//addAttr -k 1 -ln eyeVis -at bool -dv 1 Main;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;
createNode -n jointLayer displayLayer;
setAttr jointLayer.displayType 2;

//Analyze
string $markers[]=`asGetMarkersSorted`;
for ($i=0;$i<size($markers);$i++)
	{
	//Analyze $markerSide
	$markerSide[$i]="_R";
	$pos=`xform -q -ws -t $markers[$i]`;
	if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
		$markerSide[$i]="_M";

	//Analyze $markerNoMirror
	$parent=$markers[$i];
	while ($parent!="")
		{
		if (`attributeExists noMirror $parent`)
			if (`getAttr ($parent+".noMirror")`==1)
				{
				$markerNoMirror[$i]=1;
				break;
				}
		$tempString=`listConnections ($parent+".message")`;
		$tempString2=`listConnections -p 1 ($parent+".message")`;
		$parent="";
		for ($y=0;$y<size($tempString2);$y++)
			if (`gmatch $tempString2[$y] "*[.]child"` || `gmatch $tempString2[$y] "*[.]otherChildren*"`)
				$parent=$tempString[$y];
		}

	//Analyze $markerIsEndJoint
	if (`attributeExists child $markers[$i]`)
		$markerIsEndJoint[$i]=0;
	else
		$markerIsEndJoint[$i]=1;
	//Analyze rotateOrder
	$markerRotOrder[$i]=`getAttr ($markers[$i]+".rotateOrder")`;
	//Analyze markerParent
	$messageConnections=`listConnections -s 0 -d 1 ($markers[$i]+".message")`;
	$messageConnectionsWithPlug=`listConnections -s 0 -d 1 -p 1 ($markers[$i]+".message")`;
	for ($y=0;$y<size($messageConnections);$y++)
		{
		//.child
		if (`attributeExists child $messageConnections[$y]`)
			if (`isConnected ($markers[$i]+".message") ($messageConnections[$y]+".child")`)
				$markerParent[$i]=$messageConnections[$y];
		//.otherChildren
		if (`attributeExists otherChildren $messageConnections[$y]`)
			{
			int $numOtherChildren=`getAttr -size ($messageConnections[$y]+".otherChildren")`;
			for ($z=0;$z<$numOtherChildren;$z++)
				if (`isConnected ($markers[$i]+".message") ($messageConnections[$y]+".otherChildren["+$z+"]")`)
					$markerParent[$i]=$messageConnections[$y];
			}
		}
/*
	if (`attributeExists parent $markers[$i]`)
		{
		$tempString=`listConnections ($markers[$i]+".parent")`;
		if (size($tempString))
			$markerParent[$i]=$tempString[0];
		}
*/
	//Analyze markerParentSide
	if ($markerParent[$i]!="")
		{
		$markerParentSide[$i]="_R";
		$temp=`xform -q -ws -t $markerParent[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$markerParentSide[$i]="_M";
		}
	//Analyze markerChild
	if (`attributeExists child $markers[$i]`)
		{
		$tempString=`listConnections -s 1 -d 0 ($markers[$i]+".child")`;
		if ($tempString[0]!="")
			$markerChild[$i]=$tempString[0];
		}

	//Analyze markerChildSide
	if ($markerChild[$i]!="")
		{
		$markerChildSide[$i]="_R";
		$temp=`xform -q -ws -t $markerChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$markerChildSide[$i]="_M";
		}
	//Analyze markerTwists
	if (`attributeExists twists $markers[$i]`)
		$markerTwists[$i]=`getAttr ($markers[$i]+".twists")`;
	
	//Analyze markerUpTwists
	if ($markerParent[$i]!="")
		if (`attributeExists twists $markerParent[$i]`)
			$markerUpTwists[$i]=`getAttr ($markerParent[$i]+".twists")`;

	//Analyze markerTwists
	if (`attributeExists bendCtrls $markers[$i]`)
		$markerBendControls[$i]=`getAttr ($markers[$i]+".bendCtrls")`;

	//Analyze markerUpBendControls
	if ($markerParent[$i]!="")
		if (`attributeExists bendCtrls $markerParent[$i]`)
			$markerUpBendControls[$i]=`getAttr ($markerParent[$i]+".bendCtrls")`;

	//Analyze global
	if (`attributeExists "global" $markers[$i]`)
		$markerGlobal[$i]=`getAttr ($markers[$i]+".global")`;

	//Analyze markerLenght
	$markerLenght[$i]=1;
	if ($markerChild[$i]!="")
		{
		$pos2=`xform -q -ws -t $markerChild[$i]`;
		$markerLenght[$i]=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		}

	//Analyze markerSystem($ms),$markerInIK,$msSolver
	$ms[$i]=`asGetMarkerSystem $markers[$i]`;
	if ($ms[$i]!="")
		$msType[$i]=`getAttr ($ms[$i]+"System.type")`;
	if ($msType[$i]=="Arm" || $msType[$i]=="Leg")
		{
		$markerInIK[$i]=1;
		$msSolver[$i]="ikRPsolver";
		}
	if ($msType[$i]=="Spine" || $msType[$i]=="Tail" || $msType[$i]=="Basic")
		if (!`asIsMayaLT`)
			{
			$markerInIK[$i]=1;
			$msSolver[$i]="ikSplineSolver";
			}
	//Analyze $msNic ($markerSystemNumberOfIKControls)
	if (`attributeExists ikCtrls $markers[$i]`)
		$msNic[$i]=`getAttr ($markers[$i]+".ikCtrls")`;
	//Analyze $msComponent,$msStart,$msMid,$msEnd,$msEndEnd,$msToes,$msToesEnd,$msScapula,$footRotY
	$tempString=`listConnections -s 0 -d 1 ($markers[$i]+".message")`;
	$tempString2=`listConnections -s 0 -d 1 -p 1 ($markers[$i]+".message")`;

	clear $messageConnections;
	clear $messageConnectionsWithPlug;
	//Filter connections, only connected to *System*, ignoring .segments
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*System*"`)
			if (!`gmatch $tempString2[$y] "*[.]segments*"`)
				{
				$messageConnections[size($messageConnections)]=$tempString[$y];
				$messageConnectionsWithPlug[size($messageConnectionsWithPlug)]=$tempString2[$y];
				}
	//Then pickup .segments connections, if no other connection
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*System*"`)
			if (`gmatch $tempString2[$y] "*[.]segments*"`)
				if (size($messageConnections)==0)
					{
					$messageConnections[size($messageConnections)]=$tempString[$y];
					$messageConnectionsWithPlug[size($messageConnectionsWithPlug)]=$tempString2[$y];
					}

	for ($y=0;$y<size($messageConnections);$y++)
		{
		tokenize $messageConnectionsWithPlug[$y] "." $tempString;
		$msComponent[$i]=$tempString[1];
		$tempString=`listConnections ($ms[$i]+"System.start")`;
		$msStart[$i]=$tempString[0];
		$tempString=`listConnections ($ms[$i]+"System.mid")`;
		$msMid[$i]=$tempString[0];
		$tempString=`listConnections ($ms[$i]+"System.end")`;
		$msEnd[$i]=$tempString[0];
		$tempString=`listConnections ($ms[$i]+"System.endEnd")`;
		$msEndEnd[$i]=$tempString[0];
		if (`attributeExists toes ($ms[$i]+"System")`)
			{
			$tempString=`listConnections ($ms[$i]+"System.toes")`;
			$msToes[$i]=$tempString[0];
			}
		if (`attributeExists toesEnd ($ms[$i]+"System")`)
			{
			$tempString=`listConnections ($ms[$i]+"System.toesEnd")`;
			$msToesEnd[$i]=$tempString[0];
			}
		if (`attributeExists scapula  ($ms[$i]+"System")`)
			{
			$tempString=`listConnections ($ms[$i]+"System.scapula")`;
			$msScapula[$i]=$tempString[0];
			if ($markers[$i]==$msScapula[$i])
				$isScapula[$i]=1;
			}
		if (`attributeExists footRotY ($ms[$i]+"System")`)
			$footRotY[$i]=`getAttr ($ms[$i]+"System.footRotY")`+90;
		}
	}

//If Mid & End are same, preffer End (affects short Basic-chains)
for ($i=0;$i<size($markers);$i++)
	if ($msComponent[$i]=="mid")
		if ($msEnd[$i]==$markers[$i])
			$msComponent[$i]="end";

//Analyze FirstAfterIK
for ($i=0;$i<size($markers);$i++)
	{
	if ($markers[$i]=="Root")
		continue;
	for ($y=0;$y<size($markers);$y++)
		if ($markers[$y]==$markerParent[$i])
			$parentMs=$ms[$y];
	if ($ms[$i]!=$parentMs)
		$markerFirstAfterIK[$i]=1;
	}

//Re-oranize $parent/$child/$InIK/$IsEndJoin/$markerFirstAfterIK/$ms(+start,mid,end) info around Scapula
for ($i=0;$i<size($markers);$i++)
	{
	if ($isScapula[$i])
		{
		$markerInIK[$i]=0;
		$markerIsEndJoint[$i]=0;
		for ($y=0;$y<size($markers);$y++)
			if ($markers[$y]==$markerParent[$i])
				{
				//Scapula use $markerParent, from shoulder
				$markerParent[$i]=$markerParent[$y];
				$markerParentSide[$i]=$markerParentSide[$y];
				//Shoulder`s $markerParent, be Scapula
				$markerParent[$y]=$markers[$i];
				$markerParentSide[$y]=$markerSide[$i];
				//Scapula`s child is shoulder
				$markerChild[$i]=$markers[$y];
				$markerChildSide[$i]=$markerSide[$i];
				//Update $markerUpTwists/$markerUpBendControls
				$markerUpTwists[$i]=`getAttr ($markerParent[$i]+".twists")`;
				$markerUpBendControls[$i]=`getAttr ($markerParent[$i]+".bendCtrls")`;
				//Update $markerFirstAfterIK
				$markerFirstAfterIK[$i]=$markerFirstAfterIK[$y];
				$markerFirstAfterIK[$y]=0;
				//Update $ms
				$ms[$i]=$ms[$y];
				$msStart[$i]=$msStart[$y];
				$msMid[$i]=$msMid[$y];
				$msEnd[$i]=$msEnd[$y];
				$msEndEnd[$i]=$msEndEnd[$y];
				break;
				}
		//update $markerLenght
		$pos=`xform -q -ws -t $markers[$i]`;
		$pos2=`xform -q -ws -t $markerChild[$i]`;
		$markerLenght[$i]=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		}
	}

//Analyze.. update $markerInIK (now that $msStart is known, check if numIKCtrls set to 0)
for ($i=0;$i<size($markers);$i++)
	if (`attributeExists ikCtrls $msStart[$i]`)
		if (`getAttr ($msStart[$i]+".ikCtrls")`==0)
			$markerInIK[$i]=0;

//Analyze $msFKInIK
for ($i=0;$i<size($markers);$i++)
	if (`attributeExists FKInIK $msStart[$i]`)
		$msFKInIK[$i]=`getAttr ($msStart[$i]+".FKInIK")`;

//Analyze more (now that $ms for each marker is known)
for ($i=0;$i<size($markers);$i++)
	{
	$msBfc[$i]=1;
	$msUfcWhich[$i]=$markers[$i]; //$msUfcWhich( which FKControl controls this one. Self by default)
	//Analyze $msNfc(numberFkControls)
	if ($ms[$i]=="")
		continue;
	$systemMarkers=`asGetSystemMarkers ($ms[$i]+"System")`;
	string $firstSM=$systemMarkers[size($systemMarkers)-1];
	if (`attributeExists fkCtrls $firstSM`)
		$msNfc[$i]=`getAttr ($firstSM+".fkCtrls")`;
	//Analyze $msUfc(useFkControl, meaning useDistributedFkControl(This is a distributor))
	if (`attributeExists segments $firstSM`)
		if (`getAttr ($firstSM+".segments")`!=$msNfc[$i])
			$msUfc[$i]=1;
	if (!$msUfc[$i])
		continue;
	//Analyze $msBfc(do buildFkControl)
	string $reverseSystemMarkers[];
	clear $reverseSystemMarkers;
	for ($y=size($systemMarkers)-1;$y>-1;$y--)
		$reverseSystemMarkers[size($reverseSystemMarkers)]=$systemMarkers[$y];

	if (`size($reverseSystemMarkers)`>1)
		for ($y=0;$y<size($reverseSystemMarkers);$y++)
				if ($markers[$i]==$reverseSystemMarkers[$y])
					if (($y%(size($reverseSystemMarkers)/$msNfc[$i])))
						$msBfc[$i]=0;
					else
						{
						//$shareFK, how many FK to distribute to
						if ($msNfc[$i]==1)
							$msSfc[$i]=size($reverseSystemMarkers)-1/$msNfc[$i];
						else
							$msSfc[$i]=size($reverseSystemMarkers)/$msNfc[$i];//$shareFK, how many FK to distribute to
						}

	if (`gmatch $markers[$i] "*Head*"`)//Head always needs FK control
		{
		$msBfc[$i]=1;
		$msUfc[$i]=0;
		}

	//Analyze $msUfcWhich( which FKControl controls this one)
	string $whichFkControl;
	for ($y=0;$y<size($reverseSystemMarkers);$y++)
		{
		if ($msSfc[$i]>0)
			if (!($y%$msSfc[$i]))
				{
				$whichFkControl=$reverseSystemMarkers[$y];
				$msUfcWhich[$i]=$whichFkControl;
				if ($reverseSystemMarkers[$y]==$markers[$i])
					break;
				}
		$msUfcWhich[$i]=$whichFkControl;
		}
	}

//Analyze $msLenght
for ($i=0;$i<size($markers);$i++)
	{
	$msLenght[$i]=0;
	if ($ms[$i]=="" || $msStart[$i]=="" || $msEnd[$i]=="")
		continue;
	$pos =`getAttr ($msStart[$i]+".t")`;
	$pos2=`getAttr ($msMid[$i]+".t")`;
	$msLenght[$i]=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$pos =`getAttr ($msMid[$i]+".t")`;
	$pos2=`getAttr ($msEnd[$i]+".t")`;
	$msLenght[$i]+=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$msLenght[$i]*=$scale;
	}


//--Pre Creation, orient scapula loc--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$isScapula[$i])
			continue;

//		createNode -n tempUpVec transform;
//		setAttr -type float3 tempUpVec.t `getAttr ($ms[$i]+"System.poleX")` `getAttr ($ms[$i]+"System.poleY")` `getAttr ($ms[$i]+"System.poleZ")`;
//		delete `aimConstraint -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject tempUpVec $msStart[$i] $markers[$i]`;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $msStart[$i] $msStart[$i] $markers[$i]`;
//		delete tempUpVec;
		$rot=`getAttr ($markers[$i]+".r")`;
		setAttr -type float3 ($markers[$i]+".rot") $rot[0] $rot[1] $rot[2];
		xform -ws -ro 0 0 0 $markers[$i];
		}

//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

//		if ($msType[$i]=="Leg" && $markers[$i]==$msEndEnd[$i])
//			continue;refresh;

		$pos=`xform -q -ws -t $markers[$i]`;
		$rot=`getAttr ($markers[$i]+".rot")`;
		$joint=$markers[$i]+$side;

		//Creation Deform
		select -cl;
		joint -n $joint;
		sets -add DeformSet $joint;
		setAttr ($joint+".rotateOrder") $markerRotOrder[$i];
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;

		if ($side=="_L")
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation Twists
		select $joint;
		for ($y=1;$y<($markerTwists[$i]+1);$y++)
			{
			joint -n ($markers[$i]+"Part"+$y+$side);
			sets -add DeformSet ($markers[$i]+"Part"+$y+$side);
			setAttr ($markers[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($markers[$i]+".rotateOrder")`;
			}

		if ($isScapula[$i])
			addAttr -k 0 -ln Scapula -at bool -dv 1 $joint;

		if($markers[$i]=="Root")
			connectAttr -f jointLayer.drawInfo Root_M.drawOverride;
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!`objExists ($markers[$i]+$side)`)
			continue;refresh;

		$joint=$markers[$i]+$side;
		$parentJoint=$markerParent[$i]+$parentSide;
		if ($markerParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Delete endJoints that have siblings, and re-assign $markerChild (preffered sameSide)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markers[$i]==$msToesEnd[$i])
			continue;
		if ($markers[$i]=="HeadEnd")
			continue;

		clear $tempString;
		if (`objExists ($markerParent[$i]+$parentSide)`)
			$tempString=`listRelatives -c -type joint ($markerParent[$i]+$parentSide)`;
		int $siblings=0;
		for ($y=0;$y<size($tempString);$y++)
			if (!`gmatch $tempString[$y] "*Part[0-9]*"`)
				$siblings++;
		if (`gmatch $markers[$i] "*End"` && $siblings>1)
			{
			delete ($markers[$i]+$side);
			//and find the parent, and replace the parent`s $markerChild (preffered sameSide)
			string $newMarkerChild="";
			for ($z=0;$z<size($markers);$z++)
				if ($markerChild[$z]==$markers[$i])
					for ($zz=0;$zz<size($markers);$zz++)
						if ($markerParent[$zz]==$markers[$z])
							{
							if ($markers[$zz]==$markers[$i])
								continue;
							if ($markerSide[$zz]==$markerSide[$z])
								{
								$numLetters=size($markers[$zz]);
								$markerChild[$z]=$markers[$zz];
								$newMarkerChild=$markerChild[$z];
								break;
								}
							$markerChild[$z]=$markers[$zz];
							$newMarkerChild=$markerChild[$z];
							for ($zzz=0;$zzz<size($markers);$zzz++)
								if ($markers[$zzz]==$markerChild[$z])
									$markerChildSide[$z]=$markerSide[$zzz];
							}
			//and recalc uptwist for the new $markerChild, as this might have changed
			for ($z=0;$z<size($markers);$z++)
				if ($markerChild[$z]==$newMarkerChild)
					{
					//Analyze markerUpTwists
					if ($markerParent[$z]!="")
						if (`attributeExists twists $markerParent[$z]`)
							$markerUpTwists[$z]=`getAttr ($markerParent[$z]+".twists")`;
					}
			}
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1 && $markerChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerTwists[$i]<1)
			continue;refresh;

		float $twistDistance=`getAttr ($markerChild[$i]+$childSide+".t"+$D)`/($markerTwists[$i]+1.0);
		for ($y=1;$y<($markerTwists[$i]+1);$y++)
			setAttr ($markers[$i]+"Part"+$y+$side+".t"+$D) $twistDistance;
		//reParent child to last twist
		if ($markerTwists[$i]>0)
			parent ($markerChild[$i]+$childSide) ($markers[$i]+"Part"+$markerTwists[$i]+$side);
		}

//Freeze rotation(move to jointOrient)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!`objExists ($markers[$i]+$side)`)
			continue;refresh;

		$joint=$markers[$i]+$side;
		makeIdentity -a 1 -r 1 $joint;
		}

//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;
		if ($markerChild[$i]=="")
			continue;refresh;

		$pos=`xform -q -ws -t ($markers[$i]+$side)`;
		$rot=`xform -q -ws -ro ($markers[$i]+$side)`;

		if ($msBfc[$i])//(buildFkControl)
			{
			asCreateController "FK" $markers[$i] $side $markers[$i];
			setAttr ("FKExtra"+$markers[$i]+$side+".overrideEnabled") 1;
			createNode -n ("FKXOffset"+$markers[$i]+$side) transform;
			setAttr ("FKXOffset"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			parent ("FKXOffset"+$markers[$i]+$side) ("FK"+$markers[$i]+$side);
			select ("FKXOffset"+$markers[$i]+$side);
			joint -n ("FKX"+$markers[$i]+$side);
			connectAttr -f jointLayer.drawInfo ("FKX"+$markers[$i]+$side+".drawOverride");
			setAttr ("FKX"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			$tempString=`listRelatives -type joint -p ($markers[$i]+$side)`;
			if (`objExists $tempString[0]`)
				{
				delete `parentConstraint $tempString[0] ("FKXOffset"+$markers[$i]+$side)`;
/*
				$parentPos=`xform -q -ws -t $tempString[0]`;
				$parentRot=`xform -q -ws -ro $tempString[0]`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("FKXOffset"+$markers[$i]+$side);
*/
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$markers[$i]+$side);
				makeIdentity -a 1 -r 1 ("FKX"+$markers[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKXOffset"+$markers[$i]+$side);
			if ($msUfc[$i])//using distributedFK
				{
				$multipleDivide=`createNode -n ("FKX"+$markers[$i]+"MultiplyDivide"+$side) multiplyDivide`;
				setAttr ("FKX"+$markers[$i]+"MultiplyDivide"+$side+".operation") 2;
				connectAttr ("FK"+$markers[$i]+$side+".r") ("FKX"+$markers[$i]+"MultiplyDivide"+$side+".input1");
				setAttr -type float3 ("FKX"+$markers[$i]+"MultiplyDivide"+$side+".input2") $msSfc[$i] $msSfc[$i] $msSfc[$i];				
				parent ("FKXOffset"+$markers[$i]+$side) ("FKExtra"+$markers[$i]+$side);
				connectAttr ($multipleDivide+".output") ("FKX"+$markers[$i]+$side+".r");
				pointConstraint ("FK"+$markers[$i]+$side) ("FKX"+$markers[$i]+$side);
				}
			}
		else//distribute fkcontrol
			{
			select ("FKX"+$markerParent[$i]+$parentSide);
			joint -n ("FKX"+$markers[$i]+$side);
			setAttr ("FKX"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$markers[$i]+$side);
			makeIdentity -a 1 -r 1 ("FKX"+$markers[$i]+$side);
			connectAttr ("FKX"+$msUfcWhich[$i]+"MultiplyDivide"+$side+".output") ("FKX"+$markers[$i]+$side+".r");
			}

		if($markerGlobal[$i])
			{
			createNode -n ("FKGlobalStatic"+$markers[$i]+$side) -p ("FKOffset"+$markers[$i]+$side) transform;
			setAttr ("FKGlobalStatic"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			duplicate -n ("FKGlobal"+$markers[$i]+$side) ("FKGlobalStatic"+$markers[$i]+$side);
			duplicate -n ("Global"+$markers[$i]+$side) ("FKGlobalStatic"+$markers[$i]+$side);
			duplicate -n ("GlobalOffset"+$markers[$i]+$side) ("FKGlobalStatic"+$markers[$i]+$side);

			parent ("FKGlobal"+$markers[$i]+$side) ("FKGlobalStatic"+$markers[$i]+$side);
			parent ("FKExtra"+$markers[$i]+$side) ("FKGlobal"+$markers[$i]+$side);
			parent ("Global"+$markers[$i]+$side) ("GlobalOffset"+$markers[$i]+$side);
			parent ("GlobalOffset"+$markers[$i]+$side) GlobalSystem;

			orientConstraint ("Global"+$markers[$i]+$side) ("FKGlobalStatic"+$markers[$i]+$side) ("FKGlobal"+$markers[$i]+$side);
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv 0 ("FK"+$markers[$i]+$side);
			createNode -n ("globalReverse"+$markers[$i]+$side) reverse;
			createNode -n ("globalUnitConversion"+$markers[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$markers[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$markers[$i]+$side+".Global") ("globalUnitConversion"+$markers[$i]+$side+".input");
			connectAttr ("globalUnitConversion"+$markers[$i]+$side+".output") ("globalReverse"+$markers[$i]+$side+".inputX");
			connectAttr ("globalUnitConversion"+$markers[$i]+$side+".output") ("FKGlobal"+$markers[$i]+$side+"_orientConstraint1.Global"+$markers[$i]+$side+"W0");
			connectAttr ("globalReverse"+$markers[$i]+$side+".outputX") ("FKGlobal"+$markers[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$markers[$i]+$side+"W1");
			}

		if ($markerInIK[$i] && $msComponent[$i]=="end" && $msSolver[$i]=="ikRPsolver")
			{
			createNode -n ("AlignIKTo"+$markers[$i]+$side) transform;
			setAttr ("AlignIKTo"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			parent ("AlignIKTo"+$markers[$i]+$side) ("FKX"+$markers[$i]+$side);
			setAttr -type float3 ("AlignIKTo"+$markers[$i]+$side+".t") 0 0 0;
			}
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;
		if ($markerChild[$i]=="")
			continue;refresh;

		if ($markerParent[$i]=="")
			parent ("FKOffset"+$markers[$i]+$side) FKSystem;

		else if ($markerFirstAfterIK[$i])
			{
			$parentContraintToXform="FKParentConstraintTo"+$markerParent[$i]+$parentSide;
			if (!`objExists $parentContraintToXform`)
				{
				createNode -n $parentContraintToXform -p FKSystem transform;
				//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
				asAlign $parentContraintToXform ($markerParent[$i]+$parentSide) 1 0 0 0;
//				parentConstraint -mo ($markerParent[$i]+$parentSide) $parentContraintToXform;
				parentConstraint ($markerParent[$i]+$parentSide) $parentContraintToXform;

				if ($markerParent[$i]=="Wrist")
					connectAttr Main.fingerVis ($parentContraintToXform+".v");
				}
			parent ("FKOffset"+$markers[$i]+$side) $parentContraintToXform;
			connectAttr -f jointLayer.drawInfo ("FKOffset"+$markers[$i]+$side+".drawOverride");
	
			}
		else if ($msBfc[$i])
			parent ("FKOffset"+$markers[$i]+$side) ("FKX"+$markerParent[$i]+$parentSide);
		}

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		//fingers/toes to scale up with hand/foot, and anything below head
		if ((`gmatch $msType[$i] "*Finger"` && $msComponent[$i]=="start") || $msComponent[$i]=="toes" || $markerParent[$i]=="Head")
			{
			setAttr ($markers[$i]+$side+".segmentScaleCompensate") 0;
			$parentContraintToXform="FKParentConstraintTo"+$markerParent[$i]+$parentSide;
			if (`objExists $parentContraintToXform`)
				scaleConstraint ($markerParent[$i]+$parentSide) $parentContraintToXform;
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i] && $markers[$i]!=$msToesEnd[$i])
			continue;
		if (!$markerInIK[$i])
			continue;refresh;

		$pos=`xform -q -ws -t ($markers[$i]+$side)`;
		$rot=`xform -q -ws -ro ($markers[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$markers[$i]+$side);
		setAttr ("IKX"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
		if ($msComponent[$i]=="start")
			{
			createNode -n ("IKParentConstraint"+$markers[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			createNode -n ("IKXOffset"+$markers[$i]+$side) transform;
			setAttr ("IKXOffset"+$markers[$i]+$side+".rotateOrder") $markerRotOrder[$i];
			parent ("IKX"+$markers[$i]+$side) ("IKXOffset"+$markers[$i]+$side);
			if (`objExists ($markerParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($markerParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($markerParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$markers[$i]+$side);
				if ($msSolver[$i]!="ikSplineSolver")
					parentConstraint ($markerParent[$i]+$parentSide) ("IKParentConstraint"+$markers[$i]+$side);
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$markers[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$markers[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$markers[$i]+$side);
			asAlign ("IKXOffset"+$markers[$i]+$side) ($markers[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$markers[$i]+$side) ("IKParentConstraint"+$markers[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$markers[$i]+$side);
		if ($msComponent[$i]=="start" && $msSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$markers[$i]+$side) -p ("IKParentConstraint"+$markers[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$markers[$i]+$side) ("IKX"+$markers[$i]+$side) 1 1 0 1;
			}
		if ($msComponent[$i]=="start")
			connectAttr -f jointLayer.drawInfo ("IKX"+$markers[$i]+$side+".drawOverride");
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i] && $markers[$i]!=$msToesEnd[$i])
			continue;
		if (!$markerInIK[$i])
			continue;refresh;

		if ($msComponent[$i]=="start")
			parent ("IKParentConstraint"+$markers[$i]+$side) IKJoints;
		else
			{
			parent ("IKX"+$markers[$i]+$side) ("IKX"+$markerParent[$i]+$parentSide);
			makeIdentity -a 1 -r 1 ("IKX"+$markers[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;
		if ($markerChild[$i]=="")
			continue;refresh;

		parentConstraint ("FKX"+$markers[$i]+$side) ($markers[$i]+$side);
		if ($markerInIK[$i])
			parentConstraint -w 0 ("IKX"+$markers[$i]+$side) ($markers[$i]+$side);
//		setAttr ($markers[$i]+$side+"_parentConstraint1.interpType") 2;
		parent ($markers[$i]+$side+"_parentConstraint1") ConstraintSystem;
		}

//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($msComponent[$i]!="end")
			continue;refresh;

		$systemMarkers=`asGetSystemMarkers ($ms[$i]+"System")`;

		//IKSp jointChain
		if ($msSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$ms[$i]+"Offset"+$side) -p IKJoints transform;
			asAlign ("IKSp"+$ms[$i]+"Offset"+$side) ("FKX"+$msStart[$i]+$side) 1 0 0 1;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$msStart[$i]+$side) ($msEnd[$i]+$side) ("IKSp"+$ms[$i]+"Offset"+$side)`;
			for ($y=1;$y<size($systemMarkers);$y++)
				{
				select ("IKSp"+$ms[$i]+"Offset"+$side);
				joint -n ("IKSp"+$systemMarkers[$y]+$side);
//				connectAttr ("IKSp"+$systemMarkers[$y]+$side+".r") ("IKX"+$systemMarkers[$y]+$side+".r");
//				parent ("IKSp"+$ms[$i]+$systemMarkers[$y]+$side) ("IKSp"+$ms[$i]+"Offset"+$side);
				}
			//distribute IKSp joints straight and evenly
			for ($y=1;$y<size($systemMarkers);$y++)
				{
				float $posFactor=0;
				$posFactor=(1.0/(`size($systemMarkers)`-2)*($y-1));
				pointConstraint -w $posFactor ($msStart[$i]+$side) ("IKSp"+$systemMarkers[$y]+$side);
				pointConstraint -w (1-$posFactor) ($msEnd[$i]+$side) ("IKSp"+$systemMarkers[$y]+$side);
				delete ("IKSp"+$systemMarkers[$y]+$side+"_pointConstraint1");
				}
			//parent IKSp joints
			for ($y=1;$y<size($systemMarkers)-1;$y++)
				parent ("IKSp"+$systemMarkers[$y]+$side) ("IKSp"+$systemMarkers[$y+1]+$side);
			}

		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($msSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$msStart[$i]+$side);
			joint -n ("IKfake0"+$ms[$i]+$side);
			setAttr -l 1 ("IKfake0"+$ms[$i]+$side+".v") 0;
//			connectAttr -f jointLayer.drawInfo ("IKfake0"+$ms[$i]+$side+".drawOverride");
			parent ("IKfake0"+$ms[$i]+$side) ("IKParentConstraint"+$msStart[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$msStart[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$ms[$i]+$side);
			$tempString=`listRelatives -p ("IKSp"+$msEnd[$i]+$side)`;
			select $tempString[0];
			joint -n ("IKfake1"+$ms[$i]+$side);
			joint -n ("IKfake2"+$ms[$i]+$side);
			joint -n ("IKfake3"+$ms[$i]+$side);
			asAlign ("IKfake2"+$ms[$i]+$side) ("IKSp"+$msEnd[$i]+$side) 1 1 1 0;
			$tempString=`listRelatives -p $tempString[0]`;
			parent ("IKfake1"+$ms[$i]+$side) $tempString[0];
			setAttr -l 1 ("IKfake1"+$ms[$i]+$side+".visibility") 0;
			setAttr ("IKfake3"+$ms[$i]+$side+".tx") `getAttr ("IKfake2"+$ms[$i]+$side+".tx")`;			
			}

		string $startJoint="IKX"+$msStart[$i]+$side;
		string $endJoint="IKX"+$msEnd[$i]+$side;
		if ($msSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$ms[$i]+$side;
			$endJoint="IKfake2"+$ms[$i]+$side;
			if (`objExists ("IKfake2"+$ms[$i]+$side)`)
				$endJoint="IKfake3"+$ms[$i]+$side;
			}
		joint -e -setPreferredAngles -children $startJoint;

		$tempString=`ikHandle -n ("IK"+$ms[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $msSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$ms[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$ms[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$ms[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$ms[$i]+"Effector"+$side+".rotateOrder") $markerRotOrder[$i];
		if ($msSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $ms[$i] $side $markers[$i];		
			parent ("IK"+$ms[$i]+"Handle"+$side) ("IK"+$ms[$i]+$side);
			//pole
			asCreateController "Pole" $ms[$i] $side $markers[$i];	
			asLockAttr ("Pole"+$ms[$i]+$side) 0 1 1 1;
			$temp[0]=`getAttr ($ms[$i]+"System.poleX")`;
			$temp[1]=`getAttr ($ms[$i]+"System.poleY")`;
			$temp[2]=`getAttr ($ms[$i]+"System.poleZ")`;
			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$ms[$i]+$side);
			poleVectorConstraint ("Pole"+$ms[$i]+$side) ("IK"+$ms[$i]+"Handle"+$side);
			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			string $direction=`rename $tempString[0] ("PoleAnnotation"+$ms[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
			parent $direction ("IKX"+$msMid[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
			connectAttr ("Pole"+$ms[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAligned"+$ms[$i]+$side) -p ("IK"+$ms[$i]+$side) transform;
			asAlign ("IKFKAligned"+$ms[$i]+$side) ($msEnd[$i]+$side) 0 1 0 0;
			orientConstraint ("IKFKAligned"+$ms[$i]+$side) ("IKX"+$msEnd[$i]+$side);
			//$msFKInIK
			if ($msFKInIK[$i])
				{
				asCreateController "FKInIK" $ms[$i] $side $markers[$i];
				asAlign ("FKInIKOffset"+$ms[$i]+$side) ($msEnd[$i]+$side) 0 1 0 0;
				parent ("FKInIKOffset"+$ms[$i]+$side) ("IK"+$ms[$i]+$side);
				asLockAttr ("FKInIK"+$ms[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$ms[$i]+$side) ("FKInIK"+$ms[$i]+$side);
				}
			}
		if ($msSolver[$i]=="ikSplineSolver")
			{
//			if ($msType[$i]=="Spine")
//				$msNic[$i]=3;
//			else if ($msType[$i]=="Tail")
			$msNic[$i]=`getAttr ($msStart[$i]+".ikCtrls")`;
			if (`getAttr ($msStart[$i]+".ikCtrls")`==1)//if 1 Ik control, build 2, but expose 1
				$msNic[$i]=2;
			parent ("IK"+$ms[$i]+"Handle"+$side) IKHandle;
			string $crvCmd="curve -n IK"+$ms[$i]+"Curve"+$side+" -d 3";
			for ($z=0;$z<$msNic[$i]+2;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$ms[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$ms[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$ms[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$ms[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$ms[$i]+"Curve"+$side) IKCurve;

			$ikControlNr=1;
			for ($z=0;$z<$msNic[$i]+2;$z++)
				{
				spaceLocator -n ("IK"+$ms[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$ms[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$ms[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$ms[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				float $posFactor=0;
				if ($z>1)
					$posFactor=($z-1)/($msNic[$i]-1.0);
				if ($z>$msNic[$i]-1)
				    $posFactor=1;
				float $invPosFactor=1-$posFactor;
				$tempString=`pointConstraint -w $invPosFactor ("IKSp"+$msStart[$i]+$side) ("IK"+$ms[$i]+"Locator"+$z+$side)`;
				pointConstraint -w $posFactor ("IKSp"+$msEnd[$i]+$side) ("IK"+$ms[$i]+"Locator"+$z+$side);
				delete $tempString[0];

				if ($z!=1 && $z!=$msNic[$i])//Controller for each loc except second and seconLast (they are for stiffness)
					{
					asCreateController "IK" ($ms[$i]+$ikControlNr) $side $msStart[$i];
					parent ("IKOffset"+$ms[$i]+$ikControlNr+$side) IKRootConstraint;
					asAlign ("IKOffset"+$ms[$i]+$ikControlNr+$side) ("IK"+$ms[$i]+"Locator"+$z+$side) 1 1 0 1;
					parent ("IK"+$ms[$i]+"Locator"+$z+$side) ("IK"+$ms[$i]+$ikControlNr+$side);
					$rot=`xform -q -ws -ro ("IKSp"+$msStart[$i]+$side)`;
					if ($D=="x") xform -s 0.1 1 1 ("IK"+$ms[$i]+$ikControlNr+$side+".cv[0:99]");
					if ($D=="y") xform -s 1 0.1 1 ("IK"+$ms[$i]+$ikControlNr+$side+".cv[0:99]");
					if ($D=="z") xform -s 1 1 0.1 ("IK"+$ms[$i]+$ikControlNr+$side+".cv[0:99]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$ms[$i]+$ikControlNr+$side+".cv[0:99]");
					$ikControlNr++;
					}
				}
			//inbetween Ik Controllers to follow start & end (Spine only)
			if ($msType[$i]=="Spine")
				for ($z=2;$z<$msNic[$i];$z++)
					{
					float $weight=(1.0/($msNic[$i]-1))*($z-1);
					parentConstraint -mo -w (1-$weight) ("IK"+$ms[$i]+"1"+$side) ("IKOffset"+$ms[$i]+$z+$side);
					parentConstraint -mo -w $weight ("IK"+$ms[$i]+$msNic[$i]+$side) ("IKOffset"+$ms[$i]+$z+$side);
					}
			//inbetween Ik Controllers: lock rotate
			for ($z=2;$z<$msNic[$i];$z++)
				{
				asLockAttr ("IK"+$ms[$i]+$z+$side) 0 1 0 1;
				asLockAttr ("IKExtra"+$ms[$i]+$z+$side) 0 1 0 1;
				}

			parent ("IK"+$ms[$i]+"Locator1"+$side) ("IK"+$ms[$i]+"1"+$side);
			parent ("IK"+$ms[$i]+"Locator"+$msNic[$i]+$side) ("IK"+$ms[$i]+($ikControlNr-1)+$side);
			connectAttr -f ("IK"+$ms[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$ms[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$ms[$i]+$side) curveInfo;
			connectAttr ("IK"+$ms[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$ms[$i]+$side+".inputCurve");

			if (`getAttr ($msStart[$i]+".ikCtrls")`==1)//if 1 Ik control, build 2, but expose 1
				{
				sets -rm ControlSet ("IK"+$ms[$i]+"1"+$side) ("IKExtra"+$ms[$i]+"1"+$side);
				setAttr -l 1 ("IK"+$ms[$i]+"1"+$side+".v") 0;
				}

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$ms[$i]+$msNic[$i]+$side);
			createNode -n ("IKCurveInfoNormalize"+$ms[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$ms[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$ms[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$ms[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$ms[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$ms[$i]+$side+".input1X");
			connectAttr ("Main.scaleX") ("IKCurveInfoAllMultiply"+$ms[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$ms[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$ms[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$ms[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$ms[$i]+$side+".arcLength")`;
			createNode -n ("stretchy"+$ms[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("stretchy"+$ms[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+$side+".stretchy") ("stretchy"+$ms[$i]+"UnitConversion"+$side+".input");
			createNode -n ("stretchy"+$ms[$i]+"Reverse"+$side) reverse;
			connectAttr ("stretchy"+$ms[$i]+"UnitConversion"+$side+".output") ("stretchy"+$ms[$i]+"Reverse"+$side+".inputX");
			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$msEnd[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++)
				{
				createNode -n ("stretchy"+$ms[$i]+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ("stretchy"+$ms[$i]+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$ms[$i]+$side+".outputX") ("stretchy"+$ms[$i]+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ("stretchy"+$ms[$i]+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ("stretchy"+$ms[$i]+"UnitConversion"+$side+".output") ("stretchy"+$ms[$i]+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ("stretchy"+$ms[$i]+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("stretchy"+$ms[$i]+"MultiplyDivide"+$x+$side+".outputX") ("stretchy"+$ms[$i]+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ("stretchy"+$ms[$i]+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//IKFake (ChestOrientationLock)
			$tempString=`spaceLocator -n ("IKFake1UpLoc"+$ms[$i]+$side)`;
			$loc1=$tempString[0];
			asAlign $loc1 ("IKfake1"+$ms[$i]+$side) 1 1 0 0;
			parent $loc1 ("IKfake1"+$ms[$i]+$side);
			setAttr ($loc1+".translateY") 1;
			$tempString=`listRelatives -p ("IKSp"+$msEnd[$i]+$side)`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $loc1 ("IKfake2"+$ms[$i]+$side) ("IK"+$ms[$i]+$msNic[$i]+$side) $tempString[0]`;
			$constraint=$tempString[0];
			$attrs=`listAttr -k -ud $constraint`;
			connectAttr ("stretchy"+$ms[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
			connectAttr ("stretchy"+$ms[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);


			createNode -n ("IK"+$ms[$i]+"0"+"AlignTo"+$side) transform;
			asAlign ("IK"+$ms[$i]+"0"+"AlignTo"+$side) ("IKSp"+$msStart[$i]+$side) 1 1 0 0;
			parent ("IK"+$ms[$i]+"0"+"AlignTo"+$side) ("IK"+$ms[$i]+"1"+$side);

			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"AlignTo"+$side) transform;
			asAlign ("IK"+$ms[$i]+$msNic[$i]+"AlignTo"+$side) ("IKfake2"+$ms[$i]+$side) 1 1 0 0;
			parent ("IK"+$ms[$i]+$msNic[$i]+"AlignTo"+$side) ("IK"+$ms[$i]+$msNic[$i]+$side);

			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side) transform;
			asAlign ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side) ("IKfake2"+$ms[$i]+$side) 1 0 0 0;
			asAlign ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side) ("IKSp"+$msStart[$i]+$side) 0 1 0 0;
			parent ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side) ("IK"+$ms[$i]+$msNic[$i]+$side);

			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistTo"+$side) transform;
			asAlign ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side) 1 1 0 0;
			parent ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$ms[$i]+$msNic[$i]+"AlignUnIKTwistToOffset"+$side);

			parentConstraint ("IK"+$ms[$i]+"0"+"AlignTo"+$side) ("IKSp"+$msStart[$i]+$side);

			//IK spline FixedEnd
			addAttr -k 1 -ln fixedEnd -at bool -dv 1 ("IK"+$ms[$i]+$msNic[$i]+$side);
			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"ConstraintHolder"+$side) -p ("IKSp"+$msEnd[$i]+$side) transform;
			$tempString=`listRelatives -p ("IKSp"+$msEnd[$i]+$side)`;
			parent ("IK"+$ms[$i]+$msNic[$i]+"ConstraintHolder"+$side) $tempString[0];
			parentConstraint ("IK"+$ms[$i]+$msNic[$i]+"AlignTo"+$side) ("IK"+$ms[$i]+$msNic[$i]+"ConstraintHolder"+$side);

			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendT"+$side) blendColors;
			createNode -n ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendR"+$side) blendColors;
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+"ConstraintHolder"+$side+".t") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendT"+$side+".color1");
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+"ConstraintHolder"+$side+".r") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendR"+$side+".color1");
			connectAttr ($tempString[0]+".t") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendT"+$side+".color2");
			connectAttr ($tempString[0]+".r") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendR"+$side+".color2");
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendT"+$side+".output") ("IKSp"+$msEnd[$i]+$side+".t");
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendR"+$side+".output") ("IKSp"+$msEnd[$i]+$side+".r");
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+$side+".fixedEnd") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendT"+$side+".blender");
			connectAttr ("IK"+$ms[$i]+$msNic[$i]+$side+".fixedEnd") ("IK"+$ms[$i]+$msNic[$i]+"FixedEndBlendR"+$side+".blender");
			


			//IK spline Stiff
			$ikControlNr=1;
			for ($z=0;$z<$msNic[$i]+2;$z++)
				{
				if ($z!=1 && $z!=$msNic[$i])
					continue;
				if ($z==$msNic[$i])
					$ikControlNr=$msNic[$i];
				addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 3 ("IK"+$ms[$i]+$ikControlNr+$side);
				createNode -n ("IKStiff"+$ms[$i]+$z+$side) setRange;
				setAttr ("IKStiff"+$ms[$i]+$z+$side+".minX") 0.01;
				setAttr ("IKStiff"+$ms[$i]+$z+$side+".oldMinX") 0;
				setAttr ("IKStiff"+$ms[$i]+$z+$side+".oldMaxX") 10;
				connectAttr ("IK"+$ms[$i]+$ikControlNr+$side+".stiff") ("IKStiff"+$ms[$i]+$z+$side+".valueX");
				createNode -n ("IKStiffOrient"+$ms[$i]+$z+$side) transform;
				if ($z==1)
					asAlign ("IKStiffOrient"+$ms[$i]+$z+$side) ($msStart[$i]+$side) 1 0 0 0;
				else
					asAlign ("IKStiffOrient"+$ms[$i]+$z+$side) ($msEnd[$i]+$side) 1 0 0 0;
				string $aimAt=$msEnd[$i]+$side;
				float $aimV[3]={1,0,0};
				if ($z==$msNic[$i])
					$aimAt=$msStart[$i]+$side;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($msStart[$i]+$side) $aimAt ("IKStiffOrient"+$ms[$i]+$z+$side)`;
				delete $tempString[0];
				parent ("IK"+$ms[$i]+"Locator"+$z+$side) ("IKStiffOrient"+$ms[$i]+$z+$side);
				parent ("IKStiffOrient"+$ms[$i]+$z+$side) ("IK"+$ms[$i]+$ikControlNr+$side);
				setAttr ("IKStiff"+$ms[$i]+$z+$side+".maxX") ($msLenght[$i]/2.0);
				connectAttr ("IKStiff"+$ms[$i]+$z+$side+".outValueX") ("IK"+$ms[$i]+"Locator"+$z+$side+".translateX");
				}

		parentConstraint -mo ("IK"+$ms[$i]+"0"+"AlignTo"+$side) ("IKParentConstraint"+$msStart[$i]+$side);
		asCreateUnTwister $markers[$i] $side $msStart[$i] $side $ms[$i] $b 1 ("IK"+$ms[$i]+$msNic[$i]+"AlignTo");
		connectAttr ("TwistBalancer"+$markers[$i]+$side+".rotateX") ("IK"+$ms[$i]+"Handle"+$side+".twist");

			//IK spline Follow
			if ($msType[$i]=="Tail" || $msType[$i]=="Basic")
				{
				$ikControlNr=1;
				for ($z=0;$z<$msNic[$i]+2;$z++)
					if ($z!=1 && $z!=$msNic[$i])//Controller for each loc except second and seconLast (they are for stiffness)
						{
						$tempString=`listRelatives -p ($msStart[$i]+$side)`;
						string $ikParent=$tempString[0];
						if ($ikParent!="DeformationSystem")
							asFollow ("IK"+$ms[$i]+$ikControlNr+$side) ("IKOffset"+$ms[$i]+$ikControlNr+$side) $ikParent;
						$ikControlNr++;
						}
				}

			//Constraint to IKSp jointChain
			for ($y=1;$y<size($systemMarkers);$y++)
				{
				createNode -n ("IKSp"+$systemMarkers[$y]+"FollowOffset"+$side) -p ("IKSp"+$systemMarkers[$y]+$side) transform;
				asAlign ("IKSp"+$systemMarkers[$y]+"FollowOffset"+$side) ($systemMarkers[$y]+$side) 1 1 0 0;
				parentConstraint ("IKSp"+$systemMarkers[$y]+"FollowOffset"+$side) ("IKX"+$systemMarkers[$y]+$side);
				}
			}

		if ($msSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if ($msType[$i]=="Leg")
				{
				createNode -n ("PoleAim"+$ms[$i]+$side) transform;
				asAlign ("PoleAim"+$ms[$i]+$side) ("IKX"+$msStart[$i]+$side) 1 0 0 0;
//				if ($msLegAim[$i]!="")
//					asAlign ("PoleAim"+$ms[$i]+$side) ($msLegAim[$i]+$side) 1 0 0 0;
				$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 1 0 0 -worldUpType "objectrotation" -worldUpObject ("IK"+$ms[$i]+$side) ("IK"+$ms[$i]+$side) ("PoleAim"+$ms[$i]+$side)`;
				$constraint=$tempString[0];
				parent ("PoleAim"+$ms[$i]+$side) ("IKHandle");
				pointConstraint Root_M ("PoleAim"+$ms[$i]+$side);
				}

			//Follow
			if ($msType[$i]!="Leg")
				{
				$tempString=`listRelatives -p ($msStart[$i]+$side)`;
				string $ikParent=$tempString[0];
				asFollow ("IK"+$ms[$i]+$side) ("IKOffset"+$ms[$i]+$side) $ikParent;
				}
			if ($msType[$i]=="Leg")
				asFollow ("Pole"+$ms[$i]+$side) ("PoleOffset"+$ms[$i]+$side) ("PoleAim"+$ms[$i]+$side);
			else
				asFollow ("Pole"+$ms[$i]+$side) ("PoleOffset"+$ms[$i]+$side) ("IK"+$ms[$i]+$side);
			}
		}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;


		if ($msComponent[$i]!="toes")
			continue;
		if (!`objExists $msToesEnd[$i]`)
			continue;refresh;

		string $heel="Heel"+$ms[$i];
		
		if ($b==1)//tempHeelLocator
			{
			if (!`objExists deleteMe`)
				createNode -n deleteMe transform;
			spaceLocator -n ("tempHeel"+$ms[$i]+"Locator");
			parent ("tempHeel"+$ms[$i]+"Locator") deleteMe;
			xform -ws -t `getAttr ($ms[$i]+"System.heelX")` 0 `getAttr ($ms[$i]+"System.heelZ")` ("tempHeel"+$ms[$i]+"Locator");
			$sca=`xform -q -os -r -s $msToes[$i]`;
//			$sca=`mulitplyWithFitSkeletonScale $sca`;
			setAttr -type float3 ("tempHeel"+$ms[$i]+"Locator.s") $sca[0] $sca[1] $sca[2];
			duplicate -n ("tempHeel"+$ms[$i]+"Locator_R") ("tempHeel"+$ms[$i]+"Locator");
			duplicate -n ("tempHeel"+$ms[$i]+"Locator_L") ("tempHeel"+$ms[$i]+"Locator");
			setAttr ("tempHeel"+$ms[$i]+"Locator_L.tx") (`getAttr ("tempHeel"+$ms[$i]+"Locator_R.tx")`*-1);

			spaceLocator -n ("tempToesEnd"+$ms[$i]+"Locator");
			parent ("tempToesEnd"+$ms[$i]+"Locator") deleteMe;
			asAlign ("tempToesEnd"+$ms[$i]+"Locator") $msToesEnd[$i] 1 1 0 0;
			setAttr ("tempToesEnd"+$ms[$i]+"Locator.ty") 0;
			$sca=`xform -q -os -r -s $msToesEnd[$i]`;
			setAttr -type float3 ("tempToesEnd"+$ms[$i]+"Locator.s") $sca[0] $sca[1] $sca[2];
			duplicate -n ("tempToesEnd"+$ms[$i]+"Locator_R") ("tempToesEnd"+$ms[$i]+"Locator");
			duplicate -n ("tempToesEnd"+$ms[$i]+"Locator_L") ("tempToesEnd"+$ms[$i]+"Locator");
			setAttr ("tempToesEnd"+$ms[$i]+"Locator_L.tx") (`getAttr ("tempToesEnd"+$ms[$i]+"Locator_R.tx")`*-1);
			}

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$ms[$i]+$side);
		addAttr -k 1 -ln toe -at double ("IK"+$ms[$i]+$side);
		addAttr -k 1 -ln roll -at double -min -5 -max 10 ("IK"+$ms[$i]+$side);
		addAttr -k 1 -ln rollAngle -at double -dv 25 ("IK"+$ms[$i]+$side);

		connectAttr ("IK"+$ms[$i]+$side+".swivel") ("PoleAim"+$ms[$i]+$side+"_aimConstraint1.offset.offsetX");
		$tempString=`listConnections ("PoleAim"+$ms[$i]+$side+"_aimConstraint1.offset.offsetX")`;
		setAttr ($tempString[0]+".conversionFactor") 0.1;

		createNode -n ("IK"+$ms[$i]+"FootRoll"+$side) -p ("IK"+$ms[$i]+$side) transform;
		$temp=`xform -q -ws -t ($msEnd[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$ms[$i]+"FootRoll"+$side);
		setAttr ("IK"+$ms[$i]+"FootRoll"+$side+".ry") ($footRotY[$i]*$b);

		asCreateController "Roll" ($msToes[$i]) $side $msToes[$i];
//		asCreateController "Roll" ($msToesEnd[$i]) $side $msToesEnd[$i];
		asCreateController "Roll" ($msToesEnd[$i]) $side ("tempToesEnd"+$ms[$i]+"Locator");
		asCreateController "Roll" $heel $side ("tempHeel"+$ms[$i]+"Locator");

		setAttr ("RollOffset"+$heel+$side+".ry") ($footRotY[$i]*$b);
		setAttr ("RollOffset"+$msToes[$i]+$side+".ry") ($footRotY[$i]*$b);
		setAttr ("RollOffset"+$msToesEnd[$i]+$side+".ry") ($footRotY[$i]*$b);

		parent ("RollOffset"+$msToes[$i]+$side) ("Roll"+$msToesEnd[$i]+$side);
		parent ("RollOffset"+$msToesEnd[$i]+$side) ("Roll"+$heel+$side);
		parent ("RollOffset"+$heel+$side) ("IK"+$ms[$i]+$side);

		//Pinky/index toe side2side rocking
		if (`objExists $msToes[$i]`)
			{
			createNode -n ("IK"+$ms[$i]+"FootRockInnerPivot"+$side) -p ("IK"+$ms[$i]+$side) transform;
//			createNode -n ("IK"+$ms[$i]+"FootRockOuterPivot"+$side) -p ("IK"+$ms[$i]+$side) transform;
			asAlign ("IK"+$ms[$i]+"FootRockInnerPivot"+$side) ("Roll"+$msToes[$i]+$side) 1 1 0 0;
			setAttr ("IK"+$ms[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			$pos=`xform -q -ws -t ("IK"+$ms[$i]+"FootRockInnerPivot"+$side)`;
			xform -ws -t $pos[0] 0 $pos[2] ("IK"+$ms[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$ms[$i]+"FootRockInnerPivot"+$side) ("Roll"+$msToes[$i]+$side);
			duplicate -n ("IK"+$ms[$i]+"FootRockOuterPivot"+$side) ("IK"+$ms[$i]+"FootRockInnerPivot"+$side);
			setAttr ("IK"+$ms[$i]+"FootRockInnerPivot"+$side+".tx") (`getAttr ($msToes[$i]+".sz")`*$b*$scale);
			setAttr ("IK"+$ms[$i]+"FootRockOuterPivot"+$side+".tx") (`getAttr ($msToes[$i]+".sz")`*$b*$scale*-1);
			parent ("IK"+$ms[$i]+"FootRockInnerPivot"+$side) ("IK"+$ms[$i]+"FootRockOuterPivot"+$side) ("IK"+$ms[$i]+$side);
			
//			xform -r -os -t (`getAttr ($msToes[$i]+".sz")`*$b) 0 0 ("IK"+$ms[$i]+"FootRockInnerPivot"+$side);
//			xform -r -os -t (`getAttr ($msToes[$i]+".sz")`*$b*-1) 0 0 ("IK"+$ms[$i]+"FootRockOuterPivot"+$side);
/*
			$pos=`xform -q -ws -t $msToes[$i]`;
			xform -ws -t (($pos[0]+`getAttr ($msToes[$i]+".sz")`)*$b) 0 $pos[2] ("IK"+$ms[$i]+"FootRockInnerPivot"+$side);
			xform -ws -t (($pos[0]-`getAttr ($msToes[$i]+".sz")`)*$b) 0 $pos[2] ("IK"+$ms[$i]+"FootRockOuterPivot"+$side);
*/
			createNode -n ("IK"+$ms[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$ms[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			else
				setAttr ("IK"+$ms[$i]+"FootRockInnerPivotClamp"+$side+".maxR") 200;
			connectAttr ("Roll"+$msToes[$i]+$side+".rz") ("IK"+$ms[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$ms[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$ms[$i]+"FootRockInnerPivot"+$side+".rz");
			createNode -n ("IK"+$ms[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$ms[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			else
				setAttr ("IK"+$ms[$i]+"FootRockOuterPivotClamp"+$side+".minR") -200;
			connectAttr ("Roll"+$msToes[$i]+$side+".rz") ("IK"+$ms[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$ms[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$ms[$i]+"FootRockOuterPivot"+$side+".rz");
			parent ("IK"+$ms[$i]+"FootRockOuterPivot"+$side) ("IK"+$ms[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$ms[$i]+$side) ("IK"+$ms[$i]+"FootRoll"+$side) ("RollOffset"+$heel+$side) ("IK"+$ms[$i]+"FootRockOuterPivot"+$side);
			if (`objExists ("FKInIKOffset"+$ms[$i]+$side)`)
				parent ("FKInIKOffset"+$ms[$i]+$side) ("IK"+$ms[$i]+"FootRockOuterPivot"+$side);

			createNode -n ("IK"+$ms[$i]+"FootRockReverse"+$side) -p ("Roll"+$msToes[$i]+$side) transform;
			xform -os -t 0 0 0 -ro 0 0 0 ("IK"+$ms[$i]+"FootRockReverse"+$side);
			createNode -n ("IK"+$ms[$i]+"FootRockReverseMultiplyDivide"+$side) multiplyDivide;
			connectAttr ("Roll"+$msToes[$i]+$side+".rz") ("IK"+$ms[$i]+"FootRockReverseMultiplyDivide"+$side+".input1Z");
			setAttr ("IK"+$ms[$i]+"FootRockReverseMultiplyDivide"+$side+".input2Z") -1;
			connectAttr ("IK"+$ms[$i]+"FootRockReverseMultiplyDivide"+$side+".outputZ") ("IK"+$ms[$i]+"FootRockReverse"+$side+".rz");
			}

		if ($msFKInIK[$i])
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p ("IK"+$ms[$i]+$side) transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("FKInIK"+$ms[$i]+$side);
			parent ("IK"+$ms[$i]+"FootRoll"+$side) ("FKInIK"+$ms[$i]+$side);
			}

		$tempString=`ikHandle -n ("IK"+$msToes[$i]+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$msEnd[$i]+$side) -ee ("IKX"+$msToes[$i]+$side)`;
		rename $tempString[1] ("IK"+$msToes[$i]+"Effector"+$side);
		parent ("IK"+$msToes[$i]+"Handle"+$side) ("IK"+$ms[$i]+"FootRockReverse"+$side);
		setAttr -l 1 ("IK"+$msToes[$i]+"Handle"+$side+".v") 0;

		$tempString=`ikHandle -n ("IK"+$msToesEnd[$i]+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$msToes[$i]+$side) -ee ("IKX"+$msToesEnd[$i]+$side)`;
		rename $tempString[1] ("IK"+$msToesEnd[$i]+"Effector"+$side);
		createNode -n ("IK"+$ms[$i]+"LiftToe"+$side) -p ("Roll"+$msToesEnd[$i]+$side) transform;
		asAlign ("IK"+$ms[$i]+"LiftToe"+$side) ($msToes[$i]+$side) 1 0 0 0;
		parent ("IK"+$msToesEnd[$i]+"Handle"+$side) ("IK"+$ms[$i]+"LiftToe"+$side);
		setAttr -l 1 ("IK"+$msToesEnd[$i]+"Handle"+$side+".v") 0;
		connectAttr ("IK"+$ms[$i]+$side+".toe") ("IK"+$ms[$i]+"LiftToe"+$side+".rx");

		//move LegIKHandel to end of RollHierarchy
		parent ("IK"+$ms[$i]+"Handle"+$side) ("IK"+$ms[$i]+"FootRockReverse"+$side);

		createNode -n ($ms[$i]+$side+"AngleReverse") multiplyDivide;
		connectAttr ("IK"+$ms[$i]+$side+".rollAngle") ($ms[$i]+$side+"AngleReverse.input1X");
		setAttr ($ms[$i]+$side+"AngleReverse.input2X") -1;

		createNode -n ("IKRollAngle"+$ms[$i]+$side) setRange;
		connectAttr ("IK"+$ms[$i]+$side+".roll") ("IKRollAngle"+$ms[$i]+$side+".valueX");
		connectAttr ("IK"+$ms[$i]+$side+".roll") ("IKRollAngle"+$ms[$i]+$side+".valueY");
		connectAttr ("IK"+$ms[$i]+$side+".roll") ("IKRollAngle"+$ms[$i]+$side+".valueZ");
		connectAttr ($ms[$i]+$side+"AngleReverse.output.outputX") ("IKRollAngle"+$ms[$i]+$side+".minX");
		connectAttr ("IK"+$ms[$i]+$side+".rollAngle") ("IKRollAngle"+$ms[$i]+$side+".maxY");
		connectAttr ("IK"+$ms[$i]+$side+".rollAngle") ("IKRollAngle"+$ms[$i]+$side+".maxZ");
		setAttr ("IKRollAngle"+$ms[$i]+$side+".oldMinX") -5;
		setAttr ("IKRollAngle"+$ms[$i]+$side+".oldMaxY") 5;
		setAttr ("IKRollAngle"+$ms[$i]+$side+".oldMinZ") 5;
		setAttr ("IKRollAngle"+$ms[$i]+$side+".oldMaxZ") 10;

		connectAttr ("IKRollAngle"+$ms[$i]+$side+".outValueX") ("RollOffset"+$heel+$side+".rotateX");
		connectAttr ("IKRollAngle"+$ms[$i]+$side+".outValueY") ("RollOffset"+$msToes[$i]+$side+".rotateX");
		connectAttr ("IKRollAngle"+$ms[$i]+$side+".outValueZ") ("RollOffset"+$msToesEnd[$i]+$side+".rotateX");
}
if (`objExists deleteMe`)
	delete deleteMe;

//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($msComponent[$i]!="end")
			continue;refresh;

		duplicate -n ("FKIK"+$ms[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$ms[$i]+$side);
		setAttr -type float3 ("FKIK"+$ms[$i]+$side+".scale") ($scale/5.0) ($scale/5.0) ($scale/5.0);
		setAttr ("FKIK"+$ms[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$ms[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$ms[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($msStart[$i]+$side)`;
		string $parent=$tempString[0];
		if(`objExists $parent`)
			parentConstraint $parent ("FKIKParentConstraint"+$ms[$i]+$side);
		else
			parentConstraint ($msStart[$i]+$side) ("FKIKParentConstraint"+$ms[$i]+$side);
		parent ("FKIKParentConstraint"+$ms[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $msStart[$i]`;
		$sca=`mulitplyWithFitSkeletonScale $sca`;
		parent ("FKIK"+$ms[$i]+$side) ($msStart[$i]+$side);
		setAttr -type float3 ("FKIK"+$ms[$i]+$side+".t") (($msLenght[$i]*$b)/4.0) 0 ($sca[2]*2*$b);
		parent ("FKIK"+$ms[$i]+$side) ("FKIKParentConstraint"+$ms[$i]+$side);
		asLockAttr ("FKIK"+$ms[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max 10 -dv 0 ("FKIK"+$ms[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$ms[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$ms[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$ms[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$ms[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$ms[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$ms[$i]+$side+".startJoint") $msStart[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$ms[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$ms[$i]+$side+".middleJoint") $msMid[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$ms[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$ms[$i]+$side+".endJoint") $msEnd[$i];

		createNode -n ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$ms[$i]+$side+".FKIKBlend") ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".input");
		createNode -n ("FKIKBlend"+$ms[$i]+"Reverse"+$side) reverse;
		connectAttr ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$ms[$i]+"Reverse"+$side+".inputX");

		createNode -n ("FKIKBlend"+$ms[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$ms[$i]+"setRange"+$side) setRange;
		setAttr ("FKIKBlend"+$ms[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$ms[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$ms[$i]+$side+".autoVis") ("FKIKBlend"+$ms[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$ms[$i]+$side+".IKVis") ("FKIKBlend"+$ms[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$ms[$i]+$side+".FKVis") ("FKIKBlend"+$ms[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$ms[$i]+$side+".FKIKBlend") ("FKIKBlend"+$ms[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$ms[$i]+$side+".FKIKBlend") ("FKIKBlend"+$ms[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$ms[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$ms[$i]+"Condition"+$side+".colorIfFalseG");


		if ($msSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$ms[$i]+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$ms[$i]+$side+".visibility");
			}
		if ($msSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$msNic[$i]+1;$z++)
				connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$ms[$i]+$z+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorR") ("IK"+$ms[$i]+"Curve"+$side+".visibility");
			setAttr ("IK"+$ms[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$ms[$i]+"Curve"+$side+".overrideDisplayType") 1;
			}
		connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$msStart[$i]+$side+".visibility");
		connectAttr -f ("FKIKBlend"+$ms[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$msStart[$i]+$side+".visibility");
		}

//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;refresh;

		if ($markerInIK[$i])
			{
			connectAttr ("FKIKBlend"+$ms[$i]+"Reverse"+$side+".outputX")       ($markers[$i]+$side+"_parentConstraint1.FKX"+$markers[$i]+$side+"W0");
			connectAttr ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".output") ($markers[$i]+$side+"_parentConstraint1.IKX"+$markers[$i]+$side+"W1");
			}
	}

//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($msComponent[$i]!="start" || $msType[$i]!="Leg")
			continue;
		if (!`getAttr ($markers[$i]+".Scapula")`)
			continue;

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$ms[$i]+$side);
		$tempString=`listRelatives -p ("FKOffset"+$msScapula[$i]+$side)`;
		$parent=$tempString[0];
		createNode -n ("LegAim"+$msScapula[$i]+$side) -p $parent transform;
		asAlign ("LegAim"+$msScapula[$i]+$side) ("FKOffset"+$msScapula[$i]+$side) 1 1 0 0;
		duplicate -n ("LegAimOn"+$msScapula[$i]+$side) ("LegAim"+$msScapula[$i]+$side);
		duplicate -n ("LegAimOff"+$msScapula[$i]+$side) ("LegAim"+$msScapula[$i]+$side);

		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$msScapula[$i]+$side) ("IK"+$ms[$i]+$side) ("LegAimOn"+$msScapula[$i]+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "object" -worldUpObject ("Pole"+$ms[$i]+$side) ("IK"+$ms[$i]+$side) ("LegAimOn"+$msScapula[$i]+$side);
		asAlign ("LegAimOff"+$msScapula[$i]+$side) ("LegAimOn"+$msScapula[$i]+$side) 1 1 0 0;
		orientConstraint ("LegAimOff"+$msScapula[$i]+$side) ("LegAimOn"+$msScapula[$i]+$side) ("LegAim"+$msScapula[$i]+$side);
		parent ("FKOffset"+$msScapula[$i]+$side) ("LegAim"+$msScapula[$i]+$side);

		createNode -n ("IK"+$ms[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$ms[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$ms[$i]+$side+".legAim") ("IK"+$ms[$i]+"LegAimUnitConversion"+$side+".input");

		createNode -n ("IK"+$ms[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
		connectAttr ("IK"+$ms[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$ms[$i]+"LegAimMultiplyDivide"+$side+".input1X");
		connectAttr ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".output") ("IK"+$ms[$i]+"LegAimMultiplyDivide"+$side+".input2X");

		createNode -n ("IK"+$ms[$i]+"LegAimReverse"+$side) reverse;
		connectAttr ("IK"+$ms[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$ms[$i]+"LegAimReverse"+$side+".inputX");
		connectAttr ("IK"+$ms[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$msScapula[$i]+$side+"_orientConstraint1.LegAimOn"+$msScapula[$i]+$side+"W1");
		connectAttr ("IK"+$ms[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$msScapula[$i]+$side+"_orientConstraint1.LegAimOff"+$msScapula[$i]+$side+"W0");
		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i] || $markers[$i]==$msToes[$i])
			continue;refresh;

		if ($markerInIK[$i])
			{
			createNode -n ("ScaleBlend"+$markers[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$markers[$i]+$side+".color1") 1 1 1;
			connectAttr ("FK"+$msUfcWhich[$i]+$side+".scale") ("ScaleBlend"+$markers[$i]+$side+".color2");
			connectAttr ("ScaleBlend"+$markers[$i]+$side+".output") ($markers[$i]+$side+".scale");
			connectAttr ("FKIKBlend"+$ms[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$markers[$i]+$side+".blender");
			}
		else
			connectAttr ("FK"+$msUfcWhich[$i]+$side+".scale") ($markers[$i]+$side+".scale");
		if ($msComponent[$i]=="end")
			{
			if ($msSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$ms[$i]+$side+".scale") ("ScaleBlend"+$markers[$i]+$side+".color1");
				connectAttr ("IK"+$ms[$i]+$side+".scale") ("IKX"+$markers[$i]+$side+".scale");
				}
			if ($msSolver[$i]=="ikSplineSolver")
				{
				$systemMarkers=`asGetSystemMarkers ($ms[$i]+"System")`;
				string $reverseSystemMarkers[];
				clear $reverseSystemMarkers;
				for ($y=size($systemMarkers)-1;$y>-1;$y--)
					if (`objExists ("ScaleBlend"+$systemMarkers[$y]+$side)`)
						$reverseSystemMarkers[size($reverseSystemMarkers)]=$systemMarkers[$y];

				for ($y=0;$y<size($reverseSystemMarkers);$y++)
					{
					createNode -n ("IKScaler"+$reverseSystemMarkers[$y]+$side) -p IKHandle transform;
					createNode -n ("IKScale"+$reverseSystemMarkers[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$reverseSystemMarkers[$y]+$side+".scale") ("IKScale"+$reverseSystemMarkers[$y]+"MultiplyDivide"+$side+".input1");
					connectAttr ("IKScale"+$reverseSystemMarkers[$y]+"MultiplyDivide"+$side+".output") ("ScaleBlend"+$reverseSystemMarkers[$y]+$side+".color1");		

					for ($z=0;$z<$msNic[$i];$z++)
						{
		        float $yy=(1.0/(size($reverseSystemMarkers)-1))*$y;
		        float $zz=(1.0/($msNic[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=`	smoothstep 0.5 1 $weight`;
//print (" IKScaler"+$reverseSystemMarkers[$y]+" : IK"+$ms[$i]+($z+1)+$side+" : "+$weight+", $yy="+$yy+" (1.0/"+(`size($reverseSystemMarkers)`-1)+"*"+$y+") , $zz="+$zz+"\n");
						scaleConstraint -w $weight ("IK"+$ms[$i]+($z+1)+$side) ("IKScaler"+$reverseSystemMarkers[$y]+$side);
						}
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($msComponent[$i]!="end")
			continue;
		if ($msSolver[$i]!="ikRPsolver")
			continue;refresh;
		if (`asIsMayaLT`)
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$ms[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$ms[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$ms[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$ms[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$ms[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$ms[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$ms[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$ms[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$ms[$i]+$side+".stretchy") ("IKSetRangeStretch"+$ms[$i]+$side+".valueX");
		connectAttr ("IK"+$ms[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$ms[$i]+$side+".valueX");

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc1"+$ms[$i]+$side);
		setAttr -l 1 ("IKmessureLoc1"+$ms[$i]+$side+".visibility") 0;
		pointConstraint ("IKX"+$msStart[$i]+$side)  ("IKmessureLoc1"+$ms[$i]+$side);
		parent ("IKmessureLoc1"+$ms[$i]+$side) ("IKMessure");
		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc2"+$ms[$i]+$side);
		setAttr -l 1 ("IKmessureLoc2"+$ms[$i]+$side+".visibility") 0;
		asAlign ("IKmessureLoc2"+$ms[$i]+$side) ("IK"+$ms[$i]+"Handle"+$side) 1 0 0 0;
		parent ("IKmessureLoc2"+$ms[$i]+$side) ("IKmessureLoc1"+$ms[$i]+$side);

		createNode -n ("IKmessureConstrainTo"+$ms[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$ms[$i]+$side) ("IK"+$ms[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$ms[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$ms[$i]+$side) $tempString[0];
		pointConstraint ("IKmessureConstrainTo"+$ms[$i]+$side)  ("IKmessureLoc2"+$ms[$i]+$side);

		createNode -n ("IKdistance"+$ms[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistance"+$ms[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistance"+$ms[$i]+$side);
		parent ("IKdistance"+$ms[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistance"+$ms[$i]+$side+".visibility") 0;
		connectAttr ("IKmessureLoc2"+$ms[$i]+$side+".translate") ("IKdistance"+$ms[$i]+$side+".endPoint");
		createNode -n ("IKmessureDiv"+$ms[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$ms[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$ms[$i]+$side+".input2X") $msLenght[$i];

		$distance=`getAttr ("IKdistance"+$ms[$i]+$side+".distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$ms[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$ms[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$ms[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$ms[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $msLenght[$i] -dv $msLenght[$i] -cd ("IKdistance"+$ms[$i]+$side+".distance") ("IKdistance"+$ms[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $msLenght[$i] -f ($msLenght[$i]*0.1) ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($msLenght[$i]*1.2) -f ($msLenght[$i]*1.2) ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $msLenght[$i] -f ($msLenght[$i]*0.70) ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($msLenght[$i]*0.9) -f ($msLenght[$i]*0.85) ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$ms[$i]+$side+"Shape_normal") ("IKdistance"+$ms[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$ms[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$ms[$i]+$side+".distance") ("IKdistance"+$ms[$i]+$side+"Shape_normal.input");

		connectAttr ("IKdistance"+$ms[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$ms[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$ms[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$ms[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$ms[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$ms[$i]+$side+".maxR") $msLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$ms[$i]+$side+".output") ("IKdistanceClamp"+$ms[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$ms[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$ms[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$ms[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$ms[$i]+$side+".outputR") ("IKmessureBlendStretch"+$ms[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$ms[$i]+$side+".output") ("IKmessureBlendStretch"+$ms[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$ms[$i]+$side+".output") ("IKmessureDiv"+$ms[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max 10 ("Pole"+$ms[$i]+$side);
		createNode -n ("Pole"+$ms[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("Pole"+$ms[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Pole"+$ms[$i]+$side+".lock") ("Pole"+$ms[$i]+"UnitConversion"+$side+".input");

		$tempString[0]=("IKX"+$msStart[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".translateX")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$ms[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
//			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ($tempString[0]+".translateX");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$ms[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$ms[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");
/*
			if ($a==1)
				{
				createNode -n ("ScaleBlendAddX"+$msMid[$i]+$side) plusMinusAverage;
				connectAttr ("IK"+$ms[$i]+$side+".Lenght"+($a+1)) ("ScaleBlendAddX"+$msMid[$i]+$side+".input1D[0]");
				connectAttr ("IKmessureDiv"+$ms[$i]+$side+".outputX") ("ScaleBlendAddX"+$msMid[$i]+$side+".input1D[1]");
				setAttr ("ScaleBlendAddX"+$msMid[$i]+$side+".input1D[2]") -1;
				connectAttr ("ScaleBlendAddX"+$msMid[$i]+$side+".output1D") ("ScaleBlend"+$msMid[$i]+$side+".color1R");
				}
*/
			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".translateX");
			connectAttr ("Pole"+$ms[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$ms[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($a==0)
				connectAttr ("IKMessureFrom"+$msStart[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			else
				connectAttr ("IK"+$ms[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
//			connectAttr ($tempString[0]+"Distance.distance") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr Main.sy ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");;

			if ($tempString[0]==("IKX"+$msEnd[$i]+$side))
				break;
			}
		}


//Avanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootSystem;
createNode -n RootZeroXform transform;
parent RootZeroXform RootX_M;
parentConstraint RootZeroXform FKSystem;
parentConstraint RootZeroXform IKRootConstraint;
//HipSwinger
int $buildHipSwinger;
if (`objExists Spine1_M`)
	{
	$tempString=`listRelatives -type joint -p Spine1_M`;
	if ($tempString[0]=="Root_M")
		$buildHipSwinger=1;
	if (!`objExists FKOffsetSpine1_M`) //no hipswinger with reduced FK-controls..yet
		$buildHipSwinger=0;
	}
if ($buildHipSwinger)
	{
	createNode -n HipSwingerGroupRoot_M transform;
	asAlign HipSwingerGroupRoot_M Spine1_M 1 1 0 1;
	duplicate -n HipSwingerStabalizeRoot_M HipSwingerGroupRoot_M;
	duplicate -n HipSwingerGroupOffsetRoot_M HipSwingerGroupRoot_M;
	parent HipSwingerGroupRoot_M HipSwingerGroupOffsetRoot_M;
	parent HipSwingerGroupOffsetRoot_M FKXOffsetRoot_M;
	parent HipSwingerStabalizeRoot_M FKXRoot_M;
	orientConstraint FKRoot_M HipSwingerStabalizeRoot_M;
	parent FKXRoot_M HipSwingerGroupRoot_M;

	asCreateController "HipSwinger" "" "_M" "Spine1";
	asAlign HipSwingerOffset_M HipSwingerGroupOffsetRoot_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;

	parent HipSwingerOffset_M FKRoot_M;
	parent FKOffsetSpine1_M HipSwingerStabalizeRoot_M;

	connectAttr HipSwinger_M.r HipSwingerGroupRoot_M.r;

	$pos=`xform -q -ws -t Root`;
	xform -ws -t ($pos[0]+(`getAttr Root.sz`*$scale*-2)) ($pos[1]+(`getAttr Root.sz`*$scale)) $pos[2] HipSwingerOffset_M;
//	setAttr HipSwingerOffset_M.tx (`getAttr Root.sz`*$scale);
//	setAttr HipSwingerOffset_M.tz (`getAttr Root.sz`*-2*$scale);
	asLockAttr HipSwinger_M 1 0 1 0;
	}

//CenterBetweenFeet
string $ikLegs[];
$tempString=`ls "IKLeg*_*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im ControlSet $tempString[$i]`)
		$ikLegs[size($ikLegs)]=$tempString[$i];
if (size($ikLegs))
	{
	createNode -n RootCenterBtwLegsBlended_M transform;
	asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
	parent RootCenterBtwLegsBlended_M RootSystem;
	parent RootOffsetX_M RootCenterBtwLegsBlended_M;
	createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
	asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
	duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
	duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
	for ($i=0;$i<size($ikLegs);$i++)
		{
		pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
		orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
		}
	parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
	parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
	createNode -n CenterBtwLegsUnitConversion unitConversion;
	setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
	addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
	createNode -n CenterBtwLegsUnitReverse reverse;
	connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
	connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
	connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
	createNode -n CenterBtwLegsNodeStateSetRange setRange;
	setAttr CenterBtwLegsNodeStateSetRange.minX 1;
	setAttr CenterBtwLegsNodeStateSetRange.oldMaxX 0.1;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateSetRange.valueX;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_pointConstraint1.nodeState;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_orientConstraint1.nodeState;
	}
//Locking
asLockAttr FKRoot_M 1 0 0 0;
asLockAttr FKExtraRoot_M 1 0 0 0;
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1 && $markerChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;
		if ($markerTwists[$i])
			catchQuiet (`delete ($markers[$i]+$side+"_parentConstraint1")`);
		else if (!$markerUpTwists[$i])
			continue;refresh;

		asCreateUnTwister $markers[$i] $side $markerParent[$i] $parentSide $ms[$i] $b 0 "";

		if ($markerTwists[$i])
			{
			asConstraintToFKIK "point" $ms[$i] ("FKX"+$markers[$i]+$side) ("IKX"+$markers[$i]+$side) ($markers[$i]+$side);
			parent ($markers[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$markerTwists[$i]+1;
		if ($markerUpTwists[$i] && !$markerTwists[$i])
			$numTwisters=$markerUpTwists[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			createNode -n ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side) multiplyDivide;
			createNode -n ("twistAddition"+$markers[$i]+"Part"+$y+$side) plusMinusAverage;
			createNode -n ("Twister"+$markers[$i]+$y+$side) -p ("UnTwist"+$markers[$i]+$side) transform;

			if ($markerTwists[$i])
				{
				if ($y==0)
					$joint=$markers[$i]+$side;
				else
					$joint=$markers[$i]+"Part"+$y+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($markerTwists[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$markers[$i]+"Part"+$y+$side+".input1D[1]");
				orientConstraint ("Twister"+$markers[$i]+$y+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

			connectAttr ("TwistBalancer"+$markers[$i]+$side+".rotateX") ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$markers[$i]+"Part"+$y+$side+".input1D[0]");
			connectAttr ("twistAddition"+$markers[$i]+"Part"+$y+$side+".output1D") ("Twister"+$markers[$i]+$y+$side+".rotateX");
			}
		}

//Advanced Twist ($markerUpTwists)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;

		if ($markerUpTwists[$i] && !$markerTwists[$i])
			for ($y=0;$y<$markerUpTwists[$i]+1;$y++)
				{
				if ($y==0)
					$joint=$markerParent[$i]+$parentSide;
				else
					$joint=$markerParent[$i]+"Part"+$y+$parentSide;
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side+".input2X");
				connectAttr ("twistAmountDivide"+$markers[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$markerParent[$i]+"Part"+$y+$parentSide+".input1D[2]");
//				connectAttr -f ("TwistBalancer"+$markers[$i]+$side+".rotateX") ("twistAmountDivide"+$markerParent[$i]+"Part"+$y+$parentSide+".input1X");
				}
		}

//Advanced BendControls
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1 && $markerChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;
		if (!$markerBendControls[$i])
			continue;

		string $crvCmd="curve -n Bend"+$markers[$i]+"Curve"+$side+" -d 3";
		for ($z=0;$z<5;$z++)
			 $crvCmd+=" -p 0 0 0";
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$markers[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$markers[$i]+"Curve"+$side+"Shape");
		setAttr ("Bend"+$markers[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$markers[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$markers[$i]+"Curve"+$side) BendSystem;

		createNode -n ("BendParentConstraint"+$markers[$i]+$side) -p BendSystem transform;
		asConstraintToFKIK "parent" $ms[$i] ("FKX"+$markers[$i]+$side) ("IKX"+$markers[$i]+$side) ("BendParentConstraint"+$markers[$i]+$side);
		asConstraintToFKIK "scale" $ms[$i] ("FKX"+$markers[$i]+$side) ("IKX"+$markers[$i]+$side) ("BendParentConstraint"+$markers[$i]+$side);

		createNode -n ("BendParentConstraintOffset"+$markers[$i]+$side) -p BendSystem transform;
		asAlign ("BendParentConstraintOffset"+$markers[$i]+$side) ("BendParentConstraint"+$markers[$i]+$side) 1 1 0 0;
		parent ("BendParentConstraint"+$markers[$i]+$side) ("BendParentConstraintOffset"+$markers[$i]+$side);

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			spaceLocator -n ("Bend"+$markers[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("Bend"+$markers[$i]+"Locator"+$z+$side+".v") 0;
			connectAttr ("Bend"+$markers[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("Bend"+$markers[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

			float $posFactor=(1.0/4.0)*$z;

			float $invPosFactor=1-$posFactor;
			$tempString=`pointConstraint -w $invPosFactor ($markers[$i]+$side) ("Bend"+$markers[$i]+"Locator"+$z+$side)`;
			pointConstraint -w $posFactor ($markerChild[$i]+$childSide) ("Bend"+$markers[$i]+"Locator"+$z+$side);
			delete $tempString[0];

			if ($z==0)//Start
				parent ("Bend"+$markers[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$markers[$i]+$side);
			if ($z==2 || $z==0)//Controllers
				{
				asCreateController "Bend" ($markers[$i]+$bendControlNr) $side $markers[$i];
				parent ("BendOffset"+$markers[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$markers[$i]+$bendControlNr+$side) ("Bend"+$markers[$i]+"Locator"+$z+$side) 1 0 0 0;
				asAlign ("BendOffset"+$markers[$i]+$bendControlNr+$side) ("FK"+$markers[$i]+$side) 0 1 0 0;
				parent ("BendOffset"+$markers[$i]+$bendControlNr+$side) ("BendParentConstraint"+$markers[$i]+$side);
				parent ("Bend"+$markers[$i]+"Locator"+$z+$side) ("Bend"+$markers[$i]+$bendControlNr+$side);
				$rot=`xform -q -ws -ro ($markers[$i]+$side)`;
				if ($D=="x") xform -s 0.1 1 1 ("Bend"+$markers[$i]+$bendControlNr+$side+".cv[0:99]");
				if ($D=="y") xform -s 1 0.1 1 ("Bend"+$markers[$i]+$bendControlNr+$side+".cv[0:99]");
				if ($D=="z") xform -s 1 1 0.1 ("Bend"+$markers[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			if ($z==0)//Create BendStiff node
				{
				createNode -n ("BendStiff"+$markers[$i]+$side) setRange;
				setAttr ("BendStiff"+$markers[$i]+$side+".minX") 0;setAttr ("BendStiff"+$markers[$i]+$side+".minY") 1;
				setAttr ("BendStiff"+$markers[$i]+$side+".maxX") 1;setAttr ("BendStiff"+$markers[$i]+$side+".maxY") 0;
				setAttr ("BendStiff"+$markers[$i]+$side+".oldMinX") -10;setAttr ("BendStiff"+$markers[$i]+$side+".oldMinY") -10;
				setAttr ("BendStiff"+$markers[$i]+$side+".oldMaxX") 10;setAttr ("BendStiff"+$markers[$i]+$side+".oldMaxY") 10;
				}
			if ($z==2)//`Bezier handles`(stiffness)
				{
				addAttr -k 1 -ln stiff -at double -min -10 -max 10 -dv 0 ("Bend"+$markers[$i]+"2"+$side);
				connectAttr ("Bend"+$markers[$i]+"2"+$side+".stiff") ("BendStiff"+$markers[$i]+$side+".valueX");
				}

			if ($z==1 || $z==3)//`Bezier handles`(stiffness)
				{
				createNode -n ("Bend"+$markers[$i]+"BezOff"+$z+$side) -p ("BendParentConstraint"+$markers[$i]+$side) transform;
				if ($z==1)
					parent ("Bend"+$markers[$i]+"BezOff"+$z+$side) ("Bend"+$markers[$i]+"1"+$side);
				if ($z==3 && `objExists ("Bend"+$markerParent[$i]+"BezOff"+$z+$side)` && `objExists ("Bend"+$markers[$i]+"1"+$side)`)
					{
					createNode -n ("Bend"+$markerParent[$i]+"BezOffOffset"+$z+$side) -p ("BendParentConstraint"+$markers[$i]+$side) transform;
					pointConstraint ("Bend"+$markers[$i]+"1"+$side) ("Bend"+$markerParent[$i]+"2"+$parentSide) ("Bend"+$markerParent[$i]+"BezOffOffset"+$z+$side);
					parent ("Bend"+$markerParent[$i]+"BezOff"+$z+$side) ("Bend"+$markerParent[$i]+"BezOffOffset"+$z+$side);
					}

				asAlign ("Bend"+$markers[$i]+"BezOff"+$z+$side) ("Bend"+$markers[$i]+"Locator"+$z+$side) 1 1 0 0;
				duplicate -n ("Bend"+$markers[$i]+"BezOn"+$z+$side) ("Bend"+$markers[$i]+"BezOff"+$z+$side);
				parent ("Bend"+$markers[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$markers[$i]+$side);
				pointConstraint ("Bend"+$markers[$i]+"BezOn"+$z+$side) ("Bend"+$markers[$i]+"BezOff"+$z+$side) ("Bend"+$markers[$i]+"Locator"+$z+$side);

				connectAttr ("BendStiff"+$markers[$i]+$side+".outValueX") ("Bend"+$markers[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$markers[$i]+"BezOn"+$z+$side+"W0");
				connectAttr ("BendStiff"+$markers[$i]+$side+".outValueY") ("Bend"+$markers[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$markers[$i]+"BezOff"+$z+$side+"W1");

				}
			if ($z==4)
				parent ("Bend"+$markers[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$markers[$i]+$side);
			if ($z==3)
				{
				parent ("Bend"+$markers[$i]+"BezOn"+"1"+$side) ("Bend"+$markers[$i]+"2"+$side);
				parent ("Bend"+$markers[$i]+"BezOn"+"3"+$side) ("Bend"+$markers[$i]+"2"+$side);
				}
			}

		//connect to twistJoints
		for ($y=0;$y<($markerTwists[$i]+1);$y++)
			{

			if ($y==0)
				$joint=$markers[$i]+$side;
			else
				{
				$joint=$markers[$i]+"Part"+$y+$side;
				delete ($joint+"_orientConstraint1");
				}
			if ($y==0)
				delete (`listConnections -s 1 -d 0 ($markers[$i]+$side+".tx")`);//could be point or parent constraint

			//bend hookup
			if ($y==0)
				{
				pointConstraint ("Bend"+$markers[$i]+"1"+$side) $joint;				
				parent ($joint+"_pointConstraint1") ConstraintSystem;			
				}
			else
				{
				createNode -n ($markers[$i]+"PointOnCurveInfo"+$y+$side) pointOnCurveInfo;
				connectAttr -f ("Bend"+$markers[$i]+"Curve"+$side+"Shape.worldSpace[0]") ($markers[$i]+"PointOnCurveInfo"+$y+$side+".inputCurve");
				createNode -p BendSystem -n ($markers[$i]+"PointOnCurveXform"+$y+$side) transform;
				connectAttr -f ($markers[$i]+"PointOnCurveInfo"+$y+$side+".position") ($markers[$i]+"PointOnCurveXform"+$y+$side+".t");
//				setAttr ($markers[$i]+"PointOnCurveInfo"+$y+$side+".turnOnPercentage") 1;
				//make tempSurface, so a closestPointOnSurface node can find $parameter
				extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 ("Bend"+$markers[$i]+"Curve"+$side);
				createNode -n tempClosestPointOnSurface closestPointOnSurface;
				spaceLocator -n tempClosestPointOnSurfaceLoc;
				connectAttr tempSurface.worldSpace[0] tempClosestPointOnSurface.inputSurface;
				connectAttr tempClosestPointOnSurfaceLoc.worldPosition[0] tempClosestPointOnSurface.inPosition;
				pointConstraint ($markers[$i]+$side) ($markerChild[$i]+$childSide) tempClosestPointOnSurfaceLoc;
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$markers[$i]+$side+"W0") (1-((1.0/($markerTwists[$i]+1.0))*$y));
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$markerChild[$i]+$childSide+"W1")((1.0/($markerTwists[$i]+1.0))*$y);
				float $parameter=`getAttr tempClosestPointOnSurface.parameterU`;
				delete tempClosestPointOnSurface tempSurface tempClosestPointOnSurfaceLoc;
				setAttr ($markers[$i]+"PointOnCurveInfo"+$y+$side+".parameter") $parameter;

				pointConstraint ($markers[$i]+"PointOnCurveXform"+$y+$side) $joint;
				parent ($joint+"_pointConstraint1") ConstraintSystem;	
				tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$markers[$i]+$y+$side) ("Bend"+$markers[$i]+"Curve"+$side) $joint;
				parent ($joint+"_tangentConstraint1") ConstraintSystem;
				}
			}
		}

//Advanced BendControls (attached to parent)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$parentSide=$markerParentSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1 && $markerChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if ($markerIsEndJoint[$i])
			continue;

		if ($markerUpBendControls[$i])
			{
			if (!$markerBendControls[$i])//e.g. wrist
				asConstraintToFKIK "parent" $ms[$i] ("FKX"+$markers[$i]+$side) ("IKX"+$markers[$i]+$side) ("Bend"+$markerParent[$i]+"Locator"+"4"+$parentSide);
			if ($markerBendControls[$i])//e.g. elbow
				parent ("Bend"+$markerParent[$i]+"Locator"+"4"+$parentSide) ("Bend"+$markers[$i]+"1"+$side);
			}

		//twisty bendControls
		for ($y=0;$y<($markerTwists[$i]+1);$y++)
			{
			if (!$markerBendControls[$i])
				continue;
			//startTwister
			createNode -n ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$markers[$i]+"1"+$side+".rx") ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($markerTwists[$i]+0.00))*$y);
			connectAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$markers[$i]+"Part"+$y+$side+".input1D[3]");
			//midTwister
			createNode -n ("BendTwistMult"+$markers[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$markers[$i]+"2"+$side+".rx") ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input1Y");
			float $hf=(1.0/$markerTwists[$i])*$y*2;
			if ($y>$markerTwists[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			connectAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$markers[$i]+"Part"+$y+$side+".input1D[4]");
			//endTwister
			if (`objExists ("Bend"+$markerChild[$i]+"1"+$childSide+".rx")`)
				{
				connectAttr ("Bend"+$markerChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($markerTwists[$i]+0.00))*$y);
				connectAttr ("BendTwistMult"+$markers[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$markers[$i]+"Part"+$y+$side+".input1D[5]");
				}
			}
		}

//Advanced distribution of twistJoints (non-bendControls
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		$childSide=$markerChildSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1 && $markerChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerTwists[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($markers[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$markerChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$markerChild[$i]+$childSide)`)
			continue;

		string $contraintTo="FKX"+$markerChild[$i]+$childSide;
		if ($markerInIK[$i])
			{
			$contraintTo=("FKIKMix"+$markerChild[$i]+$childSide);
			createNode -n $contraintTo -p TwistSystem transform;
			if (`objExists $contraintTo`)
				asConstraintToFKIK "point" $ms[$i] ("FKX"+$markerChild[$i]+$childSide) ("IKX"+$markerChild[$i]+$childSide) $contraintTo;
			}

		if (!$markerBendControls[$i])
			for ($y=1;$y<$markerTwists[$i]+1;$y++)
				if (`objExists $contraintTo`)
					{
					pointConstraint $contraintTo ($markers[$i]+$side) ($markers[$i]+"Part"+$y+$side);
					parent ($markers[$i]+"Part"+$y+$side+"_pointConstraint1") ConstraintSystem;	
					setAttr ($markers[$i]+"Part"+$y+$side+"_pointConstraint1."+$contraintTo+"W0") ($y/($markerTwists[$i]+1.0));
					setAttr ($markers[$i]+"Part"+$y+$side+"_pointConstraint1."+$markers[$i]+$side+"W1") (1-($y/($markerTwists[$i]+1.0)));
					}
		}


//volume (Squash Scaling) - `IK setup` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($msComponent[$i]!="end")
			continue;
		if (`asIsMayaLT`)
			continue;

		$ikHandle = ("IK"+$ms[$i]+$side);
		if ($msSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$ms[$i]+$msNic[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$ms[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("volume"+$ms[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$ms[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$ms[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$ms[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$ms[$i]+$side+".input1X");
		if ($msSolver[$i]=="ikSplineSolver")
			connectAttr ("stretchy"+$ms[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$ms[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$ms[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$ms[$i]+$side+".operation") 2;
		if ($msSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$ms[$i]+$side+".outputX") ("volume1Over"+$ms[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$ms[$i]+$side+".outputX") ("volume1Over"+$ms[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$ms[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$ms[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$ms[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$ms[$i]+$side+".outputX") ("volumepow"+$ms[$i]+$side+".input1X");
		setAttr ("volumepow"+$ms[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$ms[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$ms[$i]+$side+".outputX") ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$ms[$i]+$side+".outputX") ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($markerIsEndJoint[$i] || $markers[$i]=="Root")
			continue;
		if ($msComponent[$i]=="end" || $msComponent[$i]=="toes")
			continue;
		if (`asIsMayaLT`)
			continue;

		if (`objExists ("IKScale"+$markers[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".output") ("IKScale"+$markers[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".output") ("IKScale"+$markers[$i]+"MultiplyDivide"+$side+".input2Z");
			}
		else
			{
			connectAttr ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".output") ("ScaleBlend"+$markers[$i]+$side+".color1.color1G");
			connectAttr ("volumeBlend"+$ms[$i]+"BlendTwo"+$side+".output") ("ScaleBlend"+$markers[$i]+$side+".color1.color1B");
			}
		}



connectAttr -f jointLayer.drawInfo FKOffsetRoot_M.drawOverride;

//Custom cotroller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!`objExists ($markers[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($markers[$i]+$side)`;
		$rot=`xform -q -ws -ro ($markers[$i]+$side)`;
		$sca=`xform -q -r -s $markers[$i]`;

		//Head
		if (`gmatch $markers[$i] "*Head*"` && $markerChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $markerChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$markers[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$markers[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$markers[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($markers[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$markers[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if ($msType[$i]=="Leg" && $msComponent[$i]=="end")
			{
			int $numCVs=`getAttr ("IK"+$ms[$i]+$side+".spans")`+`getAttr ("IK"+$ms[$i]+$side+".degree")`;
			for ($y=0;$y<$numCVs;$y++)
				{
				$temp=`xform -q -ws -t ("IK"+$ms[$i]+$side+".cv["+$y+"]")`;
				$temp2=`xform -q -ws -t ("IKX"+$msEnd[$i]+$side)`;
				$temp3=`xform -q -ws -t ($msToesEnd[$i]+$side)`;
				if ($temp[1]<$temp2[1])
					{
					xform -ws -t $temp[0] 0 $temp[2] ("IK"+$ms[$i]+$side+".cv["+$y+"]");
					if ($temp[2]>$temp2[2])
						xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$ms[$i]+$side+".cv["+$y+"]");
					}
				}
			$temp=`xform -q -ws -t ($msEnd[$i]+$side)`;
			rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotY[$i]*$b) 0 ("IK"+$ms[$i]+$side+".cv[0:99]");
			}
		//Scapula
		if (`gmatch $markers[$i] "Scapula*"`)
			xform -r -ws -t ($markerLenght[$i]*-0.5) 0 0 ("FK"+$markers[$i]+$side+".cv[0:99]");
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($markers);$i++)
		{
		$side=$markerSide[$i];
		if ($b==-1 && $markerSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $markerNoMirror[$i]) continue;

		if (!$markerInIK[$i])
			continue;
		if ($msComponent[$i]!="end")
			continue;

		if ($msType[$i]=="Leg")
			{
			//Legs in IK
			setAttr ("FKIK"+$ms[$i]+$side+".FKIKBlend") 10;
			//Legs have pole follow
			setAttr ("Pole"+$ms[$i]+$side+".follow") 10;
			}
		if ($msType[$i]=="Tail")
			setAttr ("IK"+$ms[$i]+$msNic[$i]+$side+".fixedEnd") 0;
		if ($msType[$i]=="Tail" || $msType[$i]=="Basic")
			{
			//IK tail stiffness, start = 5 & end= 0, and follow=10 for first
			setAttr ("IK"+$ms[$i]+"1"+$side+".stiff") 5;
			setAttr ("IK"+$ms[$i]+$msNic[$i]+$side+".stiff") 0;
			if (`attributeExists follow ("IK"+$ms[$i]+"1"+$side)`)
				setAttr ("IK"+$ms[$i]+"1"+$side+".follow") 10;
			}
		}

delete "iconsGroup";

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  ("buildPose");
setAttr -type "string" ("buildPose.udAttr") $setAttrCmd;

//height
string $markers[]=`asGetMarkers`;
float $highestMarker=0;
float $lowestMarker=99;
for ($i=0;$i<size($markers);$i++)
	{
	$pos=`xform -q -ws -t $markers[$i]`;
	if ($pos[1]>$highestMarker)
		$highestMarker=$pos[1];
	if ($pos[1]<$lowestMarker)
		$lowestMarker=$pos[1];
	}
float $height=$highestMarker-$lowestMarker;
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//set joint-size to match height
jointDisplayScale (0.005*$height);

//DrivingSystems (from FitSkeleton)
if (`objExists DrivingSystem`)//delete remainers of existing first
	delete DrivingSystem;
string $straySDKs[]=`ls -type transform "SDK*"`;
for ($i=0;$i<size($straySDKs);$i++)
	if (`gmatch $straySDKs[$i] "SDK[0-9]*"` && !`gmatch $straySDKs[$i] "prefix_*"`)
		{
		$tempString=`listRelatives -c $straySDKs[$i]`;
		if (!size($tempString))
			delete $straySDKs[$i];
		}
string $drivingSystem;
string $systems[]=`listRelatives -c Systems`;
string $drivenObjs[],$drivenObjAltPivots[],$drivenObjAttrs[],$drivingSystemDrivers[],$fitDrivingSystems[],$fitDrivingSystemDrivers[],$sdks[],$sdkObj[],$sdkAttrs[];
clear $fitDrivingSystems;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		$fitDrivingSystems[size($fitDrivingSystems)]=$systems[$i];
for ($i=0;$i<size($fitDrivingSystems);$i++)
	{
	$drivingSystem=`substitute "DS_" $fitDrivingSystems[$i] ""`;
	$fitDrivingSystemDrivers=`listRelatives -c $fitDrivingSystems[$i]`;
	for ($y=0;$y<size($fitDrivingSystemDrivers);$y++)
		{
		//analyze
		$sdks=`listConnections -scn 1 -s 1 -d 0 $fitDrivingSystemDrivers[$y]`;
		clear $drivenObjs;
		clear $drivenObjAltPivots;
		for ($z=0;$z<size($sdks);$z++)
			{
			$drivenObjAttr=`substitute "prefix_" $sdks[$z] ""`;
			$drivenObjAttr=`substitute "Fit_" $drivenObjAttr ""`;
			$drivenObjAttrs[size($drivenObjAttrs)]=$drivenObjAttr;
			tokenize $drivenObjAttr "_" $tempString2;
			$sdkObj[$z]="";
			for ($zz=0;$zz<size($tempString2)-1;$zz++)
				{
				$sdkObj[$z]=$sdkObj[$z]+$tempString2[$zz];
				if ($zz<size($tempString2)-2)
					$sdkObj[$z]=$sdkObj[$z]+"_";
				}
			$sdkAttrs[$z]=$tempString2[size($tempString2)-1];
			$drivenObj=$sdkObj[$z];
			int $startSub=5;
			string $fiftLetter=`substring $drivenObj 5 5`;
			if (`gmatch $fiftLetter "[0-9]"`)
				$startSub=6;
			$drivenObj=`substring $drivenObj $startSub 99`;
			if (!`stringArrayCount $drivenObj $drivenObjs` && `objExists $drivenObj`)
				{
				$drivenObjs[size($drivenObjs)]=$drivenObj;
				if (`attributeExists altPivot $sdks[$z]`)
					$drivenObjAltPivots[size($drivenObjAltPivots)]=`getAttr ($sdks[$z]+".altPivot")`;
				}
		}

		//make
		if (!`objExists $drivingSystem`)
			asCreateDrivingSystemController $drivingSystem $drivenObjs;
		$attrName=`substitute ("DS_"+$drivingSystem+"_") $fitDrivingSystemDrivers[$y] ""`;
		addAttr -k 1 -ln $attrName -at double $drivingSystem;
		asCopyAttrProperties ("DS_"+$drivingSystem+"."+$attrName) ($drivingSystem+"."+$attrName);
		for ($z=0;$z<size($drivenObjs);$z++)
			{
			if ($drivenObjAltPivots[$z]!="")
				$asDSAltPivot=$drivenObjAltPivots[$z];
			$sdkXform=`asCreateSDKXform $drivenObjs[$z]`;
			$asDSAltPivot="";
			}
		$asDSAltPivot="";
		for ($z=0;$z<size($sdks);$z++)
			{
			if (!`objExists $sdkObj[$z]`)
				continue;
			$newSdk=`substitute "prefix_" $sdks[$z] ""`;
			$newSdk=`substitute "Fit_" $newSdk ""`;
			duplicate -n $newSdk $sdks[$z];
			connectAttr -f ($drivingSystem+"."+$attrName) ($newSdk+".input");
			connectAttr -f ($newSdk+".output") ($sdkObj[$z]+"."+$sdkAttrs[$z]);
			float $keyTimes[]=`keyframe -q -fc $newSdk`;
			addAttr -e -min $keyTimes[0] ($drivingSystem+"."+$attrName);
			addAttr -e -max $keyTimes[size($keyTimes)-1] ($drivingSystem+"."+$attrName);
			}
		}
	}

//buildPose (add DrivingSystems
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd="";
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listRelatives -p $controlSetMembers[$i]`;
	if ($tempString[0]!="DrivingSystem")
		continue;
	$tempString=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" ("buildPose.udAttr") (`getAttr buildPose.udAttr`+";"+$setAttrCmd);

//Ensure mirrored controls
asMirrorControlCurves 0 ControlSet;

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $allNew[];
for ($i=0;$i<size($allAfter);$i++)
	if (!`stringArrayCount $allAfter[$i] $allBefore`)
		{
		if ($allAfter[$i]=="AllSet" || $allAfter[$i]=="Sets" || $allAfter[$i]=="Geometry" || `gmatch $allAfter[$i] "*olver"`)
			continue;
		$allNew[size($allNew)]=$allAfter[$i];
		}
sets -add AllSet $allNew;
sets -rm AllSet `listRelatives -ad FitSkeleton`;
print "// Build Complete\n";
select Main;
}